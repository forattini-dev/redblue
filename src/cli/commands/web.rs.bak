/// Web/asset command - Web application testing
use crate::cli::commands::{print_help, Command, Flag, Route};
use crate::cli::{output::Output, validator::Validator, CliContext};
use crate::intelligence::banner_analysis::analyze_http_server;
use crate::modules::tls::auditor::TlsAuditor;
use crate::modules::web::crawler::WebCrawler;
use crate::modules::web::fingerprinter::WebFingerprinter;
use crate::modules::web::fuzzer::{DirectoryFuzzer, Wordlists};
use crate::modules::web::linkfinder::{EndpointType, LinkFinder};
use crate::protocols::http::HttpClient;
use crate::protocols::tls_cert::{CertificateInfo, TlsClient};
use std::sync::Arc;
use std::time::{Duration, SystemTime};

mod scanning;

pub struct WebCommand;

impl Command for WebCommand {
    fn domain(&self) -> &str {
        "web"
    }

    fn resource(&self) -> &str {
        "asset"
    }

    fn description(&self) -> &str {
        "Web application testing and analysis"
    }

    fn routes(&self) -> Vec<Route> {
        vec![
            Route {
                verb: "get",
                summary: "Execute a raw HTTP GET request",
                usage: "rb web asset get <url>",
            },
            Route {
                verb: "headers",
                summary: "Inspect HTTP response headers",
                usage: "rb web asset headers <url>",
            },
            Route {
                verb: "security",
                summary: "Audit security-related HTTP headers",
                usage: "rb web asset security <url>",
            },
            // TODO: Disabled until TLS implementation is complete
            // Route {
            //     verb: "cert",
            //     summary: "Inspect TLS certificate metadata",
            //     usage: "rb web asset cert <host[:port]>",
            // },
            // Route {
            //     verb: "tls-audit",
            //     summary: "Comprehensive TLS security audit (sslyze-style)",
            //     usage: "rb web asset tls-audit <host[:port]>",
            // },
            Route {
                verb: "fuzz",
                summary: "Run directory fuzzing against the target",
                usage: "rb web asset fuzz <url> --wordlist WORDS",
            },
            Route {
                verb: "fingerprint",
                summary: "Identify web technologies (whatweb-style)",
                usage: "rb web asset fingerprint <url>",
            },
            Route {
                verb: "scan",
                summary: "Vulnerability scan (nikto-style)",
                usage: "rb web asset scan <url>",
            },
            Route {
                verb: "vuln-scan",
                summary: "Active vulnerability scanner (OWASP ZAP-style)",
                usage: "rb web asset vuln-scan <url>",
            },
            Route {
                verb: "wpscan",
                summary: "WordPress security scanner",
                usage: "rb web asset wpscan <url>",
            },
            Route {
                verb: "drupal-scan",
                summary: "Drupal security scanner (droopescan replacement)",
                usage: "rb web asset drupal-scan <url>",
            },
            Route {
                verb: "joomla-scan",
                summary: "Joomla security scanner",
                usage: "rb web asset joomla-scan <url>",
            },
            Route {
                verb: "linkfinder",
                summary: "Extract endpoints from JavaScript files",
                usage: "rb web asset linkfinder <js-url> [--type api|s3|all]",
            },
            Route {
                verb: "crawl",
                summary: "Launch a lightweight crawler (coming soon)",
                usage: "rb web asset crawl <url>",
            },
        ]
    }

    fn flags(&self) -> Vec<Flag> {
        vec![
            Flag::new("timeout", "Request timeout in seconds")
                .with_short('t')
                .with_default("10"),
            Flag::new("user-agent", "Custom User-Agent header").with_short('u'),
            Flag::new("follow", "Follow redirects").with_short('f'),
            Flag::new("wordlist", "Wordlist for fuzzing").with_short('w'),
            Flag::new("threads", "Number of concurrent threads for fuzzing").with_default("50"),
            Flag::new("filter", "Filter out status codes (comma-separated)").with_default("404"),
            Flag::new("match", "Only show status codes (comma-separated)"),
            Flag::new("common", "Use built-in common wordlist"),
            Flag::new(
                "type",
                "Filter linkfinder results by type (api, s3, websocket, graphql, all)",
            ),
            Flag::new(
                "recursive",
                "Enable recursive directory fuzzing (feroxbuster-style)",
            )
            .with_short('r'),
            Flag::new("depth", "Maximum recursion depth for fuzzing").with_default("3"),
            Flag::new(
                "strategy",
                "Scanning strategy: auto (default), wordpress, drupal, joomla, generic",
            )
            .with_short('s')
            .with_default("auto"),
            Flag::new("intel", "Perform HTTP server fingerprinting and intelligence gathering"),
        ]
    }

    fn examples(&self) -> Vec<(&str, &str)> {
        vec![
            ("Simple GET request", "rb web asset get http://example.com"),
            (
                "HTTP server fingerprinting",
                "rb web asset get http://example.com --intel",
            ),
            ("Analyze headers", "rb web asset headers http://example.com"),
            ("Security audit", "rb web asset security http://example.com"),
            // TODO: Disabled until TLS is fixed
            // ("TLS certificate check", "rb web asset cert example.com:443"),
            // ("TLS security audit", "rb web asset tls-audit example.com"),
            (
                "Directory fuzzing (basic)",
                "rb web asset fuzz http://example.com --common",
            ),
            (
                "Recursive fuzzing (feroxbuster-style)",
                "rb web asset fuzz http://example.com --common --recursive --depth 4",
            ),
            (
                "Auto-detect scan (smart)",
                "rb web asset scan http://example.com",
            ),
            (
                "Force WordPress scan",
                "rb web asset scan http://example.com --strategy wordpress",
            ),
        ]
    }

    fn execute(&self, ctx: &CliContext) -> Result<(), String> {
        let verb = ctx.verb.as_ref().ok_or_else(|| {
            print_help(self);
            "No verb provided".to_string()
        })?;

        match verb.as_str() {
            "get" => self.get(ctx),
            "headers" => self.headers(ctx),
            "security" => self.security(ctx),
            // TODO: Disabled until TLS is fixed
            // "cert" => self.cert(ctx),
            // "tls-audit" => self.tls_audit(ctx),
            "fuzz" => self.fuzz(ctx),
            "fingerprint" => self.fingerprint(ctx),
            "scan" => self.scan(ctx),
            "vuln-scan" => self.vuln_scan(ctx),
            "wpscan" => self.wpscan(ctx),
            "drupal-scan" => self.drupal_scan(ctx),
            "joomla-scan" => self.joomla_scan(ctx),
            "linkfinder" => self.linkfinder(ctx),
            "crawl" => self.crawl(ctx),
            _ => {
                Output::error(&format!("Unknown verb: {}", verb));
                println!(
                    "{}",
                    Validator::suggest_command(
                        verb,
                        &[
                            "get",
                            "headers",
                            "security",
                            // "cert", // TODO: Disabled until TLS is fixed
                            // "tls-audit", // TODO: Disabled until TLS is fixed
                            "fuzz",
                            "fingerprint",
                            "scan",
                            "vuln-scan",
                            "wpscan",
                            "drupal-scan",
                            "joomla-scan",
                            "linkfinder",
                            "crawl"
                        ]
                    )
                );
                Err("Invalid verb".to_string())
            }
        }
    }
}

fn render_certificate_summary(label: &str, cert: &CertificateInfo) {
    // Simple status based on string dates
    let status = "Check dates manually".to_string();

    let san_display = if cert.san.is_empty() {
        "-".to_string()
    } else {
        cert.san.join(", ")
    };

    Output::subheader(label);
    Output::item("Subject", &cert.subject);
    Output::item("Issuer", &cert.issuer);
    Output::item("Valid From", &cert.valid_from);
    Output::item("Valid Until", &cert.valid_until);
    Output::item("Serial", &cert.serial_number);
    Output::item("Signature", &cert.signature_algorithm);
    Output::item("Public Key", &cert.public_key_algorithm);
    Output::item("SANs", san_display.as_str());
    Output::item("Status", status.as_str());

    // TODO: Add certificate validation when TLS implementation is complete
    // if expired {
    //     Output::warning("Certificate is expired");
    // } else if not_yet_valid {
    //     Output::warning("Certificate validity period has not started");
    // }
}

fn format_duration(duration: Duration) -> String {
    let total_secs = duration.as_secs();
    if total_secs == 0 {
        return "0s".to_string();
    }

    let days = total_secs / 86_400;
    let hours = (total_secs % 86_400) / 3_600;
    let minutes = (total_secs % 3_600) / 60;
    let seconds = total_secs % 60;

    let mut parts = Vec::new();
    if days > 0 {
        parts.push(format!("{}d", days));
    }
    if hours > 0 {
        parts.push(format!("{}h", hours));
    }
    if minutes > 0 && parts.len() < 2 {
        parts.push(format!("{}m", minutes));
    }
    if seconds > 0 && parts.is_empty() {
        parts.push(format!("{}s", seconds));
    }

    parts.join(" ")
}

impl WebCommand {
    fn guard_plain_http(_url: &str, _command: &str) -> Result<(), String> {
        // HTTPS supported via native TLS 1.2 client
        Ok(())
    }

    fn get(&self, ctx: &CliContext) -> Result<(), String> {
        let url = ctx.target.as_ref().ok_or(
            "Missing URL. Usage: rb web asset get <URL> Example: rb web asset get http://example.com"
        )?;

        Validator::validate_url(url)?;
        Self::guard_plain_http(url, "rb web asset get")?;

        let format = ctx.get_output_format();

        let client = HttpClient::new();

        if format == crate::cli::format::OutputFormat::Human {
            Output::spinner_start("Sending request");
        }

        let response = client
            .get(url)
            .map_err(|e| format!("Request failed: {}", e))?;

        if format == crate::cli::format::OutputFormat::Human {
            Output::spinner_done();
        }

        // JSON output
        if format == crate::cli::format::OutputFormat::Json {
            println!("{{");
            println!("  \"url\": \"{}\",", url);
            println!("  \"status_code\": {},", response.status_code);
            println!("  \"status_text\": \"{}\",", response.status_text);
            println!("  \"body_size\": {},", response.body.len());
            println!("  \"headers\": {{");
            let header_count = response.headers.len();
            for (i, (key, value)) in response.headers.iter().enumerate() {
                let comma = if i < header_count - 1 { "," } else { "" };
                let value_escaped = value.replace('\\', "\\\\").replace('"', "\\\"");
                println!("    \"{}\": \"{}\"{}", key, value_escaped, comma);
            }
            println!("  }}");
            println!("}}");
            return Ok(());
        }

        // YAML output
        if format == crate::cli::format::OutputFormat::Yaml {
            println!("url: {}", url);
            println!("status_code: {}", response.status_code);
            println!("status_text: {}", response.status_text);
            println!("body_size: {}", response.body.len());
            println!("headers:");
            for (key, value) in &response.headers {
                println!("  {}: \"{}\"", key, value.replace('"', "\\\""));
            }
            return Ok(());
        }

        // Human output
        Output::header("HTTP GET Request");
        Output::item("URL", url);
        println!();

        Output::subheader("Response");
        Output::item(
            "Status",
            &format!("{} {}", response.status_code, response.status_text),
        );
        Output::item("Body Size", &format!("{} bytes", response.body.len()));
        println!();

        Output::subheader("Headers");
        for (key, value) in &response.headers {
            Output::item(key, value);
        }

        // HTTP server intelligence gathering
        if ctx.has_flag("intel") {
            println!();
            Output::header("HTTP Server Intelligence");

            // Extract Server header
            if let Some(server_header) = response.headers.get("server") {
                let banner_info = analyze_http_server(server_header);

                // Display vendor
                if let Some(vendor) = &banner_info.vendor {
                    Output::item("Server Software", vendor);
                }

                // Display version
                if let Some(version) = &banner_info.version {
                    Output::item("Version", version);
                }

                // Display OS hints
                if !banner_info.os_hints.is_empty() {
                    Output::item("Operating System", &banner_info.os_hints.join(", "));
                }

                // Display if banner was modified
                if banner_info.is_modified {
                    Output::warning("⚠ Server header appears to be modified/customized");
                }

                // Display custom fields (e.g., build info, modules)
                for (key, value) in &banner_info.custom_fields {
                    let label = key
                        .chars()
                        .enumerate()
                        .map(|(i, c)| {
                            if i == 0 {
                                c.to_uppercase().to_string()
                            } else {
                                c.to_string()
                            }
                        })
                        .collect::<String>();
                    Output::item(&label, value);
                }

                // Display raw banner if modified
                if banner_info.is_modified {
                    Output::item("Raw Server Header", &banner_info.raw_banner);
                }
            } else {
                Output::warning("No Server header found in response");
                Output::info("Server may be hiding version information for security");
            }
        }

        println!();
        if (200..300).contains(&response.status_code) {
            Output::success("Request successful");
        } else if response.status_code >= 400 {
            Output::warning(&format!("Client/Server error: {}", response.status_code));
        }

        Ok(())
    }

    fn headers(&self, ctx: &CliContext) -> Result<(), String> {
        let url = ctx.target.as_ref().ok_or(
            "Missing URL. Usage: rb web asset headers <URL> Example: rb web asset headers http://example.com",
        )?;

        Validator::validate_url(url)?;
        Self::guard_plain_http(url, "rb web asset headers")?;

        let format = ctx.get_output_format();

        let client = HttpClient::new();

        if format == crate::cli::format::OutputFormat::Human {
            Output::spinner_start("Fetching headers");
        }

        let response = client
            .get(url)
            .map_err(|e| format!("Request failed: {}", e))?;

        if format == crate::cli::format::OutputFormat::Human {
            Output::spinner_done();
        }

        // JSON output
        if format == crate::cli::format::OutputFormat::Json {
            println!("{{");
            println!("  \"url\": \"{}\",", url);
            println!("  \"status_code\": {},", response.status_code);
            println!("  \"status_text\": \"{}\",", response.status_text);
            println!("  \"header_count\": {},", response.headers.len());
            println!("  \"headers\": {{");
            let header_count = response.headers.len();
            for (i, (key, value)) in response.headers.iter().enumerate() {
                let comma = if i < header_count - 1 { "," } else { "" };
                let value_escaped = value.replace('\\', "\\\\").replace('"', "\\\"");
                println!("    \"{}\": \"{}\"{}", key, value_escaped, comma);
            }
            println!("  }}");
            println!("}}");
            return Ok(());
        }

        // YAML output
        if format == crate::cli::format::OutputFormat::Yaml {
            println!("url: {}", url);
            println!("status_code: {}", response.status_code);
            println!("status_text: {}", response.status_text);
            println!("header_count: {}", response.headers.len());
            println!("headers:");
            for (key, value) in &response.headers {
                println!("  {}: \"{}\"", key, value.replace('"', "\\\""));
            }
            return Ok(());
        }

        // Human output
        Output::header("HTTP Headers Analysis");
        Output::item("URL", url);
        println!();

        Output::subheader(&format!(
            "Status: {} {}",
            response.status_code, response.status_text
        ));
        println!();

        Output::table_header(&["HEADER", "VALUE"]);
        for (key, value) in &response.headers {
            Output::table_row(&[key, value]);
        }

        println!();
        Output::success(&format!("Found {} headers", response.headers.len()));

        Ok(())
    }

    fn security(&self, ctx: &CliContext) -> Result<(), String> {
        let url = ctx.target.as_ref().ok_or(
            "Missing URL. Usage: rb web asset security <URL> Example: rb web asset security http://example.com",
        )?;

        Validator::validate_url(url)?;
        Self::guard_plain_http(url, "rb web asset security")?;

        let format = ctx.get_output_format();

        let client = HttpClient::new();

        if format == crate::cli::format::OutputFormat::Human {
            Output::spinner_start("Analyzing security");
        }

        let response = client
            .get(url)
            .map_err(|e| format!("Request failed: {}", e))?;

        if format == crate::cli::format::OutputFormat::Human {
            Output::spinner_done();
        }

        let security_headers = vec![
            ("Strict-Transport-Security", "HSTS - Forces HTTPS"),
            ("X-Frame-Options", "Prevents clickjacking"),
            ("X-Content-Type-Options", "Prevents MIME sniffing"),
            ("X-XSS-Protection", "XSS filter"),
            ("Content-Security-Policy", "CSP - Prevents XSS/injection"),
            ("Referrer-Policy", "Controls referrer information"),
            ("Permissions-Policy", "Controls browser features"),
        ];

        // JSON output
        if format == crate::cli::format::OutputFormat::Json {
            println!("{{");
            println!("  \"url\": \"{}\",", url);
            println!("  \"security_headers\": [");
            for (i, (header, description)) in security_headers.iter().enumerate() {
                let comma = if i < security_headers.len() - 1 {
                    ","
                } else {
                    ""
                };
                let present = response.headers.get(*header).is_some();
                println!("    {{");
                println!("      \"header\": \"{}\",", header);
                println!("      \"description\": \"{}\",", description);
                println!("      \"present\": {},", present);
                if present {
                    let value = response.headers.get(*header).unwrap();
                    let value_escaped = value.replace('\\', "\\\\").replace('"', "\\\"");
                    println!("      \"value\": \"{}\"", value_escaped);
                } else {
                    println!("      \"value\": null");
                }
                println!("    }}{}", comma);
            }
            println!("  ]");
            println!("}}");
            return Ok(());
        }

        // YAML output
        if format == crate::cli::format::OutputFormat::Yaml {
            println!("url: {}", url);
            println!("security_headers:");
            for (header, description) in security_headers.iter() {
                let present = response.headers.get(*header).is_some();
                println!("  - header: {}", header);
                println!("    description: {}", description);
                println!("    present: {}", present);
                if present {
                    let value = response.headers.get(*header).unwrap();
                    let value_escaped = value.replace('"', "\\\"");
                    println!("    value: \"{}\"", value_escaped);
                } else {
                    println!("    value: null");
                }
            }
            return Ok(());
        }

        // Human output
        Output::header("Security Headers Audit");
        Output::item("URL", url);
        println!();

        Output::subheader("Security Headers");
        println!();

        for (header, description) in security_headers {
            if let Some(value) = response.headers.get(header) {
                Output::success(&format!("{}: {}", header, value));
                println!("  \x1b[2m{}\x1b[0m", description);
            } else {
                Output::error(&format!("{} is missing", header));
                println!("  \x1b[2m{}\x1b[0m", description);
            }
            println!();
        }

        Ok(())
    }

    fn cert(&self, ctx: &CliContext) -> Result<(), String> {
        let host = ctx.target.as_ref().ok_or(
            "Missing host. Usage: rb web asset cert <HOST[:PORT]> Example: rb web asset cert example.com:443",
        )?;

        let mut parts = host.split(':');
        let hostname = parts.next().unwrap_or(host);
        let port = parts
            .next()
            .unwrap_or("443")
            .parse::<u16>()
            .map_err(|_| format!("Invalid port in host '{}'", host))?;

        let format = ctx.get_output_format();

        let client = TlsClient::new();

        if format == crate::cli::format::OutputFormat::Human {
            Output::spinner_start("Fetching certificate");
        }

        let cert = client.get_certificate(hostname, port)?;

        if format == crate::cli::format::OutputFormat::Human {
            Output::spinner_done();
        }

        // JSON output
        if format == crate::cli::format::OutputFormat::Json {
            println!("{{");
            println!("  \"host\": \"{}\",", hostname);
            println!("  \"port\": {},", port);
            println!("  \"certificate\": {{");
            println!(
                "    \"subject\": \"{}\",",
                cert.subject.replace('"', "\\\"")
            );
            println!("    \"issuer\": \"{}\",", cert.issuer.replace('"', "\\\""));
            println!("    \"valid_from\": \"{}\",", cert.valid_from);
            println!("    \"valid_until\": \"{}\",", cert.valid_until);
            println!("    \"serial_number\": \"{}\",", cert.serial_number);
            println!(
                "    \"signature_algorithm\": \"{}\",",
                cert.signature_algorithm
            );
            println!(
                "    \"public_key_algorithm\": \"{}\",",
                cert.public_key_algorithm
            );
            println!("    \"version\": {},", cert.version);
            println!("    \"san\": [");
            for (i, san) in cert.san.iter().enumerate() {
                let comma = if i < cert.san.len() - 1 { "," } else { "" };
                println!("      \"{}\"{}", san, comma);
            }
            println!("    ],");

            // Calculate status
            // TODO: Implement proper certificate validation when TLS is complete
            let status = "unknown";

            println!("    \"status\": \"{}\"", status);
            println!("  }}");
            println!("}}");
            return Ok(());
        }

        // YAML output
        if format == crate::cli::format::OutputFormat::Yaml {
            println!("host: {}", hostname);
            println!("port: {}", port);
            println!("certificate:");
            println!("  subject: {}", cert.subject);
            println!("  issuer: {}", cert.issuer);
            println!("  valid_from: {}", cert.valid_from);
            println!("  valid_until: {}", cert.valid_until);
            println!("  serial_number: {}", cert.serial_number);
            println!("  signature_algorithm: {}", cert.signature_algorithm);
            println!("  public_key_algorithm: {}", cert.public_key_algorithm);
            println!("  version: {}", cert.version);
            println!("  san:");
            for san in &cert.san {
                println!("    - {}", san);
            }

            let expired = TlsClient::is_expired(&cert);
            let not_yet_valid = TlsClient::is_not_yet_valid(&cert);
            let status = if expired {
                "expired"
            } else if not_yet_valid {
                "not_yet_valid"
            } else {
                "valid"
            };
            println!("  status: {}", status);
            return Ok(());
        }

        // Human output
        Output::header("TLS Certificate Inspection");
        Output::item("Host", hostname);
        Output::item("Port", &port.to_string());
        println!();

        render_certificate_summary("Certificate", &cert);

        println!();
        Output::success("Certificate inspection completed");

        Ok(())
    }

    fn tls_audit(&self, ctx: &CliContext) -> Result<(), String> {
        let host = ctx.target.as_ref().ok_or(
            "Missing host. Usage: rb web asset tls-audit <HOST[:PORT]> Example: rb web asset tls-audit example.com",
        )?;

        let mut parts = host.split(':');
        let hostname = parts.next().unwrap_or(host);
        let port = parts
            .next()
            .unwrap_or("443")
            .parse::<u16>()
            .map_err(|_| format!("Invalid port in host '{}'", host))?;

        let format = ctx.get_output_format();

        let auditor = TlsAuditor::new();

        if format == crate::cli::format::OutputFormat::Human {
            Output::spinner_start("Running TLS security audit");
        }

        let result = auditor.audit(hostname, port)?;

        if format == crate::cli::format::OutputFormat::Human {
            Output::spinner_done();
        }

        // JSON output
        if format == crate::cli::format::OutputFormat::Json {
            println!("{{");
            println!("  \"host\": \"{}\",", hostname);
            println!("  \"port\": {},", port);
            println!("  \"certificate_valid\": {},", result.certificate_valid);

            // TLS versions
            println!("  \"tls_versions\": [");
            for (i, version) in result.supported_versions.iter().enumerate() {
                let comma = if i < result.supported_versions.len() - 1 {
                    ","
                } else {
                    ""
                };
                println!("    {{");
                println!("      \"version\": \"{}\",", version.version);
                println!("      \"supported\": {}", version.supported);
                if let Some(ref error) = version.error {
                    let error_escaped = error.replace('\\', "\\\\").replace('"', "\\\"");
                    println!("      ,\"error\": \"{}\"", error_escaped);
                }
                println!("    }}{}", comma);
            }
            println!("  ],");

            // Cipher suites
            println!("  \"cipher_suites\": [");
            for (i, cipher) in result.supported_ciphers.iter().enumerate() {
                let comma = if i < result.supported_ciphers.len() - 1 {
                    ","
                } else {
                    ""
                };
                let strength = match cipher.strength {
                    crate::modules::tls::auditor::CipherStrength::Weak => "weak",
                    crate::modules::tls::auditor::CipherStrength::Medium => "medium",
                    crate::modules::tls::auditor::CipherStrength::Strong => "strong",
                };
                println!("    {{");
                println!("      \"name\": \"{}\",", cipher.name);
                println!("      \"code\": \"0x{:04X}\",", cipher.code);
                println!("      \"strength\": \"{}\"", strength);
                println!("    }}{}", comma);
            }
            println!("  ],");

            // Vulnerabilities
            println!("  \"vulnerabilities\": [");
            for (i, vuln) in result.vulnerabilities.iter().enumerate() {
                let comma = if i < result.vulnerabilities.len() - 1 {
                    ","
                } else {
                    ""
                };
                let severity = vuln.severity.to_string().to_lowercase();
                println!("    {{");
                println!("      \"name\": \"{}\",", vuln.name.replace('"', "\\\""));
                println!("      \"severity\": \"{}\",", severity);
                println!(
                    "      \"description\": \"{}\"",
                    vuln.description.replace('"', "\\\"")
                );
                println!("    }}{}", comma);
            }
            println!("  ],");

            // Certificate chain
            println!("  \"certificate_chain\": [");
            for (i, cert) in result.certificate_chain.iter().enumerate() {
                let comma = if i < result.certificate_chain.len() - 1 {
                    ","
                } else {
                    ""
                };
                println!("    {{");
                println!(
                    "      \"subject\": \"{}\",",
                    cert.subject.replace('"', "\\\"")
                );
                println!(
                    "      \"issuer\": \"{}\",",
                    cert.issuer.replace('"', "\\\"")
                );
                println!("      \"valid_from\": \"{}\",", cert.valid_from);
                println!("      \"valid_until\": \"{}\",", cert.valid_until);
                println!("      \"serial_number\": \"{}\",", cert.serial_number);
                println!("      \"san\": [");
                for (j, san) in cert.san.iter().enumerate() {
                    let san_comma = if j < cert.san.len() - 1 { "," } else { "" };
                    println!("        \"{}\"{}", san, san_comma);
                }
                println!("      ]");
                println!("    }}{}", comma);
            }
            println!("  ]");
            println!("}}");
            return Ok(());
        }

        // YAML output
        if format == crate::cli::format::OutputFormat::Yaml {
            println!("host: {}", hostname);
            println!("port: {}", port);
            println!("certificate_valid: {}", result.certificate_valid);

            println!("tls_versions:");
            for version in &result.supported_versions {
                println!("  - version: {}", version.version);
                println!("    supported: {}", version.supported);
                if let Some(ref error) = version.error {
                    println!("    error: {}", error);
                }
            }

            println!("cipher_suites:");
            for cipher in &result.supported_ciphers {
                let strength = match cipher.strength {
                    crate::modules::tls::auditor::CipherStrength::Weak => "weak",
                    crate::modules::tls::auditor::CipherStrength::Medium => "medium",
                    crate::modules::tls::auditor::CipherStrength::Strong => "strong",
                };
                println!("  - name: {}", cipher.name);
                println!("    code: 0x{:04X}", cipher.code);
                println!("    strength: {}", strength);
            }

            println!("vulnerabilities:");
            for vuln in &result.vulnerabilities {
                let severity = vuln.severity.to_string().to_lowercase();
                println!("  - name: {}", vuln.name);
                println!("    severity: {}", severity);
                println!("    description: {}", vuln.description);
            }

            println!("certificate_chain:");
            for cert in &result.certificate_chain {
                println!("  - subject: {}", cert.subject);
                println!("    issuer: {}", cert.issuer);
                println!("    valid_from: {}", cert.valid_from);
                println!("    valid_until: {}", cert.valid_until);
                println!("    serial_number: {}", cert.serial_number);
                println!("    san:");
                for san in &cert.san {
                    println!("      - {}", san);
                }
            }
            return Ok(());
        }

        // Human output
        Output::header("TLS Security Audit");
        Output::item("Host", hostname);
        Output::item("Port", &port.to_string());
        println!();

        Output::warning(
            "Experimental auditor: cipher enumeration and certificate validation are informational only (signature checks pending).",
        );
        println!();

        // Display TLS versions
        println!();
        Output::subheader("TLS Protocol Versions");
        println!();
        println!("  {:<15} {:<10} {}", "VERSION", "STATUS", "NOTES");
        println!("  {}", "─".repeat(60));

        for version in &result.supported_versions {
            let status = if version.supported {
                "\x1b[32m✓ Supported\x1b[0m"
            } else {
                "\x1b[31m✗ Not Supported\x1b[0m"
            };

            let notes = version.error.as_ref().map(|e| e.as_str()).unwrap_or("");

            println!("  {:<15} {:<10} {}", version.version, status, notes);
        }

        // Display cipher suites
        println!();
        Output::subheader(&format!(
            "Cipher Suites ({})",
            result.supported_ciphers.len()
        ));
        println!();
        println!("  {:<50} {:<10} {}", "CIPHER", "CODE", "STRENGTH");
        println!("  {}", "─".repeat(75));

        for cipher in &result.supported_ciphers {
            let strength_color = match cipher.strength {
                crate::modules::tls::auditor::CipherStrength::Weak => "\x1b[31m", // Red
                crate::modules::tls::auditor::CipherStrength::Medium => "\x1b[33m", // Yellow
                crate::modules::tls::auditor::CipherStrength::Strong => "\x1b[32m", // Green
            };

            let strength_text = match cipher.strength {
                crate::modules::tls::auditor::CipherStrength::Weak => "WEAK",
                crate::modules::tls::auditor::CipherStrength::Medium => "MEDIUM",
                crate::modules::tls::auditor::CipherStrength::Strong => "STRONG",
            };

            println!(
                "  {:<50} 0x{:04X}    {}{}",
                cipher.name, cipher.code, strength_color, strength_text
            );
            print!("\x1b[0m");
        }

        // Display vulnerabilities
        if !result.vulnerabilities.is_empty() {
            println!();
            Output::subheader(&format!(
                "Security Issues ({} found)",
                result.vulnerabilities.len()
            ));
            println!();

            for vuln in &result.vulnerabilities {
                let severity_color = match vuln.severity {
                    crate::modules::tls::auditor::Severity::Critical => "\x1b[31m", // Red
                    crate::modules::tls::auditor::Severity::High => "\x1b[31m",     // Red
                    crate::modules::tls::auditor::Severity::Medium => "\x1b[33m",   // Yellow
                    crate::modules::tls::auditor::Severity::Low => "\x1b[36m",      // Cyan
                };

                println!(
                    "  [{}{}]\x1b[0m {}",
                    severity_color, vuln.severity, vuln.name
                );
                println!("    \x1b[2m{}\x1b[0m", vuln.description);
                println!();
            }
        } else {
            println!();
            Output::success("No major security issues detected!");
        }

        // Display certificate info
        if !result.certificate_chain.is_empty() {
            println!();
            Output::subheader("Certificate Chain");
            for (idx, cert) in result.certificate_chain.iter().enumerate() {
                println!();
                let label = format!("Certificate #{}", idx + 1);
                render_certificate_summary(&label, cert);
            }
        } else {
            Output::warning("No certificate chain retrieved from server");
        }

        println!();
        Output::success("TLS security audit completed");

        Ok(())
    }

    fn fuzz(&self, ctx: &CliContext) -> Result<(), String> {
        let url = ctx
            .target
            .as_ref()
            .ok_or("Missing URL. Usage: rb web asset fuzz <URL> --wordlist WORDS Example: rb web asset fuzz http://example.com --common")?;

        Validator::validate_url(url)?;
        Self::guard_plain_http(url, "rb web asset fuzz")?;

        let recursive = ctx.has_flag("recursive");
        let header = if recursive {
            "Directory Fuzzing (feroxbuster-style - RECURSIVE)"
        } else {
            "Directory Fuzzing (ffuf-style)"
        };

        Output::header(header);
        Output::item("Target", url);
        println!();

        // Determine wordlist source
        let wordlist_path = if ctx.has_flag("common") {
            // Use built-in common wordlist
            let words = Wordlists::common_dirs();
            Output::item("Wordlist", "Built-in common directories");
            Output::item("Words", &words.len().to_string());

            Wordlists::create_temp_wordlist(&words)?
        } else if let Some(path) = ctx.get_flag("wordlist") {
            // Use custom wordlist file
            Output::item("Wordlist", path);
            path.to_string()
        } else {
            return Err("No wordlist specified. Use --wordlist <FILE> or --common".to_string());
        };

        // Parse configuration
        let threads = ctx
            .get_flag_or("threads", "50")
            .parse::<usize>()
            .map_err(|_| "Invalid threads value")?;

        let filter_codes = if let Some(filter_str) = ctx.get_flag("filter") {
            filter_str
                .split(',')
                .filter_map(|s| s.trim().parse::<u16>().ok())
                .collect()
        } else {
            vec![404]
        };

        let match_codes = if let Some(match_str) = ctx.get_flag("match") {
            match_str
                .split(',')
                .filter_map(|s| s.trim().parse::<u16>().ok())
                .collect()
        } else {
            Vec::new()
        };

        Output::item("Threads", &threads.to_string());
        if recursive {
            let depth = ctx
                .get_flag_or("depth", "3")
                .parse::<usize>()
                .map_err(|_| "Invalid depth value")?;
            Output::item("Mode", &format!("Recursive (max depth: {})", depth));
        } else {
            Output::item("Mode", "Single-level");
        }
        if !filter_codes.is_empty() {
            Output::item(
                "Filter",
                &format!(
                    "{}",
                    filter_codes
                        .iter()
                        .map(|c| c.to_string())
                        .collect::<Vec<_>>()
                        .join(", ")
                ),
            );
        }
        if !match_codes.is_empty() {
            Output::item(
                "Match",
                &format!(
                    "{}",
                    match_codes
                        .iter()
                        .map(|c| c.to_string())
                        .collect::<Vec<_>>()
                        .join(", ")
                ),
            );
        }
        println!();

        // Create fuzzer
        let mut fuzzer = DirectoryFuzzer::new(url, &wordlist_path)
            .with_threads(threads)
            .with_filter_status(filter_codes)
            .with_match_status(match_codes);

        // Enable recursive mode if requested
        if recursive {
            let depth = ctx
                .get_flag_or("depth", "3")
                .parse::<usize>()
                .map_err(|_| "Invalid depth value")?;
            fuzzer = fuzzer.with_recursive(depth);
        }

        let format = ctx.get_output_format();
        let total_words_estimate = if let Ok(words) = fuzzer.preview_wordlist_count() {
            words as u64
        } else {
            0
        };

        let progress_label = format!("Fuzzing {}", url);
        let progress =
            if format == crate::cli::format::OutputFormat::Human && total_words_estimate > 0 {
                Some(Arc::new(Output::progress_bar(
                    progress_label,
                    total_words_estimate,
                    true,
                )))
            } else {
                None
            };

        if let Some(p) = &progress {
            fuzzer = fuzzer.with_progress(Arc::clone(p) as Arc<_>);
        }

        let (results, stats) = fuzzer.fuzz()?;

        if let Some(progress_bar) = progress {
            progress_bar.finish();
        }

        // Display results
        if results.is_empty() {
            println!();
            Output::warning("No directories/files found");
        } else {
            println!();
            Output::subheader(&format!("Found {} Paths", results.len()));
            println!();

            println!(
                "  {:<6} {:<60} {:<10} {}",
                "STATUS", "PATH", "SIZE", "INTERESTING"
            );
            println!("  {}", "─".repeat(90));

            for result in &results {
                let status_color = if (200..300).contains(&result.status_code) {
                    "\x1b[32m" // Green
                } else if (300..400).contains(&result.status_code) {
                    "\x1b[33m" // Yellow
                } else if result.status_code == 401 || result.status_code == 403 {
                    "\x1b[31m" // Red
                } else {
                    "\x1b[36m" // Cyan
                };

                let interesting = if result.interesting { "✓" } else { "" };

                println!(
                    "  {}{:<6}\x1b[0m {:<60} {:<10} {}",
                    status_color, result.status_code, result.path, result.size, interesting
                );
            }
        }

        // Display statistics
        println!();
        Output::subheader("Statistics");
        println!("  Total Requests: {}", stats.total_requests);
        println!("  Found:          {}", stats.found);
        println!("  Errors:         {}", stats.errors);
        println!(
            "  Duration:       {:.2}s",
            stats.duration_ms as f64 / 1000.0
        );
        println!(
            "  Requests/sec:   {:.0}",
            stats.total_requests as f64 / (stats.duration_ms as f64 / 1000.0)
        );

        println!();
        Output::success("Fuzzing completed");

        Ok(())
    }

    fn fingerprint(&self, ctx: &CliContext) -> Result<(), String> {
        let url = ctx.target.as_ref().ok_or(
            "Missing URL. Usage: rb web asset fingerprint <URL> Example: rb web asset fingerprint http://example.com",
        )?;

        Validator::validate_url(url)?;
        Self::guard_plain_http(url, "rb web asset fingerprint")?;

        Output::header("Web Technology Fingerprinting");
        Output::item("URL", url);
        println!();

        let fingerprinter = WebFingerprinter::new();

        Output::spinner_start("Analyzing technologies");
        let result = fingerprinter.fingerprint(url)?;
        Output::spinner_done();

        // Display main findings
        println!();
        Output::subheader("Key Findings");
        println!();

        if let Some(ref cms) = result.cms {
            Output::item("CMS", cms);
        }

        if let Some(ref server) = result.web_server {
            Output::item("Web Server", server);
        }

        if let Some(ref lang) = result.programming_language {
            Output::item("Language", lang);
        }

        if !result.frameworks.is_empty() {
            Output::item("Frameworks", &result.frameworks.join(", "));
        }

        // Display all detected technologies
        if !result.technologies.is_empty() {
            println!();
            Output::subheader(&format!(
                "All Technologies ({} detected)",
                result.technologies.len()
            ));
            println!();

            println!(
                "  {:<30} {:<15} {:<12} {}",
                "TECHNOLOGY", "CATEGORY", "CONFIDENCE", "VERSION"
            );
            println!("  {}", "─".repeat(75));

            for tech in &result.technologies {
                let category = match tech.category {
                    crate::modules::web::fingerprinter::TechCategory::CMS => "CMS",
                    crate::modules::web::fingerprinter::TechCategory::Framework => "Framework",
                    crate::modules::web::fingerprinter::TechCategory::WebServer => "Web Server",
                    crate::modules::web::fingerprinter::TechCategory::Language => "Language",
                    crate::modules::web::fingerprinter::TechCategory::Library => "Library",
                    crate::modules::web::fingerprinter::TechCategory::CDN => "CDN",
                    crate::modules::web::fingerprinter::TechCategory::Analytics => "Analytics",
                    crate::modules::web::fingerprinter::TechCategory::Database => "Database",
                    crate::modules::web::fingerprinter::TechCategory::Other => "Other",
                };

                let confidence_color = match tech.confidence {
                    crate::modules::web::fingerprinter::Confidence::High => "\x1b[32m", // Green
                    crate::modules::web::fingerprinter::Confidence::Medium => "\x1b[33m", // Yellow
                    crate::modules::web::fingerprinter::Confidence::Low => "\x1b[36m",  // Cyan
                };

                let version = tech.version.as_ref().map(|v| v.as_str()).unwrap_or("-");

                println!(
                    "  {:<30} {:<15} {}{:<12}\x1b[0m {}",
                    tech.name, category, confidence_color, tech.confidence, version
                );
            }
        } else {
            println!();
            Output::warning("No technologies detected");
        }

        println!();
        Output::success("Fingerprinting completed");

        Ok(())
    }

    fn scan(&self, ctx: &CliContext) -> Result<(), String> {
        scanning::run_scan(ctx)
    }

    fn vuln_scan(&self, ctx: &CliContext) -> Result<(), String> {
        scanning::run_active_scan(ctx)
    }

    fn wpscan(&self, ctx: &CliContext) -> Result<(), String> {
        let url = ctx.target.as_ref().ok_or(
            "Missing URL. Usage: rb web asset wpscan <URL> Example: rb web asset wpscan http://example.com",
        )?;

        Validator::validate_url(url)?;
        Self::guard_plain_http(url, "rb web asset wpscan")?;

        Output::header("WordPress Security Scanner");
        Output::item("Target", url);
        println!();

        Output::spinner_start("Scanning WordPress installation");

        // Create scanner and run scan
        use crate::modules::web::wpscan::WPScanner;
        let scanner = WPScanner::new();
        let result = scanner.scan(url)?;

        Output::spinner_done();
        println!();

        // Display results
        if !result.is_wordpress {
            Output::info("Not a WordPress site");
            return Ok(());
        }

        Output::success("✓ WordPress Detected");

        if let Some(version) = &result.version {
            Output::item("Version", version);
        } else {
            Output::item("Version", "Unknown");
        }
        println!();

        // Display plugins
        if !result.plugins.is_empty() {
            Output::subheader(&format!("Plugins Found: {}", result.plugins.len()));
            for plugin in &result.plugins {
                let version_str = plugin.version.as_deref().unwrap_or("unknown");
                println!(
                    "  • {} ({})",
                    Output::colorize(&plugin.name, "cyan"),
                    version_str
                );
                println!("    Path: {}", plugin.path);
            }
            println!();
        }

        // Display themes
        if !result.themes.is_empty() {
            Output::subheader(&format!("Themes Found: {}", result.themes.len()));
            for theme in &result.themes {
                let version_str = theme.version.as_deref().unwrap_or("unknown");
                println!(
                    "  • {} ({})",
                    Output::colorize(&theme.name, "cyan"),
                    version_str
                );
                println!("    Path: {}", theme.path);
            }
            println!();
        }

        // Display users
        if !result.users.is_empty() {
            Output::subheader(&format!("Users Enumerated: {}", result.users.len()));
            for user in &result.users {
                println!("  • {}", Output::colorize(user, "yellow"));
            }
            println!();
        }

        // Display vulnerabilities
        if !result.vulnerabilities.is_empty() {
            Output::warning(&format!(
                "⚠️  {} VULNERABILITIES FOUND:",
                result.vulnerabilities.len()
            ));
            println!();

            for vuln in &result.vulnerabilities {
                let severity_color = match vuln.severity {
                    crate::modules::web::wpscan::VulnSeverity::Critical => "red",
                    crate::modules::web::wpscan::VulnSeverity::High => "red",
                    crate::modules::web::wpscan::VulnSeverity::Medium => "yellow",
                    crate::modules::web::wpscan::VulnSeverity::Low => "blue",
                    crate::modules::web::wpscan::VulnSeverity::Info => "cyan",
                };

                println!(
                    "  {} | {}",
                    Output::colorize(&vuln.severity.to_string(), severity_color),
                    Output::colorize(&vuln.title, "white")
                );
                println!("    {}", vuln.description);
                if let Some(path) = &vuln.path {
                    println!("    Path: {}", path);
                }
                println!();
            }

            Output::warning("🚨 SECURITY ALERT: WordPress vulnerabilities detected!");
            Output::warning("   Review findings and apply security patches");
        } else {
            Output::success("✓ No known vulnerabilities detected");
        }

        Ok(())
    }

    fn drupal_scan(&self, ctx: &CliContext) -> Result<(), String> {
        let url = ctx.target.as_ref().ok_or(
            "Missing URL. Usage: rb web asset drupal-scan <URL> Example: rb web asset drupal-scan http://example.com",
        )?;

        Validator::validate_url(url)?;
        Self::guard_plain_http(url, "rb web asset drupal-scan")?;

        Output::header("Drupal Security Scanner");
        Output::item("Target", url);
        println!();

        Output::spinner_start("Scanning Drupal installation");

        // Create scanner and run scan
        use crate::modules::web::drupal_scanner::DrupalScanner;
        let scanner = DrupalScanner::new();
        let result = scanner.scan(url)?;

        Output::spinner_done();
        println!();

        // Display results
        if !result.is_drupal {
            Output::info("Not a Drupal site");
            return Ok(());
        }

        Output::success("✓ Drupal Detected");

        if let Some(version) = &result.version {
            Output::item("Version", version);
        } else {
            Output::item("Version", "Unknown");
        }
        println!();

        // Display modules
        if !result.modules.is_empty() {
            Output::subheader(&format!("Modules Found: {}", result.modules.len()));
            for module in &result.modules {
                let version_str = module.version.as_deref().unwrap_or("unknown");
                println!(
                    "  • {} ({})",
                    Output::colorize(&module.name, "cyan"),
                    version_str
                );
                println!("    Path: {}", module.path);
            }
            println!();
        }

        // Display themes
        if !result.themes.is_empty() {
            Output::subheader(&format!("Themes Found: {}", result.themes.len()));
            for theme in &result.themes {
                let version_str = theme.version.as_deref().unwrap_or("unknown");
                println!(
                    "  • {} ({})",
                    Output::colorize(&theme.name, "cyan"),
                    version_str
                );
                println!("    Path: {}", theme.path);
            }
            println!();
        }

        // Display users
        if !result.users.is_empty() {
            Output::subheader(&format!("Users Enumerated: {}", result.users.len()));
            for user in &result.users {
                println!("  • {}", Output::colorize(user, "yellow"));
            }
            println!();
        }

        // Display config exposure
        if !result.config_exposure.is_empty() {
            Output::warning(&format!(
                "⚠️  {} CONFIGURATION FILES EXPOSED:",
                result.config_exposure.len()
            ));
            println!();
            for config in &result.config_exposure {
                println!(
                    "  • {} [{}] - Risk: {}",
                    Output::colorize(&config.path, "red"),
                    config.status,
                    config.risk
                );
            }
            println!();
        }

        // Display vulnerabilities
        if !result.vulnerabilities.is_empty() {
            Output::warning(&format!(
                "⚠️  {} VULNERABILITIES FOUND:",
                result.vulnerabilities.len()
            ));
            println!();

            for vuln in &result.vulnerabilities {
                let severity_color = match vuln.severity {
                    crate::modules::web::drupal_scanner::VulnSeverity::Critical => "red",
                    crate::modules::web::drupal_scanner::VulnSeverity::High => "red",
                    crate::modules::web::drupal_scanner::VulnSeverity::Medium => "yellow",
                    crate::modules::web::drupal_scanner::VulnSeverity::Low => "blue",
                };

                println!(
                    "  {} | {}",
                    Output::colorize(&vuln.severity.to_string(), severity_color),
                    Output::colorize(&vuln.title, "white")
                );
                println!("    {}", vuln.description);
                println!("    Affected: {}", vuln.affected_versions);
                if let Some(cve) = &vuln.cve {
                    println!("    CVE: {}", cve);
                }
                println!();
            }

            Output::warning("🚨 SECURITY ALERT: Drupal vulnerabilities detected!");
            Output::warning("   Review findings and apply security patches");
        } else {
            Output::success("✓ No known vulnerabilities detected");
        }

        Ok(())
    }

    fn joomla_scan(&self, ctx: &CliContext) -> Result<(), String> {
        let url = ctx.target.as_ref().ok_or(
            "Missing URL. Usage: rb web asset joomla-scan <URL> Example: rb web asset joomla-scan http://example.com",
        )?;

        Validator::validate_url(url)?;
        Self::guard_plain_http(url, "rb web asset joomla-scan")?;

        Output::header("Joomla Security Scanner");
        Output::item("Target", url);
        println!();

        Output::spinner_start("Scanning Joomla installation");

        // Create scanner and run scan
        use crate::modules::web::joomla_scanner::JoomlaScanner;
        let scanner = JoomlaScanner::new();
        let result = scanner.scan(url)?;

        Output::spinner_done();
        println!();

        // Display results
        if !result.is_joomla {
            Output::info("Not a Joomla site");
            return Ok(());
        }

        Output::success("✓ Joomla Detected");

        if let Some(version) = &result.version {
            Output::item("Version", version);
        } else {
            Output::item("Version", "Unknown");
        }
        println!();

        // Display extensions
        if !result.extensions.is_empty() {
            Output::subheader(&format!("Extensions Found: {}", result.extensions.len()));
            for ext in &result.extensions {
                let version_str = ext.version.as_deref().unwrap_or("unknown");
                println!(
                    "  • {} ({}) - {}",
                    Output::colorize(&ext.name, "cyan"),
                    version_str,
                    ext.ext_type
                );
                println!("    Path: {}", ext.path);
            }
            println!();
        }

        // Display templates
        if !result.templates.is_empty() {
            Output::subheader(&format!("Templates Found: {}", result.templates.len()));
            for template in &result.templates {
                let version_str = template.version.as_deref().unwrap_or("unknown");
                println!(
                    "  • {} ({})",
                    Output::colorize(&template.name, "cyan"),
                    version_str
                );
                println!("    Path: {}", template.path);
            }
            println!();
        }

        // Display users
        if !result.users.is_empty() {
            Output::subheader(&format!("Users Enumerated: {}", result.users.len()));
            for user in &result.users {
                println!("  • {}", Output::colorize(user, "yellow"));
            }
            println!();
        }

        // Display config exposure
        if !result.config_exposure.is_empty() {
            Output::warning(&format!(
                "⚠️  {} CONFIGURATION FILES EXPOSED:",
                result.config_exposure.len()
            ));
            println!();
            for config in &result.config_exposure {
                println!(
                    "  • {} [{}] - Risk: {}",
                    Output::colorize(&config.path, "red"),
                    config.status,
                    config.risk
                );
            }
            println!();
        }

        // Display vulnerabilities
        if !result.vulnerabilities.is_empty() {
            Output::warning(&format!(
                "⚠️  {} VULNERABILITIES FOUND:",
                result.vulnerabilities.len()
            ));
            println!();

            for vuln in &result.vulnerabilities {
                let severity_color = match vuln.severity {
                    crate::modules::web::joomla_scanner::VulnSeverity::Critical => "red",
                    crate::modules::web::joomla_scanner::VulnSeverity::High => "red",
                    crate::modules::web::joomla_scanner::VulnSeverity::Medium => "yellow",
                    crate::modules::web::joomla_scanner::VulnSeverity::Low => "blue",
                };

                println!(
                    "  {} | {}",
                    Output::colorize(&vuln.severity.to_string(), severity_color),
                    Output::colorize(&vuln.title, "white")
                );
                println!("    {}", vuln.description);
                println!("    Affected: {}", vuln.affected_versions);
                if let Some(cve) = &vuln.cve {
                    println!("    CVE: {}", cve);
                }
                println!();
            }

            Output::warning("🚨 SECURITY ALERT: Joomla vulnerabilities detected!");
            Output::warning("   Review findings and apply security patches");
        } else {
            Output::success("✓ No known vulnerabilities detected");
        }

        Ok(())
    }

    fn crawl(&self, ctx: &CliContext) -> Result<(), String> {
        let url = ctx.target.as_ref().ok_or(
            "Missing URL. Usage: rb web asset crawl <URL> [--depth N] [--max-pages N] Example: rb web asset crawl http://example.com",
        )?;

        Validator::validate_url(url)?;

        Output::header("Web Crawler - Site Mapping");
        Output::item("Target", url);

        // Parse options
        let max_depth = ctx
            .get_flag("depth")
            .or_else(|| ctx.get_flag("d"))
            .and_then(|s| s.parse::<usize>().ok())
            .unwrap_or(3);

        let max_pages = ctx
            .get_flag("max-pages")
            .or_else(|| ctx.get_flag("m"))
            .and_then(|s| s.parse::<usize>().ok())
            .unwrap_or(100);

        let same_origin = !ctx.has_flag("external");

        Output::item("Max Depth", &max_depth.to_string());
        Output::item("Max Pages", &max_pages.to_string());
        Output::item("Same Origin", if same_origin { "Yes" } else { "No" });
        println!();

        Output::spinner_start("Crawling website");

        // Create crawler
        let mut crawler = WebCrawler::new()
            .with_max_depth(max_depth)
            .with_max_pages(max_pages)
            .with_same_origin(same_origin);

        // Crawl
        let result = crawler.crawl(url)?;

        Output::spinner_done();

        // Display results
        Output::success(&format!(
            "Crawled {} pages (depth: {})",
            result.total_urls, result.max_depth_reached
        ));
        println!();

        // Group pages by depth
        let mut by_depth: std::collections::HashMap<usize, Vec<&str>> =
            std::collections::HashMap::new();

        for page in &result.pages {
            by_depth
                .entry(page.depth)
                .or_insert_with(Vec::new)
                .push(&page.url);
        }

        // Display pages by depth
        for depth in 0..=result.max_depth_reached {
            if let Some(urls) = by_depth.get(&depth) {
                println!(
                    "\x1b[1m\x1b[36m● Depth {}\x1b[0m ({} pages)",
                    depth,
                    urls.len()
                );

                // Show first 5 URLs per depth
                for (i, url) in urls.iter().take(5).enumerate() {
                    println!("  {}. {}", i + 1, url);
                }

                if urls.len() > 5 {
                    println!("  \x1b[90m... and {} more\x1b[0m", urls.len() - 5);
                }

                println!();
            }
        }

        // Display forms found
        let total_forms: usize = result.pages.iter().map(|p| p.forms.len()).sum();
        if total_forms > 0 {
            println!(
                "\x1b[1m\x1b[33m● Forms Found\x1b[0m ({} total)",
                total_forms
            );

            let mut form_count = 0;
            for page in &result.pages {
                for form in &page.forms {
                    if form_count >= 5 {
                        break;
                    }
                    println!(
                        "  {} {} (inputs: {:?})",
                        form.method, form.action, form.inputs
                    );
                    form_count += 1;
                }
                if form_count >= 5 {
                    break;
                }
            }

            if total_forms > 5 {
                println!("  \x1b[90m... and {} more\x1b[0m", total_forms - 5);
            }

            println!();
        }

        // Display assets summary
        let total_js: usize = result
            .pages
            .iter()
            .map(|p| {
                p.assets
                    .iter()
                    .filter(|a| a.asset_type == crate::modules::web::crawler::AssetType::JavaScript)
                    .count()
            })
            .sum();

        let total_css: usize = result
            .pages
            .iter()
            .map(|p| {
                p.assets
                    .iter()
                    .filter(|a| a.asset_type == crate::modules::web::crawler::AssetType::CSS)
                    .count()
            })
            .sum();

        let total_images: usize = result
            .pages
            .iter()
            .map(|p| {
                p.assets
                    .iter()
                    .filter(|a| a.asset_type == crate::modules::web::crawler::AssetType::Image)
                    .count()
            })
            .sum();

        if total_js + total_css + total_images > 0 {
            println!("\x1b[1m\x1b[35m● Assets Discovered\x1b[0m");
            println!("  JavaScript: {}", total_js);
            println!("  CSS: {}", total_css);
            println!("  Images: {}", total_images);
            println!();
        }

        // Statistics
        println!("\x1b[1mStatistics:\x1b[0m");
        println!("  Pages crawled: {}", result.total_urls);
        println!("  Total links found: {}", result.total_links);
        println!("  Max depth reached: {}", result.max_depth_reached);
        println!("  Forms discovered: {}", total_forms);
        println!("  Assets found: {}", total_js + total_css + total_images);

        Ok(())
    }

    fn linkfinder(&self, ctx: &CliContext) -> Result<(), String> {
        let js_url = ctx.target.as_ref().ok_or(
            "Missing JavaScript URL. Usage: rb web asset linkfinder <js-url> [--type api|s3|websocket|graphql|all] Example: rb web asset linkfinder https://example.com/app.js",
        )?;

        Validator::validate_url(js_url)?;

        Output::header("LinkFinder - JS Endpoint Extractor");
        Output::item("Target", js_url);

        let filter_type = ctx.get_flag("type").or_else(|| ctx.get_flag("t"));
        if let Some(ref t) = filter_type {
            Output::item("Filter Type", t);
        }
        println!();

        Output::spinner_start("Extracting endpoints from JavaScript");

        let finder = LinkFinder::new();
        let endpoints = finder.extract_from_url(js_url)?;

        Output::spinner_done();

        if endpoints.is_empty() {
            Output::warning("No endpoints found in JavaScript file");
            return Ok(());
        }

        // Apply type filter if specified
        let filtered_endpoints = if let Some(ref type_filter) = filter_type {
            match type_filter.to_lowercase().as_str() {
                "api" => LinkFinder::filter_by_type(endpoints, EndpointType::ApiEndpoint),
                "s3" => LinkFinder::filter_by_type(endpoints, EndpointType::S3Bucket),
                "websocket" | "ws" => {
                    LinkFinder::filter_by_type(endpoints, EndpointType::WebSocket)
                }
                "graphql" | "gql" => LinkFinder::filter_by_type(endpoints, EndpointType::GraphQL),
                "cloud" => LinkFinder::filter_by_type(endpoints, EndpointType::CloudStorage),
                "relative" => LinkFinder::filter_by_type(endpoints, EndpointType::RelativePath),
                "absolute" | "url" => {
                    LinkFinder::filter_by_type(endpoints, EndpointType::AbsoluteUrl)
                }
                "all" => endpoints,
                _ => {
                    return Err(format!(
                        "Invalid type '{}'. Valid types: api, s3, websocket, graphql, cloud, relative, absolute, all",
                        type_filter
                    ));
                }
            }
        } else {
            endpoints
        };

        if filtered_endpoints.is_empty() {
            let filter_str = filter_type.as_ref().map(|s| s.as_str()).unwrap_or("all");
            Output::warning(&format!(
                "No endpoints found matching filter '{}'",
                filter_str
            ));
            return Ok(());
        }

        // Group by endpoint type
        let mut by_type: std::collections::HashMap<String, Vec<String>> =
            std::collections::HashMap::new();

        for endpoint in &filtered_endpoints {
            let type_name = match endpoint.endpoint_type {
                EndpointType::RelativePath => "Relative Paths",
                EndpointType::AbsoluteUrl => "Absolute URLs",
                EndpointType::ApiEndpoint => "API Endpoints",
                EndpointType::S3Bucket => "S3 Buckets",
                EndpointType::CloudStorage => "Cloud Storage",
                EndpointType::WebSocket => "WebSockets",
                EndpointType::GraphQL => "GraphQL",
            };
            by_type
                .entry(type_name.to_string())
                .or_insert_with(Vec::new)
                .push(endpoint.url.clone());
        }

        // Display results grouped by type
        Output::success(&format!("Found {} endpoints", filtered_endpoints.len()));
        println!();

        for (type_name, urls) in by_type.iter() {
            // Color based on type
            let color = match type_name.as_str() {
                "API Endpoints" => "\x1b[36m",  // Cyan
                "S3 Buckets" => "\x1b[33m",     // Yellow
                "Cloud Storage" => "\x1b[33m",  // Yellow
                "WebSockets" => "\x1b[35m",     // Magenta
                "GraphQL" => "\x1b[36m",        // Cyan
                "Relative Paths" => "\x1b[32m", // Green
                "Absolute URLs" => "\x1b[34m",  // Blue
                _ => "\x1b[0m",                 // Default
            };

            println!("{}● {}\x1b[0m ({} found)", color, type_name, urls.len());

            // Show first 10 URLs per type
            for (i, url) in urls.iter().take(10).enumerate() {
                println!("  {}. {}", i + 1, url);
            }

            if urls.len() > 10 {
                println!("  \x1b[90m... and {} more\x1b[0m", urls.len() - 10);
            }
            println!();
        }

        // Show statistics
        println!("\x1b[1mStatistics:\x1b[0m");
        println!("  Total endpoints: {}", filtered_endpoints.len());
        println!("  Unique types: {}", by_type.len());

        Ok(())
    }
}
