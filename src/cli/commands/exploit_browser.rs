//! Browser Exploitation CLI
//!
//! Controls the browser exploitation server and interacts with zombies.

use crate::cli::commands::{Command, Flag, Route};
use crate::cli::{output::Output, CliContext};
use crate::modules::exploit::browser::server::BrowserServer;
use std::net::SocketAddr;
use std::sync::{Arc, Mutex};

pub struct BrowserExploitCommand;

// Global reference to the server for interactive commands (simplified for CLI)
// In a real long-running app, this would be managed by a daemon or service manager.
static SERVER: Mutex<Option<Arc<BrowserServer>>> = Mutex::new(None);

impl Command for BrowserExploitCommand {
    fn domain(&self) -> &str {
        "exploit"
    }

    fn resource(&self) -> &str {
        "browser"
    }

    fn description(&self) -> &str {
        "Browser Exploitation Framework (RBB)"
    }

    fn routes(&self) -> Vec<Route> {
        vec![
            Route {
                verb: "serve",
                summary: "Start the browser exploitation server",
                usage: "rb exploit browser serve [--port PORT] [--bind IP]",
            },
            Route {
                verb: "list",
                summary: "List connected zombies",
                usage: "rb exploit browser list",
            },
            Route {
                verb: "exec",
                summary: "Execute JavaScript on a zombie",
                usage: "rb exploit browser exec --id ZOMBIE_ID --script 'alert(1)'",
            },
        ]
    }

    fn flags(&self) -> Vec<Flag> {
        vec![
            Flag::new("bind", "Bind address").with_default("0.0.0.0"),
            Flag::new("port", "Listen port").with_default("3000").with_short('p'),
            Flag::new("id", "Zombie Session ID").with_short('i'),
            Flag::new("script", "JavaScript to execute").with_short('s'),
        ]
    }

    fn examples(&self) -> Vec<(&str, &str)> {
        vec![
            ("Start server", "rb exploit browser serve"),
            ("List zombies", "rb exploit browser list"),
            ("Exec alert", "rb exploit browser exec --id ZOMBIE_ID --script \"alert('Pwned')\""),
        ]
    }

    fn execute(&self, ctx: &CliContext) -> Result<(), String> {
        let verb = ctx.verb.as_ref().ok_or("No verb provided")?;

        match verb.as_str() {
            "serve" => self.serve(ctx),
            "list" => self.list(ctx),
            "exec" => self.exec(ctx),
            _ => Err(format!("Unknown verb: {}", verb)),
        }
    }
}

impl BrowserExploitCommand {
    fn serve(&self, ctx: &CliContext) -> Result<(), String> {
        let bind = ctx.get_flag_or("bind", "0.0.0.0");
        let port = ctx.get_flag_or("port", "3000");
        let addr: SocketAddr = format!("{}:{}", bind, port).parse()
            .map_err(|e| format!("Invalid address: {}", e))?;

        Output::header("RBB Browser Server");
        Output::item("Listening on", &addr.to_string());
        Output::item("Hook URL", &format!("http://{}:{}/hook.js", bind, port));
        println!();
        
        Output::warning("This server runs in the foreground. Open a new terminal to send commands.");
        println!();

        let server = Arc::new(BrowserServer::new(addr));
        
        // Store reference (this is a bit hacky for a CLI, usually we'd daemonize)
        // But since 'serve' blocks, we can't really use the global mutex effectively 
        // across different CLI invocations unless we use IPC/files.
        // For this MVP, 'serve' is blocking and intended to be run in one terminal,
        // while other commands would need to communicate with it.
        //
        // TODO: Real implementation needs IPC (Unix Sockets or HTTP Control API).
        // For now, let's make 'serve' purely blocking and print logs.
        // To properly control it from another terminal, we'd need a Control API.
        
        // For the sake of the user's request "how they talk", this serves the purpose.
        // We will implement a basic TUI or command loop inside 'serve' later if needed.
        
        server.run()?;

        Ok(())
    }

    fn list(&self, _ctx: &CliContext) -> Result<(), String> {
        // Limitation: In this stateless CLI architecture, 'list' cannot access the memory
        // of the running 'serve' process. 
        // To fix this, the 'serve' command should write state to a file (sqlite/json) 
        // or expose a local management API.
        
        Output::error("Cannot list zombies from a separate process yet.");
        Output::info("Feature coming soon: IPC for remote management.");
        Ok(())
    }

    fn exec(&self, _ctx: &CliContext) -> Result<(), String> {
        Output::error("Cannot execute commands from a separate process yet.");
        Output::info("Feature coming soon: IPC for remote management.");
        Ok(())
    }
}
