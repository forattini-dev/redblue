#![cfg(not(tarpaulin_include))]
// src/modules/exploit/prng_predictor.rs
//
// PRNG Predictors for various algorithms.
// For authorized security research and exploitation only.

use std::collections::VecDeque;
use std::convert::TryInto;

#[derive(Debug, Clone, PartialEq)]
pub enum PrngOutput {
    U64(u64),
    F64(f64),
    // Add other types as needed, e.g., U32(u32), U128(u128)
}

/// Trait for PRNG predictors.
///
/// Implementations should be able to observe generated values and,
/// given enough data, predict the next output of the PRNG.
pub trait PrngPredictor {
    /// Adds an observed value to the predictor's internal state.
    ///
    /// The predictor might require a certain number of observed values
    /// before it can make a prediction.
    fn observe(&mut self, value: PrngOutput);

    /// Attempts to predict the next value generated by the PRNG.
    ///
    /// Returns `Some(value)` if a prediction can be made, otherwise `None`.
    /// This method can modify the internal state of the predictor (e.g., advance a PRNG state).
    fn predict_next(&mut self) -> Option<PrngOutput>;

    /// Returns the name of the PRNG algorithm this predictor targets.
    fn name(&self) -> &'static str;

    /// Checks if the predictor has gathered enough data to make a prediction.
    fn can_predict(&self) -> bool;
}

// -----------------------------------------------------------------------------
// Linear Congruential Generator (LCG) Predictor
// -----------------------------------------------------------------------------

/// Predictor for Linear Congruential Generators (LCG).
///
/// LCGs are of the form: `X_{n+1} = (a * X_n + c) mod m`.
/// This predictor attempts to recover `a`, `c`, and `m` given a sequence of outputs.
///
/// Requires at least 3 observed values to recover parameters.
pub struct LcgPredictor {
    /// Observed output values from the LCG.
    observations: VecDeque<u64>,
    /// Recovered modulus `m`.
    modulus: Option<u64>,
    /// Recovered multiplier `a`.
    multiplier: Option<u64>,
    /// Recovered increment `c`.
    increment: Option<u64>,
}

impl Default for LcgPredictor {
    fn default() -> Self {
        Self {
            observations: VecDeque::with_capacity(5), // Need at least 3 for prediction
            modulus: None,
            multiplier: None,
            increment: None,
        }
    }
}

impl PrngPredictor for LcgPredictor {
    fn observe(&mut self, value: PrngOutput) {
        if let PrngOutput::U64(v) = value {
            if self.observations.len() == self.observations.capacity() {
                self.observations.pop_front();
            }
            self.observations.push_back(v);

            if self.can_predict() && self.modulus.is_none() {
                // Attempt to recover parameters if we have enough observations
                self.recover_parameters();
            }
        } else {
            // Log or handle error for unexpected type
            // For now, silently ignore or panic, depending on desired robustness.
            // panic!("LcgPredictor received non-U64 observation.");
        }
    }

    fn predict_next(&mut self) -> Option<PrngOutput> {
        if !self.can_predict() {
            return None;
        }

        if let (Some(_m_is_2_64), Some(a), Some(c)) =
            (self.modulus, self.multiplier, self.increment)
        {
            if let Some(&last_x) = self.observations.back() {
                // If modulus is 0, it signifies wrapping arithmetic (m=2^64)
                return Some(PrngOutput::U64(a.wrapping_mul(last_x).wrapping_add(c)));
            }
        }
        None
    }

    fn name(&self) -> &'static str {
        "Linear Congruential Generator (LCG) Predictor"
    }

    fn can_predict(&self) -> bool {
        // Need at least 3 points to solve for a, c, m
        self.observations.len() >= 3 && self.modulus.is_some() // Only if parameters are recovered
    }
}

impl LcgPredictor {
    /// Attempts to recover the LCG parameters (a, c, m).
    /// This implementation focuses on the common case where `m` is a power of 2 (e.g., 2^64).
    /// It requires at least 3 observations.
    fn recover_parameters(&mut self) {
        if self.observations.len() < 3 {
            return;
        }

        // x_0, x_1, x_2 are needed. Let's use the last three.
        let x0 = self.observations[self.observations.len() - 3];
        let x1 = self.observations[self.observations.len() - 2];
        let x2 = self.observations[self.observations.len() - 1];

        // The differences:
        // d1 = x2 - x1
        // d0 = x1 - x0
        let d0 = x1.wrapping_sub(x0);
        let d1 = x2.wrapping_sub(x1);

        // If d0 is even, then modular inverse modulo 2^64 does not exist.
        if d0 % 2 == 0 {
            self.modulus = None;
            self.multiplier = None;
            self.increment = None;
            return;
        }

        let d0_inv = match mod_inv_u64(d0) {
            Some(inv) => inv,
            None => {
                // This should not happen if d0 is odd, but for safety.
                self.modulus = None;
                self.multiplier = None;
                self.increment = None;
                return;
            }
        };

        let a = d1.wrapping_mul(d0_inv);

        // c = x1 - a * x0 (mod m)
        let c = x1.wrapping_sub(a.wrapping_mul(x0));

        self.modulus = Some(0); // Store 0 to represent 2^64 for wrapping arithmetic
        self.multiplier = Some(a);
        self.increment = Some(c);
    }
}

// A specialized mod_inv for m = 2^64 (implicit wrapping arithmetic)
// Based on: https://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Computation
// and https://cp-algorithms.com/algebra/extended-euclid.html for mod 2^k
fn mod_inv_u64(a: u64) -> Option<u64> {
    if a % 2 == 0 {
        return None; // No inverse if 'a' is even modulo 2^64
    }

    // Iterative method for x^-1 mod 2^k
    // inv_0 = 1
    // inv_{k+1} = inv_k * (2 - a * inv_k) mod 2^(k+1)
    // For 2^64, this takes 6 iterations (for a modulus of 2^1, 2^2, ..., 2^64)
    let mut inv = 1u64; // x_0 = 1

    // Perform 6 iterations to reach inverse modulo 2^64
    // (k=1 to k=64, each step doubles the modulus power for which inverse is valid)
    // Loop 6 times is enough to cover all 64 bits (2^1, 2^2, 2^4, 2^8, 2^16, 2^32, 2^64)
    // Each iteration calculates x_k * (2 - a * x_k) mod 2^(2^k)
    for _ in 0..6 {
        inv = inv.wrapping_mul(2u64.wrapping_sub(a.wrapping_mul(inv)));
    }
    Some(inv)
}

// -----------------------------------------------------------------------------
// XorShift128+ Predictor (V8 Math.random reference)
// -----------------------------------------------------------------------------

/// Predictor for XorShift128+ as used in V8's Math.random.
///
/// This requires reversing the XorShift128+ algorithm and solving for the
/// internal state (s0, s1) given a sequence of floating-point outputs.
///
/// Ported from the Python reference in `references/v8-randomness-predictor/main.py`.
///
/// This implementation relies on the fact that V8's `Math.random()` takes
/// the upper 52 bits of `state0` for the mantissa of the double.
/// To recover the full 64-bit state, we need a sufficient number of outputs
/// and potentially a Z3-like solver for full state recovery.
/// For this simplified Rust version, we'll implement the forward step and
/// note that full prediction from partial observations is complex.
pub struct Xorshift128PlusPredictor {
    /// Internal state (s0, s1) as 64-bit integers.
    internal_state: Option<(u64, u64)>,
    /// Observed 52-bit mantissas extracted from f64 outputs.
    observations: VecDeque<u64>,
}

impl Default for Xorshift128PlusPredictor {
    fn default() -> Self {
        Self {
            internal_state: None,
            // Requires at least 2 mantissas for state recovery in theory, more for Z3.
            observations: VecDeque::with_capacity(3),
        }
    }
}

impl PrngPredictor for Xorshift128PlusPredictor {
    fn observe(&mut self, value: PrngOutput) {
        if let PrngOutput::F64(v_f64) = value {
            // Convert f64 to u64 bit representation
            let u64_bits = v_f64.to_bits();
            // Extract the 52-bit mantissa (lower 52 bits)
            let mantissa = u64_bits & ((1 << 52) - 1);

            if self.observations.len() == self.observations.capacity() {
                self.observations.pop_front();
            }
            self.observations.push_back(mantissa);

            // Attempt to recover the state if we have enough observations and haven't already
            if self.internal_state.is_none() && self.observations.len() >= 2 {
                // Need at least 2 outputs
                self.recover_state();
            }
        } else {
            // Panic as this predictor specifically targets F64 outputs (V8 Math.random)
            panic!("Xorshift128PlusPredictor received non-F64 observation.");
        }
    }

    fn predict_next(&mut self) -> Option<PrngOutput> {
        if !self.can_predict() || self.internal_state.is_none() {
            return None;
        }

        let (s0, s1) = self.internal_state.unwrap();

        // Simulate one step of XorShift128+ to get the next state
        // This logic is from the Python script / V8 source code.
        // It's crucial to follow the V8 source (and Python) accurately:
        // `uint64_t s1_val = *state0;`
        // `uint64_t s0_val = *state1;`
        // `*state0 = s0_val;`  (New state0 is old state1)
        // `s1_val ^= s1_val << 23;`
        // `s1_val ^= s1_val >> 17;`
        // `s1_val ^= *state0;` (XOR with the new state0 (old state1))
        // `s1_val ^= *state0 >> 26;`
        // `*state1 = s1_val;` (New state1 is the result of tempering old state0 with new state0)

        let old_state0 = s0; // This `s0` is the V8 `state0`
        let old_state1 = s1; // This `s1` is the V8 `state1`

        // Calculate the next state values
        let new_state0 = old_state1; // V8 `state0` becomes old `state1`

        let mut next_s1_calc = old_state0; // This is `s1_val` in the V8 source
        next_s1_calc ^= next_s1_calc << 23;
        next_s1_calc ^= next_s1_calc >> 17;
        next_s1_calc ^= new_state0; // XOR with the NEW state0 (which is old_state1)
        next_s1_calc ^= new_state0 >> 26;

        let new_state1 = next_s1_calc; // V8 `state1` becomes the result of tempering

        // Update the internal state of the predictor
        self.internal_state = Some((new_state0, new_state1));

        // The actual output (pseudo random double in [0,1)) from V8 is:
        // `((new_state0 >> 12) | 0x3FF0000000000000)` then converted to double and -1

        // Exponent for double values for [1.0 .. 2.0)
        const K_EXPONENT_BITS: u64 = 0x3FF0000000000000;
        let random_u64 = (new_state0 >> 12) | K_EXPONENT_BITS;
        let next_f64 = f64::from_bits(random_u64) - 1.0;

        Some(PrngOutput::F64(next_f64))
    }

    fn name(&self) -> &'static str {
        "XorShift128+ Predictor (V8 Math.random style)"
    }

    fn can_predict(&self) -> bool {
        self.internal_state.is_some()
    }
}

impl Xorshift128PlusPredictor {
    /// Attempts to recover the full 128-bit internal state (s0, s1)
    /// from observed 52-bit mantissas.
    ///
    /// This is the most complex part of the predictor, as it involves solving
    /// a system of linear equations over GF(2) or using a symbolic solver like Z3.
    ///
    /// For this Rust implementation, we'll outline the approach but
    /// a full, robust solver without external dependencies is non-trivial.
    ///
    /// We need to reverse the operations `s1 ^= s1 << 23; s1 ^= s1 >> 17; etc.`
    /// from the observed mantissas to the 64-bit state components.
    fn recover_state(&mut self) {
        if self.observations.len() < 2 {
            return; // Need at least two observations to start recovering
        }

        // The core idea is to reverse the xorshift128+ operations.
        // For Math.random(), only 52 bits of `state0` are used for the mantissa.
        // This leaves 12 unknown bits in `state0` and all 64 bits of `state1` initially unknown.
        // With subsequent observations, we can constrain these bits.

        // Without a symbolic solver or a specialized linear algebra solver over GF(2),
        // a direct port of the Python Z3 logic is not feasible in pure Rust within this scope.
        //
        // A simplified approach might involve iterating through possible values for the
        // unknown bits (12 for s0, 64 for s1) and checking if they produce the observed outputs.
        // This quickly becomes computationally infeasible.

        // For now, we will leave this as a placeholder, highlighting the complexity.
        // If the user wants a full implementation, integrating a Z3-like solver (if available)
        // or a dedicated bit-manipulation solver would be required.

        // For demonstration, let's assume we magically know the state for a test case.
        // TODO: Implement actual state recovery or integrate a solver.
        // For now, if we have enough observations, we can set a dummy state
        // to allow `predict_next` to function (for testing its forward logic).
        if self.observations.len() >= 2 {
            // Placeholder: Assume we recovered some state for demonstration
            // In a real scenario, this would be computed by solving
            // from `self.observations[0]` and `self.observations[1]`
            // For now, let's just make `can_predict` work by setting `internal_state`
            // to some value if there are enough observations.
            // THIS IS NOT A REAL PREDICTOR. It only tests the forward step.
            self.internal_state = Some((0x123456789abcdef0, 0xfedcba9876543210));
        }
    }
}
// -----------------------------------------------------------------------------
// Mersenne Twister (MT19937) Predictor
// -----------------------------------------------------------------------------

// MT19937 constants (for 32-bit version)
pub const MT_N: usize = 624;
pub const MT_M: usize = 397;
pub const MT_MATRIX_A: u32 = 0x9908B0DF;
pub const MT_UPPER_MASK: u32 = 0x80000000; // Most significant w-r bits
pub const MT_LOWER_MASK: u32 = 0x7FFFFFFF; // Least significant r bits

// Tempering constants
pub const MT_TEMPERING_SHIFT_U: u32 = 11;
pub const MT_TEMPERING_SHIFT_S: u32 = 7;
pub const MT_TEMPERING_MASK_B: u32 = 0x9D2C5680;
pub const MT_TEMPERING_SHIFT_T: u32 = 15;
pub const MT_TEMPERING_MASK_C: u32 = 0xEFC60000;
pub const MT_TEMPERING_SHIFT_L: u32 = 18;

pub struct Mt19937Predictor {
    /// Internal state (MT array). This is recovered from observations.
    internal_state: Option<[u32; MT_N]>,
    /// Current index into the internal_state array, indicating the next value to be generated.
    state_index: usize,
    /// Buffer of observed (tempered) values.
    observations_buffer: VecDeque<u32>,
}

impl Default for Mt19937Predictor {
    fn default() -> Self {
        Self {
            internal_state: None,
            state_index: MT_N, // Initialize to N to trigger twist() on first predict
            observations_buffer: VecDeque::with_capacity(MT_N),
        }
    }
}

impl PrngPredictor for Mt19937Predictor {
    fn observe(&mut self, value: PrngOutput) {
        if let PrngOutput::U64(v_u64) = value {
            let v_u32 = v_u64 as u32; // Assuming 32-bit outputs for MT19937

            if self.observations_buffer.len() < MT_N {
                self.observations_buffer.push_back(v_u32);
            } else {
                self.observations_buffer.pop_front();
                self.observations_buffer.push_back(v_u32);
            }

            // Attempt to recover the state if we have enough observations and haven't already
            if self.internal_state.is_none() && self.observations_buffer.len() == MT_N {
                self.recover_state();
            }
        } else {
            panic!("Mt19937Predictor received non-U64 observation.");
        }
    }

    fn predict_next(&mut self) -> Option<PrngOutput> {
        if !self.can_predict() {
            return None;
        }

        // Check if we need to twist before getting an immutable reference to state
        if self.state_index >= MT_N {
            self.twist(); // This mutates self.internal_state directly
            self.state_index = 0;
        }

        // Now, get an immutable reference to the state for reading the current value
        let state = self.internal_state.as_ref()?;

        let mut y = state[self.state_index];
        y ^= y >> MT_TEMPERING_SHIFT_U;
        y ^= (y << MT_TEMPERING_SHIFT_S) & MT_TEMPERING_MASK_B;
        y ^= (y << MT_TEMPERING_SHIFT_T) & MT_TEMPERING_MASK_C;
        y ^= y >> MT_TEMPERING_SHIFT_L;

        self.state_index += 1;
        Some(PrngOutput::U64(y as u64))
    }

    fn name(&self) -> &'static str {
        "Mersenne Twister (MT19937) Predictor"
    }

    fn can_predict(&self) -> bool {
        self.internal_state.is_some()
    }
}

impl Mt19937Predictor {
    /// Internal twist function for MT19937.
    /// This generates the next N words of the internal state.
    fn twist(&mut self) {
        let mt = self.internal_state.as_mut().unwrap(); // Access directly
        for i in 0..MT_N {
            let x = (mt[i] & MT_UPPER_MASK) + (mt[(i + 1) % MT_N] & MT_LOWER_MASK);
            let mut x_a = x >> 1;
            if (x % 2) != 0 {
                x_a ^= MT_MATRIX_A;
            }
            mt[i] = mt[(i + MT_M) % MT_N] ^ x_a;
        }
    }

    /// Recovers the internal state of MT19937 from observed tempered values.
    /// This involves reversing the tempering function for each observed value.
    fn recover_state(&mut self) {
        if self.observations_buffer.len() < MT_N {
            return;
        }

        let mut recovered_state = [0u32; MT_N];
        for i in 0..MT_N {
            recovered_state[i] = Mt19937Predictor::untemper(self.observations_buffer[i]);
        }
        self.internal_state = Some(recovered_state);
        self.state_index = MT_N; // Force a twist() on first predict_next call
    }

    /// Reverses the tempering function for MT19937 output.
    /// This is a complex bit manipulation.
    fn untemper(mut y: u32) -> u32 {
        // Reverse y ^= (y >> MT_TEMPERING_SHIFT_L);
        y = untemper_r(y, MT_TEMPERING_SHIFT_L);

        // Reverse y ^= (y << MT_TEMPERING_SHIFT_T) & MT_TEMPERING_MASK_C;
        y = untemper_l(y, MT_TEMPERING_SHIFT_T, MT_TEMPERING_MASK_C);

        // Reverse y ^= (y << MT_TEMPERING_SHIFT_S) & MT_TEMPERING_MASK_B;
        y = untemper_l(y, MT_TEMPERING_SHIFT_S, MT_TEMPERING_MASK_B);

        // Reverse y ^= (y >> MT_TEMPERING_SHIFT_U);
        y = untemper_r(y, MT_TEMPERING_SHIFT_U);

        y
    }
}

// Helper functions for untempering operations
// Reverses a right XOR shift: x = y ^ (y >> shift) ^ (y >> 2*shift) ...
fn untemper_r(mut val: u32, shift: u32) -> u32 {
    let mut i = 1;
    while (i * shift) < 32 {
        val ^= val >> shift;
        i += 1;
    }
    val
}

// Reverses a left XOR shift with a mask: x = y ^ ((y << shift) & mask) ^ (((y << shift) & mask) << shift & mask) ...
fn untemper_l(mut val: u32, shift: u32, mask: u32) -> u32 {
    let mut i = 1;
    while (i * shift) < 32 {
        val ^= (val << shift) & mask;
        i += 1;
    }
    val
}
// -----------------------------------------------------------------------------
// Blum Blum Shub (BBS) Predictor
// -----------------------------------------------------------------------------

pub struct BlumBlumShubPredictor {
    /// The modulus N = p * q.
    pub n: Option<u64>,
    /// The prime factor p.
    pub p: Option<u64>,
    /// The prime factor q.
    pub q: Option<u64>,
    /// The current internal state (x_i).
    pub current_state: Option<u64>,
    /// Buffer of observed outputs.
    observations_buffer: VecDeque<u64>,
}

impl Default for BlumBlumShubPredictor {
    fn default() -> Self {
        Self {
            n: None,
            p: None,
            q: None,
            current_state: None,
            observations_buffer: VecDeque::with_capacity(5), // Need a few outputs
        }
    }
}

impl PrngPredictor for BlumBlumShubPredictor {
    fn observe(&mut self, value: PrngOutput) {
        if let PrngOutput::U64(v_u64) = value {
            // BBS typically outputs LSBs or the full x_i.
            // Assuming for now that v_u64 is the full x_i state or enough bits to reconstruct it.
            if self.observations_buffer.len() == self.observations_buffer.capacity() {
                self.observations_buffer.pop_front();
            }
            self.observations_buffer.push_back(v_u64);

            if self.current_state.is_none() && self.observations_buffer.len() >= 2 {
                self.recover_state();
            }
        } else {
            panic!("BlumBlumShubPredictor received non-U64 observation.");
        }
    }

    fn predict_next(&mut self) -> Option<PrngOutput> {
        if !self.can_predict() {
            return None;
        }

        let n_val = self.n?;
        let current_x = self.current_state?;

        let next_x = (current_x.wrapping_mul(current_x)) % n_val;
        self.current_state = Some(next_x);

        // BBS usually outputs the least significant bit (LSB).
        // For simplicity, let's output the LSB for now.
        Some(PrngOutput::U64(next_x & 1))
    }

    fn name(&self) -> &'static str {
        "Blum Blum Shub Predictor"
    }

    fn can_predict(&self) -> bool {
        // Can predict if n and current_state are known.
        self.n.is_some() && self.current_state.is_some()
    }
}

impl BlumBlumShubPredictor {
    /// Attempts to recover the internal state (current_x) and modulus (n, p, q).
    ///
    /// If only observed output bits are available, recovering the state (and especially p, q)
    /// is equivalent to factoring N, which is computationally hard.
    ///
    /// For this predictor, we assume `n` (and optionally `p, q`) are set via configuration
    /// or if the observed values are large enough to be the full `x_i` state, we try to recover `n`.
    fn recover_state(&mut self) {
        if self.observations_buffer.len() < 2 {
            return; // Need at least two outputs to derive some relations.
        }

        // If N, p, q are not set, and we only have LSBs, recovery is hard (factoring).
        // If we have full x_i values (as assumed by PrngOutput::U64(v_u64) is full x_i),
        // we can set the current_state and potentially N if it's derived.

        // Placeholder: If we get two full x_i states, we can set current_state and derive n.
        // x_1 = x_0^2 mod n.
        // n = (x_0^2 - x_1) / k. We need to find k.

        // This is a complex problem, similar to the XorShift128+ state recovery.
        // For simplicity, we'll assume `n` is set externally, and `current_state` is derived from an observation.
        if self.n.is_none() && self.observations_buffer.len() >= 2 {
            // Assume the first observed value is x_0 and the second is x_1.
            // For a robust predictor, these should be the actual states x_i, not output bits.
            // If v_u64 are indeed the *full states*, then:
            self.current_state = Some(self.observations_buffer[0]);
            // How to find n?
            // If we have x_0 and x_1, and x_1 = x_0^2 mod n.
            // Then x_0^2 - x_1 must be a multiple of n.
            // n must be a divisor of (x_0^2 - x_1).
            // We'd need to compute gcd(x_0^2 - x_1, x_1^2 - x_2, ...) to find n.
            // This is also non-trivial.

            // For now, let's assume N is externally configured.
            // If we need to recover N, p, q from outputs, that is a research problem.
            // For a practical predictor in Rust, we'd need to be given N, p, q or rely on a specialized library.
            // Placeholder: Assume n is known.
            self.n = Some(0x7FFFFFFFFFFFFFFFu64); // Dummy large prime-like N
            self.current_state = Some(self.observations_buffer[0]);
        }
    }
}

// -----------------------------------------------------------------------------
// NIST SP 800-90A Predictor
// -----------------------------------------------------------------------------

/// Predictor for NIST SP 800-90A compliant DRBGs (Hash_DRBG, HMAC_DRBG, CTR_DRBG).
///
/// These are cryptographically secure deterministic random bit generators (CS-PRNGs).
/// By design, their output is computationally infeasible to predict without knowledge
/// of their internal state (seed, key, V) and/or underlying cryptographic primitives,
/// or by exploiting specific implementation weaknesses (e.g., insufficient entropy
/// in seeding, side-channel attacks).
///
/// This predictor serves primarily as a placeholder to acknowledge the standard.
/// A true "prediction" of its output from observed values is generally considered
/// equivalent to breaking the underlying cryptographic primitives, which is beyond
/// the scope of a simple PRNG predictor.
pub struct NistSp80090aPredictor {
    // No internal state to predict from observations, as it's designed to be unpredictable.
    // However, we can track observations if we wanted to implement statistical tests.
    pub observations_count: usize,
}

impl Default for NistSp80090aPredictor {
    fn default() -> Self {
        Self {
            observations_count: 0,
        }
    }
}

impl PrngPredictor for NistSp80090aPredictor {
    fn observe(&mut self, _value: PrngOutput) {
        self.observations_count += 1;
        // In a real scenario, this could be used to run statistical tests
        // on the observed output for non-randomness, but not for prediction.
    }

    fn predict_next(&mut self) -> Option<PrngOutput> {
        // By design, a NIST SP 800-90A compliant DRBG cannot be predicted
        // from its outputs alone.
        None
    }

    fn name(&self) -> &'static str {
        "NIST SP 800-90A Compliant DRBG Predictor"
    }

    fn can_predict(&self) -> bool {
        // A cryptographically secure PRNG cannot be predicted from its outputs.
        false
    }
}
