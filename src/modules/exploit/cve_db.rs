/// CVE Exploit Database
///
/// ✅ ZERO DEPENDENCIES - Pure Rust CVE database
///
/// **What Does This Do?**
/// Maps CVE IDs to known public exploits for quick reference during pentests.
///
/// **⚠️ AUTHORIZED USE ONLY**
///
/// **Works alongside**:
/// - searchsploit (Exploit-DB)
/// - Metasploit modules
/// - GitHub exploit repositories
use std::collections::HashMap;

/// CVE exploit entry
#[derive(Debug, Clone)]
pub struct CveExploit {
    pub cve_id: String,
    pub title: String,
    pub description: String,
    pub affected_versions: Vec<String>,
    pub exploit_available: bool,
    pub exploit_urls: Vec<String>,
    pub references: Vec<String>,
}

/// CVE database
pub struct CveDatabase {
    exploits: HashMap<String, CveExploit>,
}

impl CveDatabase {
    pub fn new() -> Self {
        let mut db = Self {
            exploits: HashMap::new(),
        };
        db.load_kernel_exploits();
        db.load_web_exploits();
        db
    }

    /// Load known kernel exploits
    fn load_kernel_exploits(&mut self) {
        // DirtyCOW
        self.exploits.insert(
            "CVE-2016-5195".to_string(),
            CveExploit {
                cve_id: "CVE-2016-5195".to_string(),
                title: "DirtyCOW - Linux Kernel Memory Corruption".to_string(),
                description: "Race condition in mm/gup.c in the Linux kernel allows local users to gain privileges via COW breakage".to_string(),
                affected_versions: vec![
                    "Linux kernel 2.6.22 - 4.8.3".to_string(),
                ],
                exploit_available: true,
                exploit_urls: vec![
                    "https://github.com/dirtycow/dirtycow.github.io".to_string(),
                    "https://www.exploit-db.com/exploits/40839".to_string(),
                ],
                references: vec![
                    "https://www.cvedetails.com/cve/CVE-2016-5195/".to_string(),
                ],
            },
        );

        // Add more kernel exploits here...
    }

    /// Load web application exploits
    fn load_web_exploits(&mut self) {
        // Heartbleed
        self.exploits.insert(
            "CVE-2014-0160".to_string(),
            CveExploit {
                cve_id: "CVE-2014-0160".to_string(),
                title: "Heartbleed - OpenSSL TLS Heartbeat Memory Disclosure".to_string(),
                description: "Buffer over-read in OpenSSL's TLS heartbeat extension allows remote attackers to read memory".to_string(),
                affected_versions: vec![
                    "OpenSSL 1.0.1 - 1.0.1f".to_string(),
                ],
                exploit_available: true,
                exploit_urls: vec![
                    "https://github.com/sensepost/heartbleed-poc".to_string(),
                ],
                references: vec![
                    "https://heartbleed.com/".to_string(),
                ],
            },
        );
    }

    /// Search CVE database
    pub fn search(&self, query: &str) -> Vec<&CveExploit> {
        self.exploits
            .values()
            .filter(|e| {
                e.cve_id.to_lowercase().contains(&query.to_lowercase())
                    || e.title.to_lowercase().contains(&query.to_lowercase())
            })
            .collect()
    }

    /// Get exploit by CVE ID
    pub fn get(&self, cve_id: &str) -> Option<&CveExploit> {
        self.exploits.get(cve_id)
    }
}

impl Default for CveDatabase {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cve_search() {
        let db = CveDatabase::new();
        let results = db.search("dirtycow");
        assert!(!results.is_empty());
    }

    #[test]
    fn test_cve_get() {
        let db = CveDatabase::new();
        let exploit = db.get("CVE-2016-5195");
        assert!(exploit.is_some());
    }
}
