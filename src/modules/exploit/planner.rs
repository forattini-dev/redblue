use crate::modules::intel::attack_database::db as attack_db;
use crate::storage::records::{PortScanRecord, Severity, VulnerabilityRecord};
use std::collections::HashMap;

/// An organized attack plan based on findings
#[derive(Debug, Clone, Default)]
pub struct AttackPlan {
    pub target: String,
    pub phases: Vec<AttackPhase>,
    pub timestamp: u64,
}

/// A phase in the attack chain (e.g., Initial Access)
#[derive(Debug, Clone)]
pub struct AttackPhase {
    pub name: String,         // "Initial Access", "Privilege Escalation"
    pub mitre_tactic: String, // "TA0001"
    pub options: Vec<AttackOption>,
}

/// A specific attack option/vector
#[derive(Debug, Clone)]
pub struct AttackOption {
    pub technique_id: String,     // MITRE Technique ID (e.g., "T1190")
    pub technique_name: String,   // "Exploit Public-Facing Application"
    pub target_component: String, // "tcp/443 (nginx)" or "CVE-2021-44228"
    pub description: String,
    pub command: Option<String>, // Suggested rb command
    pub confidence: u8,          // 0-100
    pub risk: u8,                // 0-100 (OpSec risk)
    pub prerequisites: Vec<String>,
}

pub struct PlannerInput<'a> {
    pub target: &'a str,
    pub ports: &'a [PortScanRecord],
    pub vulns: &'a [VulnerabilityRecord],
    pub fingerprints: &'a [String], // e.g. "wordpress", "jenkins"
}

impl AttackPlan {
    pub fn new(target: &str) -> Self {
        Self {
            target: target.to_string(),
            phases: Vec::new(),
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
        }
    }

    pub fn add_phase(&mut self, phase: AttackPhase) {
        if !phase.options.is_empty() {
            self.phases.push(phase);
        }
    }
}

/// Generate an attack plan from findings
pub fn generate_plan(input: PlannerInput) -> AttackPlan {
    let mut plan = AttackPlan::new(input.target);

    // 1. Initial Access
    plan.add_phase(plan_initial_access(&input));

    // 2. Execution (often overlaps with Initial Access but can be distinct)
    // For now we merge relevant execution steps into Initial Access or treat separately if needed.
    // Let's check for specific execution vectors like RCE vulns.

    // 3. Privilege Escalation (Post-Exploitation planning)
    // This is harder to plan from outside, but we can suggest checks based on services.
    plan.add_phase(plan_privilege_escalation(&input));

    // 4. Lateral Movement
    plan.add_phase(plan_lateral_movement(&input));

    plan
}

fn plan_initial_access(input: &PlannerInput) -> AttackPhase {
    let mut options = Vec::new();
    let adb = attack_db();

    // 1. Check Vulnerabilities (CVEs)
    for vuln in input.vulns {
        // High severity or RCE vulns are prime initial access candidates
        if vuln.severity == Severity::Critical || vuln.severity == Severity::High {
            let tech_id = "T1190"; // Exploit Public-Facing Application
            let tech_name = adb
                .get_technique(tech_id)
                .map(|t| t.name.clone())
                .unwrap_or_else(|| "Exploit Public-Facing Application".to_string());

            options.push(AttackOption {
                technique_id: tech_id.to_string(),
                technique_name: tech_name,
                target_component: format!("{} ({})", vuln.cve_id, vuln.technology),
                description: format!("Exploit critical vulnerability: {}", vuln.description),
                command: Some(format!(
                    "rb exploit suggest {} --cve {}",
                    input.target, vuln.cve_id
                )),
                confidence: if vuln.exploit_available { 90 } else { 60 },
                risk: 80, // Exploitation is noisy
                prerequisites: vec!["Network visibility".to_string()],
            });
        }
    }

    // 2. Check Open Ports / Services
    for port in input.ports {
        match port.port {
            22 => {
                // SSH
                let tech_id = "T1133"; // External Remote Services
                let tech_name = adb
                    .get_technique(tech_id)
                    .map(|t| t.name.clone())
                    .unwrap_or_else(|| "External Remote Services".to_string());
                options.push(AttackOption {
                    technique_id: tech_id.to_string(),
                    technique_name: tech_name,
                    target_component: format!("tcp/{}", port.port),
                    description: "Attempt SSH credential brute-force or key spraying".to_string(),
                    command: Some(format!(
                        "rb access shell create ssh://root@{} --crack",
                        input.target
                    )),
                    confidence: 40,
                    risk: 70, // Brute-force is noisy
                    prerequisites: vec!["Valid username list".to_string()],
                });
            }
            21 => {
                // FTP
                let tech_id = "T1190";
                let tech_name = adb
                    .get_technique(tech_id)
                    .map(|t| t.name.clone())
                    .unwrap_or_else(|| "Exploit Public-Facing Application".to_string());
                options.push(AttackOption {
                    technique_id: tech_id.to_string(),
                    technique_name: tech_name,
                    target_component: format!("tcp/{}", port.port),
                    description:
                        "Check for anonymous FTP access or known FTP server vulnerabilities"
                            .to_string(),
                    command: Some(format!("rb access ftp check {}", input.target)),
                    confidence: 50,
                    risk: 30,
                    prerequisites: vec![].into(),
                });
            }
            80 | 443 | 8080 | 8443 => {
                // Web
                // Generic Web
                let tech_id = "T1190";
                let tech_name = adb
                    .get_technique(tech_id)
                    .map(|t| t.name.clone())
                    .unwrap_or_else(|| "Exploit Public-Facing Application".to_string());
                options.push(AttackOption {
                    technique_id: tech_id.to_string(),
                    technique_name: tech_name,
                    target_component: format!("tcp/{}", port.port),
                    description:
                        "Scan web application for common vulnerabilities (SQLi, XSS, etc.)"
                            .to_string(),
                    command: Some(format!("rb vuln scan {}", input.target)), // Use vuln scan
                    confidence: 60,
                    risk: 60,
                    prerequisites: vec![].into(),
                });
            }
            445 | 139 => {
                // SMB
                let tech_id = "T1133";
                let tech_name = adb
                    .get_technique(tech_id)
                    .map(|t| t.name.clone())
                    .unwrap_or_else(|| "External Remote Services".to_string());
                options.push(AttackOption {
                    technique_id: tech_id.to_string(),
                    technique_name: tech_name,
                    target_component: format!("tcp/{}", port.port),
                    description: "Check for null sessions, extensive shares, or SMB vulnerabilities (EternalBlue)".to_string(),
                    command: Some(format!("rb access smb list {}", input.target)), // Hypothetical command
                    confidence: 70,
                    risk: 50,
                    prerequisites: vec![].into(),
                });
            }
            _ => {}
        }
    }

    // 3. Check Fingerprints
    for fp in input.fingerprints {
        let lower_fp = fp.to_lowercase();
        if lower_fp.contains("wordpress") {
            options.push(AttackOption {
                technique_id: "T1190".to_string(),
                technique_name: "Exploit Public-Facing Application".to_string(),
                target_component: "WordPress".to_string(),
                description: "Enumerate WordPress users, plugins, and themes for vulnerabilities"
                    .to_string(),
                command: Some(format!("rb web app wordpress scan {}", input.target)), // Assuming web command
                confidence: 80,
                risk: 50,
                prerequisites: vec![].into(),
            });
        }
        if lower_fp.contains("jenkins") {
            options.push(AttackOption {
                technique_id: "T1133".to_string(),
                technique_name: "External Remote Services".to_string(),
                target_component: "Jenkins".to_string(),
                description: "Check for unauthenticated script console or default credentials"
                    .to_string(),
                command: None,
                confidence: 75,
                risk: 60,
                prerequisites: vec![].into(),
            });
        }
    }

    AttackPhase {
        name: "Initial Access".to_string(),
        mitre_tactic: "TA0001".to_string(),
        options,
    }
}

fn plan_privilege_escalation(input: &PlannerInput) -> AttackPhase {
    // This is mostly speculative based on OS detection or services known to run as root/SYSTEM
    let mut options = Vec::new();
    let adb = attack_db();

    // If we detected Linux
    options.push(AttackOption {
        technique_id: "T1068".to_string(),
        technique_name: adb
            .get_technique("T1068")
            .map(|t| t.name.clone())
            .unwrap_or("Exploitation for Privilege Escalation".to_string()),
        target_component: "Kernel/OS".to_string(),
        description: "Check for kernel exploits (DirtyPipe, etc.) or misconfigured SUID binaries"
            .to_string(),
        command: Some("rb exploit privesc linux enum".to_string()),
        confidence: 50,
        risk: 40,
        prerequisites: vec!["Initial Access".to_string()],
    });

    // If we detected Windows
    options.push(AttackOption {
        technique_id: "T1574".to_string(),
        technique_name: adb
            .get_technique("T1574")
            .map(|t| t.name.clone())
            .unwrap_or("Hijack Execution Flow".to_string()),
        target_component: "Services".to_string(),
        description: "Check for unquoted service paths or weak service permissions".to_string(),
        command: Some("rb exploit privesc windows enum".to_string()),
        confidence: 50,
        risk: 40,
        prerequisites: vec!["Initial Access".to_string()],
    });

    AttackPhase {
        name: "Privilege Escalation".to_string(),
        mitre_tactic: "TA0004".to_string(),
        options,
    }
}

fn plan_lateral_movement(input: &PlannerInput) -> AttackPhase {
    let mut options = Vec::new();
    let adb = attack_db();

    // Check for services useful for pivoting
    let has_ssh = input.ports.iter().any(|p| p.port == 22);
    let has_smb = input.ports.iter().any(|p| p.port == 445);

    if has_ssh {
        options.push(AttackOption {
            technique_id: "T1021.004".to_string(),
            technique_name: adb
                .get_technique("T1021.004")
                .map(|t| t.name.clone())
                .unwrap_or("Remote Services: SSH".to_string()),
            target_component: "SSH".to_string(),
            description: "Pivot through SSH tunnels or hijack SSH agent keys".to_string(),
            command: None,
            confidence: 80,
            risk: 30,
            prerequisites: vec!["Compromised Host with SSH keys".to_string()],
        });
    }

    if has_smb {
        options.push(AttackOption {
            technique_id: "T1021.002".to_string(),
            technique_name: adb
                .get_technique("T1021.002")
                .map(|t| t.name.clone())
                .unwrap_or("Remote Services: SMB/Windows Admin Shares".to_string()),
            target_component: "SMB".to_string(),
            description: "Pass-the-Hash or PSExec lateral movement".to_string(),
            command: None,
            confidence: 70,
            risk: 70, // High risk of detection
            prerequisites: vec!["Local Admin Creds/Hash".to_string()],
        });
    }

    AttackPhase {
        name: "Lateral Movement".to_string(),
        mitre_tactic: "TA0008".to_string(),
        options,
    }
}
