/// Privilege Escalation Enumeration
///
/// ✅ ZERO DEPENDENCIES - Pure Rust privilege escalation scanner
///
/// **What Does This Do?**
/// Enumerates common privilege escalation vectors on Linux and Windows systems.
/// This is the FIRST step after gaining initial access to a system.
///
/// **Privilege Escalation Vectors**:
///
/// **Linux**:
/// 1. SUID/SGID binaries (GTFOBins exploitation)
/// 2. Writable /etc/passwd, /etc/shadow
/// 3. Sudo misconfigurations (sudo -l)
/// 4. Kernel exploits (uname -a → searchsploit)
/// 5. Cron jobs with writable scripts
/// 6. Capabilities (getcap -r / 2>/dev/null)
/// 7. NFS shares with no_root_squash
/// 8. Docker socket exposure
/// 9. Writable service files
/// 10. PATH hijacking opportunities
///
/// **Windows**:
/// 1. Unquoted service paths
/// 2. Weak service permissions
/// 3. AlwaysInstallElevated registry keys
/// 4. Stored credentials (cmdkey, Credential Manager)
/// 5. Token impersonation (SeImpersonatePrivilege)
/// 6. Kernel exploits (systeminfo → Sherlock/Watson)
/// 7. Scheduled tasks with writable scripts
/// 8. DLL hijacking opportunities
/// 9. Group Policy Preferences (GPP) passwords
/// 10. Pass-the-Hash/Pass-the-Ticket
///
/// **⚠️ AUTHORIZED USE ONLY**:
/// - Penetration testing engagements
/// - CTF competitions
/// - Bug bounty programs
/// - Security research
/// - Educational purposes
///
/// **Works alongside**:
/// - LinPEAS (Linux privilege escalation)
/// - WinPEAS (Windows privilege escalation)
/// - LinEnum (Linux enumeration)
/// - PEASS-ng (complete suite)
/// - GTFOBins (SUID binary exploitation)
/// - Metasploit local_exploit_suggester

/// Operating system type
#[derive(Debug, Clone, PartialEq)]
pub enum OsType {
    Linux,
    Windows,
    Unknown,
}

/// Privilege escalation vector
#[derive(Debug, Clone)]
pub struct PrivEscVector {
    pub category: String,
    pub severity: Severity,
    pub title: String,
    pub description: String,
    pub exploit_technique: String,
    pub references: Vec<String>,
}

/// Severity level
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}

impl Severity {
    pub fn as_str(&self) -> &str {
        match self {
            Severity::Low => "LOW",
            Severity::Medium => "MEDIUM",
            Severity::High => "HIGH",
            Severity::Critical => "CRITICAL",
        }
    }

    pub fn color(&self) -> &str {
        match self {
            Severity::Low => "blue",
            Severity::Medium => "yellow",
            Severity::High => "orange",
            Severity::Critical => "red",
        }
    }
}

/// Privilege escalation result
#[derive(Debug, Clone)]
pub struct PrivEscScan {
    pub os_type: OsType,
    pub os_version: String,
    pub kernel_version: String,
    pub hostname: String,
    pub current_user: String,
    pub current_groups: Vec<String>,
    pub vectors: Vec<PrivEscVector>,
}

/// Privilege escalation scanner
pub struct PrivEscScanner {
    os_type: OsType,
}

impl PrivEscScanner {
    pub fn new() -> Self {
        Self {
            os_type: Self::detect_os(),
        }
    }

    /// Detect operating system type
    fn detect_os() -> OsType {
        #[cfg(target_os = "linux")]
        return OsType::Linux;

        #[cfg(target_os = "windows")]
        return OsType::Windows;

        #[cfg(not(any(target_os = "linux", target_os = "windows")))]
        return OsType::Unknown;
    }

    /// Run complete privilege escalation enumeration
    pub fn scan(&self) -> Result<PrivEscScan, String> {
        match self.os_type {
            OsType::Linux => self.scan_linux(),
            OsType::Windows => self.scan_windows(),
            OsType::Unknown => Err("Unsupported operating system".to_string()),
        }
    }

    /// Scan Linux system for privilege escalation vectors
    fn scan_linux(&self) -> Result<PrivEscScan, String> {
        let mut vectors = Vec::new();

        // Get system information
        let (os_version, kernel_version, hostname, current_user, current_groups) =
            self.get_linux_system_info()?;

        // 1. Check for SUID/SGID binaries
        vectors.extend(self.check_suid_binaries()?);

        // 2. Check writable sensitive files
        vectors.extend(self.check_writable_sensitive_files()?);

        // 3. Check sudo configuration
        vectors.extend(self.check_sudo_config()?);

        // 4. Check for known kernel exploits
        vectors.extend(self.check_kernel_exploits(&kernel_version)?);

        // 5. Check cron jobs
        vectors.extend(self.check_cron_jobs()?);

        // 6. Check capabilities
        vectors.extend(self.check_capabilities()?);

        // 7. Check Docker exposure
        vectors.extend(self.check_docker_exposure()?);

        // 8. Check PATH hijacking
        vectors.extend(self.check_path_hijacking()?);

        Ok(PrivEscScan {
            os_type: OsType::Linux,
            os_version,
            kernel_version,
            hostname,
            current_user,
            current_groups,
            vectors,
        })
    }

    /// Scan Windows system for privilege escalation vectors
    fn scan_windows(&self) -> Result<PrivEscScan, String> {
        let mut vectors = Vec::new();

        // Get system information
        let (os_version, kernel_version, hostname, current_user, current_groups) =
            self.get_windows_system_info()?;

        // 1. Check unquoted service paths
        vectors.extend(self.check_unquoted_service_paths()?);

        // 2. Check weak service permissions
        vectors.extend(self.check_weak_service_permissions()?);

        // 3. Check AlwaysInstallElevated
        vectors.extend(self.check_always_install_elevated()?);

        // 4. Check stored credentials
        vectors.extend(self.check_stored_credentials()?);

        // 5. Check SeImpersonatePrivilege
        vectors.extend(self.check_token_privileges()?);

        // 6. Check kernel exploits
        vectors.extend(self.check_windows_kernel_exploits(&os_version)?);

        // 7. Check scheduled tasks
        vectors.extend(self.check_scheduled_tasks()?);

        // 8. Check DLL hijacking
        vectors.extend(self.check_dll_hijacking()?);

        Ok(PrivEscScan {
            os_type: OsType::Windows,
            os_version,
            kernel_version,
            hostname,
            current_user,
            current_groups,
            vectors,
        })
    }

    /// Get Linux system information
    fn get_linux_system_info(
        &self,
    ) -> Result<(String, String, String, String, Vec<String>), String> {
        use std::process::Command;

        // OS version
        let os_version = Command::new("cat")
            .arg("/etc/os-release")
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).to_string())
            .unwrap_or_else(|_| "Unknown".to_string());

        // Kernel version
        let kernel_version = Command::new("uname")
            .arg("-r")
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
            .unwrap_or_else(|_| "Unknown".to_string());

        // Hostname
        let hostname = Command::new("hostname")
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
            .unwrap_or_else(|_| "Unknown".to_string());

        // Current user
        let current_user = Command::new("whoami")
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
            .unwrap_or_else(|_| "Unknown".to_string());

        // Current groups
        let groups_output = Command::new("groups")
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
            .unwrap_or_else(|_| String::new());

        let current_groups: Vec<String> = groups_output
            .split_whitespace()
            .map(|s| s.to_string())
            .collect();

        Ok((
            os_version,
            kernel_version,
            hostname,
            current_user,
            current_groups,
        ))
    }

    /// Check for SUID/SGID binaries
    fn check_suid_binaries(&self) -> Result<Vec<PrivEscVector>, String> {
        use std::process::Command;

        let mut vectors = Vec::new();

        // Find SUID binaries
        let output = Command::new("find")
            .args(&["/", "-perm", "-4000", "-type", "f", "2>/dev/null"])
            .output();

        if let Ok(output) = output {
            let suid_binaries = String::from_utf8_lossy(&output.stdout);

            // Known exploitable SUID binaries (GTFOBins)
            let exploitable = vec![
                "nmap", "vim", "find", "bash", "more", "less", "nano", "cp", "mv", "awk", "perl",
                "python", "ruby", "lua", "env", "ftp", "gdb", "git", "zip", "tar", "docker",
            ];

            for binary in suid_binaries.lines() {
                for exploit_bin in &exploitable {
                    if binary.contains(exploit_bin) {
                        vectors.push(PrivEscVector {
                            category: "SUID Binary".to_string(),
                            severity: Severity::Critical,
                            title: format!("Exploitable SUID binary: {}", binary),
                            description: format!(
                                "The binary '{}' has SUID bit set and can be exploited for privilege escalation",
                                exploit_bin
                            ),
                            exploit_technique: format!(
                                "Check GTFOBins for {} SUID exploitation: https://gtfobins.github.io/gtfobins/{}/",
                                exploit_bin, exploit_bin
                            ),
                            references: vec![
                                format!("https://gtfobins.github.io/gtfobins/{}/", exploit_bin),
                                "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#suid".to_string(),
                            ],
                        });
                    }
                }
            }
        }

        Ok(vectors)
    }

    /// Check writable sensitive files
    fn check_writable_sensitive_files(&self) -> Result<Vec<PrivEscVector>, String> {
        use std::process::Command;

        let mut vectors = Vec::new();

        // Check writable /etc/passwd
        let passwd_writable = Command::new("test")
            .args(&["-w", "/etc/passwd"])
            .status()
            .map(|s| s.success())
            .unwrap_or(false);

        if passwd_writable {
            vectors.push(PrivEscVector {
                category: "Writable Sensitive File".to_string(),
                severity: Severity::Critical,
                title: "/etc/passwd is writable".to_string(),
                description: "The /etc/passwd file is writable! Can add root user.".to_string(),
                exploit_technique: r#"
Add new root user:
echo 'hacker:x:0:0:root:/root:/bin/bash' >> /etc/passwd
openssl passwd -1 -salt hacker password123
# Then add password hash to /etc/shadow or use /etc/passwd password field
"#.to_string(),
                references: vec![
                    "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#writable-etc-passwd".to_string(),
                ],
            });
        }

        // Check writable /etc/shadow
        let shadow_writable = Command::new("test")
            .args(&["-w", "/etc/shadow"])
            .status()
            .map(|s| s.success())
            .unwrap_or(false);

        if shadow_writable {
            vectors.push(PrivEscVector {
                category: "Writable Sensitive File".to_string(),
                severity: Severity::Critical,
                title: "/etc/shadow is writable".to_string(),
                description: "The /etc/shadow file is writable! Can change root password.".to_string(),
                exploit_technique: r#"
Generate password hash:
mkpasswd -m sha-512 newpassword

Replace root line in /etc/shadow with new hash
"#.to_string(),
                references: vec![
                    "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#writable-etc-shadow".to_string(),
                ],
            });
        }

        Ok(vectors)
    }

    /// Check sudo configuration
    fn check_sudo_config(&self) -> Result<Vec<PrivEscVector>, String> {
        use std::process::Command;

        let mut vectors = Vec::new();

        // Check sudo -l
        let output = Command::new("sudo").args(&["-l"]).output();

        if let Ok(output) = output {
            let sudo_output = String::from_utf8_lossy(&output.stdout);

            // Check for NOPASSWD
            if sudo_output.contains("NOPASSWD") {
                vectors.push(PrivEscVector {
                    category: "Sudo Misconfiguration".to_string(),
                    severity: Severity::High,
                    title: "NOPASSWD sudo entry found".to_string(),
                    description: "User can run commands as root without password".to_string(),
                    exploit_technique: "Run: sudo -l to see which commands. Then execute with sudo.".to_string(),
                    references: vec![
                        "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#sudo-and-suid".to_string(),
                    ],
                });
            }

            // Check for (ALL : ALL) ALL
            if sudo_output.contains("(ALL : ALL) ALL") || sudo_output.contains("(ALL) ALL") {
                vectors.push(PrivEscVector {
                    category: "Sudo Misconfiguration".to_string(),
                    severity: Severity::Critical,
                    title: "User has full sudo access".to_string(),
                    description: "User can run ALL commands as root".to_string(),
                    exploit_technique: "Run: sudo su - OR sudo /bin/bash".to_string(),
                    references: vec![
                        "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#sudo-and-suid".to_string(),
                    ],
                });
            }
        }

        Ok(vectors)
    }

    /// Check for known kernel exploits
    fn check_kernel_exploits(&self, kernel_version: &str) -> Result<Vec<PrivEscVector>, String> {
        let mut vectors = Vec::new();

        // Known exploitable kernel versions
        let exploits = vec![
            ("2.6.22", "vmsplice", "CVE-2008-0600", "Local root exploit"),
            (
                "2.6.37",
                "Full-Nelson",
                "CVE-2010-4258",
                "Local privilege escalation",
            ),
            (
                "3.13.0",
                "OverlayFS",
                "CVE-2015-1328",
                "Ubuntu overlayfs local root",
            ),
            (
                "3.13.0",
                "DirtyCOW",
                "CVE-2016-5195",
                "Race condition in memory subsystem",
            ),
            (
                "4.4.0",
                "AF_PACKET",
                "CVE-2016-8655",
                "Packet socket use-after-free",
            ),
            ("4.8.0", "DirtyCOW2", "CVE-2016-5195", "Dirty COW variant"),
        ];

        for (version, name, cve, desc) in exploits {
            if kernel_version.contains(version) {
                vectors.push(PrivEscVector {
                    category: "Kernel Exploit".to_string(),
                    severity: Severity::Critical,
                    title: format!("Kernel vulnerable to {} ({})", name, cve),
                    description: desc.to_string(),
                    exploit_technique: format!(
                        "Search for {} exploit: searchsploit {} OR github.com/search?q={}",
                        name, cve, cve
                    ),
                    references: vec![
                        format!("https://www.cvedetails.com/cve/{}/", cve),
                        "https://github.com/SecWiki/linux-kernel-exploits".to_string(),
                    ],
                });
            }
        }

        Ok(vectors)
    }

    /// Check cron jobs for writable scripts
    fn check_cron_jobs(&self) -> Result<Vec<PrivEscVector>, String> {
        // TODO: Check /etc/crontab, /var/spool/cron, etc.
        Ok(Vec::new())
    }

    /// Check capabilities
    fn check_capabilities(&self) -> Result<Vec<PrivEscVector>, String> {
        // TODO: Run getcap -r / 2>/dev/null
        Ok(Vec::new())
    }

    /// Check Docker socket exposure
    fn check_docker_exposure(&self) -> Result<Vec<PrivEscVector>, String> {
        use std::process::Command;

        let mut vectors = Vec::new();

        // Check if user is in docker group
        let output = Command::new("groups").output();
        if let Ok(output) = output {
            let groups = String::from_utf8_lossy(&output.stdout);
            if groups.contains("docker") {
                vectors.push(PrivEscVector {
                    category: "Docker Misconfiguration".to_string(),
                    severity: Severity::Critical,
                    title: "User is in docker group".to_string(),
                    description: "Can escalate to root via Docker".to_string(),
                    exploit_technique: r#"
docker run -v /:/mnt --rm -it alpine chroot /mnt sh
# OR
docker run -v /:/mnt --rm -it ubuntu chroot /mnt bash
"#
                    .to_string(),
                    references: vec!["https://gtfobins.github.io/gtfobins/docker/".to_string()],
                });
            }
        }

        Ok(vectors)
    }

    /// Check PATH hijacking opportunities
    fn check_path_hijacking(&self) -> Result<Vec<PrivEscVector>, String> {
        // TODO: Check for writable directories in PATH
        Ok(Vec::new())
    }

    /// Get Windows system information
    fn get_windows_system_info(
        &self,
    ) -> Result<(String, String, String, String, Vec<String>), String> {
        // TODO: Windows system enumeration
        Ok((
            "Windows".to_string(),
            "Unknown".to_string(),
            "Unknown".to_string(),
            "Unknown".to_string(),
            Vec::new(),
        ))
    }

    /// Check unquoted service paths (Windows)
    fn check_unquoted_service_paths(&self) -> Result<Vec<PrivEscVector>, String> {
        // TODO: wmic service get name,displayname,pathname,startmode
        Ok(Vec::new())
    }

    /// Check weak service permissions (Windows)
    fn check_weak_service_permissions(&self) -> Result<Vec<PrivEscVector>, String> {
        // TODO: accesschk.exe -uwcqv "Authenticated Users" *
        Ok(Vec::new())
    }

    /// Check AlwaysInstallElevated (Windows)
    fn check_always_install_elevated(&self) -> Result<Vec<PrivEscVector>, String> {
        // TODO: reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
        Ok(Vec::new())
    }

    /// Check stored credentials (Windows)
    fn check_stored_credentials(&self) -> Result<Vec<PrivEscVector>, String> {
        // TODO: cmdkey /list
        Ok(Vec::new())
    }

    /// Check token privileges (Windows)
    fn check_token_privileges(&self) -> Result<Vec<PrivEscVector>, String> {
        // TODO: whoami /priv
        Ok(Vec::new())
    }

    /// Check Windows kernel exploits
    fn check_windows_kernel_exploits(
        &self,
        _os_version: &str,
    ) -> Result<Vec<PrivEscVector>, String> {
        // TODO: Use Sherlock/Watson database
        Ok(Vec::new())
    }

    /// Check scheduled tasks (Windows)
    fn check_scheduled_tasks(&self) -> Result<Vec<PrivEscVector>, String> {
        // TODO: schtasks /query /fo LIST /v
        Ok(Vec::new())
    }

    /// Check DLL hijacking (Windows)
    fn check_dll_hijacking(&self) -> Result<Vec<PrivEscVector>, String> {
        // TODO: Check writable directories in PATH
        Ok(Vec::new())
    }
}

impl Default for PrivEscScanner {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_os_detection() {
        let scanner = PrivEscScanner::new();
        #[cfg(target_os = "linux")]
        assert_eq!(scanner.os_type, OsType::Linux);

        #[cfg(target_os = "windows")]
        assert_eq!(scanner.os_type, OsType::Windows);
    }

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::Critical > Severity::High);
        assert!(Severity::High > Severity::Medium);
        assert!(Severity::Medium > Severity::Low);
    }
}
