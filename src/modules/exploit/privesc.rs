/// Privilege Escalation Enumeration
///
/// ✅ ZERO DEPENDENCIES - Pure Rust privilege escalation scanner
///
/// **What Does This Do?**
/// Enumerates common privilege escalation vectors on Linux and Windows systems.
/// This is the FIRST step after gaining initial access to a system.
///
/// **Privilege Escalation Vectors**:
///
/// **Linux**:
/// 1. SUID/SGID binaries (GTFOBins exploitation)
/// 2. Writable /etc/passwd, /etc/shadow
/// 3. Sudo misconfigurations (sudo -l)
/// 4. Kernel exploits (uname -a → searchsploit)
/// 5. Cron jobs with writable scripts
/// 6. Capabilities (getcap -r / 2>/dev/null)
/// 7. NFS shares with no_root_squash
/// 8. Docker socket exposure
/// 9. Writable service files
/// 10. PATH hijacking opportunities
///
/// **Windows**:
/// 1. Unquoted service paths
/// 2. Weak service permissions
/// 3. AlwaysInstallElevated registry keys
/// 4. Stored credentials (cmdkey, Credential Manager)
/// 5. Token impersonation (SeImpersonatePrivilege)
/// 6. Kernel exploits (systeminfo → Sherlock/Watson)
/// 7. Scheduled tasks with writable scripts
/// 8. DLL hijacking opportunities
/// 9. Group Policy Preferences (GPP) passwords
/// 10. Pass-the-Hash/Pass-the-Ticket
///
/// **⚠️ AUTHORIZED USE ONLY**:
/// - Penetration testing engagements
/// - CTF competitions
/// - Bug bounty programs
/// - Security research
/// - Educational purposes
///
/// **Works alongside**:
/// - LinPEAS (Linux privilege escalation)
/// - WinPEAS (Windows privilege escalation)
/// - LinEnum (Linux enumeration)
/// - PEASS-ng (complete suite)
/// - GTFOBins (SUID binary exploitation)
/// - Metasploit local_exploit_suggester

/// Operating system type
#[derive(Debug, Clone, PartialEq)]
pub enum OsType {
    Linux,
    Windows,
    Unknown,
}

/// Privilege escalation vector
#[derive(Debug, Clone)]
pub struct PrivEscVector {
    pub category: String,
    pub severity: Severity,
    pub title: String,
    pub description: String,
    pub exploit_technique: String,
    pub references: Vec<String>,
}

/// Severity level
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}

impl Severity {
    pub fn as_str(&self) -> &str {
        match self {
            Severity::Low => "LOW",
            Severity::Medium => "MEDIUM",
            Severity::High => "HIGH",
            Severity::Critical => "CRITICAL",
        }
    }

    pub fn color(&self) -> &str {
        match self {
            Severity::Low => "blue",
            Severity::Medium => "yellow",
            Severity::High => "orange",
            Severity::Critical => "red",
        }
    }
}

/// Privilege escalation result
#[derive(Debug, Clone)]
pub struct PrivEscScan {
    pub os_type: OsType,
    pub os_version: String,
    pub kernel_version: String,
    pub hostname: String,
    pub current_user: String,
    pub current_groups: Vec<String>,
    pub vectors: Vec<PrivEscVector>,
}

/// Privilege escalation scanner
pub struct PrivEscScanner {
    os_type: OsType,
}

impl PrivEscScanner {
    pub fn new() -> Self {
        Self {
            os_type: Self::detect_os(),
        }
    }

    /// Detect operating system type
    fn detect_os() -> OsType {
        #[cfg(target_os = "linux")]
        return OsType::Linux;

        #[cfg(target_os = "windows")]
        return OsType::Windows;

        #[cfg(not(any(target_os = "linux", target_os = "windows")))]
        return OsType::Unknown;
    }

    /// Run complete privilege escalation enumeration
    pub fn scan(&self) -> Result<PrivEscScan, String> {
        match self.os_type {
            OsType::Linux => self.scan_linux(),
            OsType::Windows => self.scan_windows(),
            OsType::Unknown => Err("Unsupported operating system".to_string()),
        }
    }

    /// Scan Linux system for privilege escalation vectors
    fn scan_linux(&self) -> Result<PrivEscScan, String> {
        let mut vectors = Vec::new();

        // Get system information
        let (os_version, kernel_version, hostname, current_user, current_groups) =
            self.get_linux_system_info()?;

        // 1. Check for SUID/SGID binaries
        vectors.extend(self.check_suid_binaries()?);

        // 2. Check writable sensitive files
        vectors.extend(self.check_writable_sensitive_files()?);

        // 3. Check sudo configuration
        vectors.extend(self.check_sudo_config()?);

        // 4. Check for known kernel exploits
        vectors.extend(self.check_kernel_exploits(&kernel_version)?);

        // 5. Check cron jobs
        vectors.extend(self.check_cron_jobs()?);

        // 6. Check capabilities
        vectors.extend(self.check_capabilities()?);

        // 7. Check Docker exposure
        vectors.extend(self.check_docker_exposure()?);

        // 8. Check PATH hijacking
        vectors.extend(self.check_path_hijacking()?);

        Ok(PrivEscScan {
            os_type: OsType::Linux,
            os_version,
            kernel_version,
            hostname,
            current_user,
            current_groups,
            vectors,
        })
    }

    /// Scan Windows system for privilege escalation vectors
    fn scan_windows(&self) -> Result<PrivEscScan, String> {
        let mut vectors = Vec::new();

        // Get system information
        let (os_version, kernel_version, hostname, current_user, current_groups) =
            self.get_windows_system_info()?;

        // 1. Check unquoted service paths
        vectors.extend(self.check_unquoted_service_paths()?);

        // 2. Check weak service permissions
        vectors.extend(self.check_weak_service_permissions()?);

        // 3. Check AlwaysInstallElevated
        vectors.extend(self.check_always_install_elevated()?);

        // 4. Check stored credentials
        vectors.extend(self.check_stored_credentials()?);

        // 5. Check SeImpersonatePrivilege
        vectors.extend(self.check_token_privileges()?);

        // 6. Check kernel exploits
        vectors.extend(self.check_windows_kernel_exploits(&os_version)?);

        // 7. Check scheduled tasks
        vectors.extend(self.check_scheduled_tasks()?);

        // 8. Check DLL hijacking
        vectors.extend(self.check_dll_hijacking()?);

        Ok(PrivEscScan {
            os_type: OsType::Windows,
            os_version,
            kernel_version,
            hostname,
            current_user,
            current_groups,
            vectors,
        })
    }

    /// Get Linux system information
    fn get_linux_system_info(
        &self,
    ) -> Result<(String, String, String, String, Vec<String>), String> {
        use std::process::Command;

        // OS version
        let os_version = Command::new("cat")
            .arg("/etc/os-release")
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).to_string())
            .unwrap_or_else(|_| "Unknown".to_string());

        // Kernel version
        let kernel_version = Command::new("uname")
            .arg("-r")
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
            .unwrap_or_else(|_| "Unknown".to_string());

        // Hostname
        let hostname = Command::new("hostname")
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
            .unwrap_or_else(|_| "Unknown".to_string());

        // Current user
        let current_user = Command::new("whoami")
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
            .unwrap_or_else(|_| "Unknown".to_string());

        // Current groups
        let groups_output = Command::new("groups")
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
            .unwrap_or_else(|_| String::new());

        let current_groups: Vec<String> = groups_output
            .split_whitespace()
            .map(|s| s.to_string())
            .collect();

        Ok((
            os_version,
            kernel_version,
            hostname,
            current_user,
            current_groups,
        ))
    }

    /// Check for SUID/SGID binaries
    fn check_suid_binaries(&self) -> Result<Vec<PrivEscVector>, String> {
        use std::process::Command;

        let mut vectors = Vec::new();

        // Find SUID binaries
        let output = Command::new("find")
            .args(&["/", "-perm", "-4000", "-type", "f", "2>/dev/null"])
            .output();

        if let Ok(output) = output {
            let suid_binaries = String::from_utf8_lossy(&output.stdout);

            // Known exploitable SUID binaries (GTFOBins)
            let exploitable = vec![
                "nmap", "vim", "find", "bash", "more", "less", "nano", "cp", "mv", "awk", "perl",
                "python", "ruby", "lua", "env", "ftp", "gdb", "git", "zip", "tar", "docker",
            ];

            for binary in suid_binaries.lines() {
                for exploit_bin in &exploitable {
                    if binary.contains(exploit_bin) {
                        vectors.push(PrivEscVector {
                            category: "SUID Binary".to_string(),
                            severity: Severity::Critical,
                            title: format!("Exploitable SUID binary: {}", binary),
                            description: format!(
                                "The binary '{}' has SUID bit set and can be exploited for privilege escalation",
                                exploit_bin
                            ),
                            exploit_technique: format!(
                                "Check GTFOBins for {} SUID exploitation: https://gtfobins.github.io/gtfobins/{}/",
                                exploit_bin, exploit_bin
                            ),
                            references: vec![
                                format!("https://gtfobins.github.io/gtfobins/{}/", exploit_bin),
                                "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#suid".to_string(),
                            ],
                        });
                    }
                }
            }
        }

        Ok(vectors)
    }

    /// Check writable sensitive files
    fn check_writable_sensitive_files(&self) -> Result<Vec<PrivEscVector>, String> {
        use std::process::Command;

        let mut vectors = Vec::new();

        // Check writable /etc/passwd
        let passwd_writable = Command::new("test")
            .args(&["-w", "/etc/passwd"])
            .status()
            .map(|s| s.success())
            .unwrap_or(false);

        if passwd_writable {
            vectors.push(PrivEscVector {
                category: "Writable Sensitive File".to_string(),
                severity: Severity::Critical,
                title: "/etc/passwd is writable".to_string(),
                description: "The /etc/passwd file is writable! Can add root user.".to_string(),
                exploit_technique: r#"
Add new root user:
echo 'hacker:x:0:0:root:/root:/bin/bash' >> /etc/passwd
openssl passwd -1 -salt hacker password123
# Then add password hash to /etc/shadow or use /etc/passwd password field
"#.to_string(),
                references: vec![
                    "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#writable-etc-passwd".to_string(),
                ],
            });
        }

        // Check writable /etc/shadow
        let shadow_writable = Command::new("test")
            .args(&["-w", "/etc/shadow"])
            .status()
            .map(|s| s.success())
            .unwrap_or(false);

        if shadow_writable {
            vectors.push(PrivEscVector {
                category: "Writable Sensitive File".to_string(),
                severity: Severity::Critical,
                title: "/etc/shadow is writable".to_string(),
                description: "The /etc/shadow file is writable! Can change root password.".to_string(),
                exploit_technique: r#"
Generate password hash:
mkpasswd -m sha-512 newpassword

Replace root line in /etc/shadow with new hash
"#.to_string(),
                references: vec![
                    "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#writable-etc-shadow".to_string(),
                ],
            });
        }

        Ok(vectors)
    }

    /// Check sudo configuration
    fn check_sudo_config(&self) -> Result<Vec<PrivEscVector>, String> {
        use std::process::Command;

        let mut vectors = Vec::new();

        // Check sudo -l
        let output = Command::new("sudo").args(&["-l"]).output();

        if let Ok(output) = output {
            let sudo_output = String::from_utf8_lossy(&output.stdout);

            // Check for NOPASSWD
            if sudo_output.contains("NOPASSWD") {
                vectors.push(PrivEscVector {
                    category: "Sudo Misconfiguration".to_string(),
                    severity: Severity::High,
                    title: "NOPASSWD sudo entry found".to_string(),
                    description: "User can run commands as root without password".to_string(),
                    exploit_technique: "Run: sudo -l to see which commands. Then execute with sudo.".to_string(),
                    references: vec![
                        "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#sudo-and-suid".to_string(),
                    ],
                });
            }

            // Check for (ALL : ALL) ALL
            if sudo_output.contains("(ALL : ALL) ALL") || sudo_output.contains("(ALL) ALL") {
                vectors.push(PrivEscVector {
                    category: "Sudo Misconfiguration".to_string(),
                    severity: Severity::Critical,
                    title: "User has full sudo access".to_string(),
                    description: "User can run ALL commands as root".to_string(),
                    exploit_technique: "Run: sudo su - OR sudo /bin/bash".to_string(),
                    references: vec![
                        "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#sudo-and-suid".to_string(),
                    ],
                });
            }
        }

        Ok(vectors)
    }

    /// Check for known kernel exploits
    fn check_kernel_exploits(&self, kernel_version: &str) -> Result<Vec<PrivEscVector>, String> {
        let mut vectors = Vec::new();

        // Known exploitable kernel versions
        let exploits = vec![
            ("2.6.22", "vmsplice", "CVE-2008-0600", "Local root exploit"),
            (
                "2.6.37",
                "Full-Nelson",
                "CVE-2010-4258",
                "Local privilege escalation",
            ),
            (
                "3.13.0",
                "OverlayFS",
                "CVE-2015-1328",
                "Ubuntu overlayfs local root",
            ),
            (
                "3.13.0",
                "DirtyCOW",
                "CVE-2016-5195",
                "Race condition in memory subsystem",
            ),
            (
                "4.4.0",
                "AF_PACKET",
                "CVE-2016-8655",
                "Packet socket use-after-free",
            ),
            ("4.8.0", "DirtyCOW2", "CVE-2016-5195", "Dirty COW variant"),
        ];

        for (version, name, cve, desc) in exploits {
            if kernel_version.contains(version) {
                vectors.push(PrivEscVector {
                    category: "Kernel Exploit".to_string(),
                    severity: Severity::Critical,
                    title: format!("Kernel vulnerable to {} ({})", name, cve),
                    description: desc.to_string(),
                    exploit_technique: format!(
                        "Search for {} exploit: searchsploit {} OR github.com/search?q={}",
                        name, cve, cve
                    ),
                    references: vec![
                        format!("https://www.cvedetails.com/cve/{}/", cve),
                        "https://github.com/SecWiki/linux-kernel-exploits".to_string(),
                    ],
                });
            }
        }

        Ok(vectors)
    }

    /// Check cron jobs for writable scripts
    fn check_cron_jobs(&self) -> Result<Vec<PrivEscVector>, String> {
        #[cfg(not(target_os = "linux"))]
        {
            let _ = self;
            return Ok(Vec::new());
        }

        #[cfg(target_os = "linux")]
        {
            use std::fs;
            use std::path::PathBuf;

            let mut vectors = Vec::new();
            let cron_files = ["/etc/crontab", "/etc/anacrontab", "/var/spool/cron/root"];
            let cron_directories = [
                "/etc/cron.d",
                "/var/spool/cron",
                "/var/spool/cron/crontabs",
                "/etc/cron.hourly",
                "/etc/cron.daily",
                "/etc/cron.weekly",
                "/etc/cron.monthly",
            ];

            let user_ids = self.current_user_ids().ok();

            let mut check_target = |target_path: PathBuf, source: &str| {
                if let Some((uid, gid)) = user_ids {
                    if let Ok(true) = self.is_path_writable_by_user(&target_path, uid, gid) {
                        let display = target_path.display().to_string();
                        vectors.push(PrivEscVector {
                            category: "Cron Job".to_string(),
                            severity: Severity::High,
                            title: format!("Writable cron target: {}", display),
                            description: format!(
                                "Cron job in '{}' references '{}' which the current user can modify",
                                source, display
                            ),
                            exploit_technique: format!(
                                "Inject commands into '{}' so they execute with elevated privileges when the cron job runs",
                                display
                            ),
                            references: vec![
                                "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#cron-jobs"
                                    .to_string(),
                            ],
                        });
                    }
                }
            };

            for cron_file in &cron_files {
                if let Ok(contents) = fs::read_to_string(cron_file) {
                    for target in Self::extract_cron_targets(&contents) {
                        check_target(target, cron_file);
                    }
                }
            }

            for directory in &cron_directories {
                if let Ok(entries) = fs::read_dir(directory) {
                    for entry in entries.flatten() {
                        let path = entry.path();
                        if path.is_file() {
                            check_target(path, directory);
                        }
                    }
                }
            }

            Ok(vectors)
        }
    }

    /// Check capabilities
    fn check_capabilities(&self) -> Result<Vec<PrivEscVector>, String> {
        use std::process::Command;

        let mut vectors = Vec::new();
        let output = Command::new("getcap").arg("-r").arg("/").output();

        let output = match output {
            Ok(v) => v,
            Err(_) => return Ok(vectors),
        };

        if !output.status.success() {
            return Ok(vectors);
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        for line in stdout.lines() {
            let parts: Vec<&str> = line.split('=').map(|s| s.trim()).collect();
            if parts.len() != 2 {
                continue;
            }

            let path = parts[0];
            let caps = parts[1];
            if path.is_empty() || caps.is_empty() {
                continue;
            }

            vectors.push(PrivEscVector {
                category: "File Capability".to_string(),
                severity: Severity::High,
                title: format!("{} has capabilities", path),
                description: format!(
                    "Binary '{}' is assigned capabilities '{}', which may be leveraged for privilege escalation",
                    path, caps
                ),
                exploit_technique: format!(
                    "Confirm abuse path: echo 'id' | {}",
                    path
                ),
                references: vec![
                    "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#capabilities"
                        .to_string(),
                ],
            });
        }

        Ok(vectors)
    }

    /// Check Docker socket exposure
    fn check_docker_exposure(&self) -> Result<Vec<PrivEscVector>, String> {
        use std::process::Command;

        let mut vectors = Vec::new();

        // Check if user is in docker group
        let output = Command::new("groups").output();
        if let Ok(output) = output {
            let groups = String::from_utf8_lossy(&output.stdout);
            if groups.contains("docker") {
                vectors.push(PrivEscVector {
                    category: "Docker Misconfiguration".to_string(),
                    severity: Severity::Critical,
                    title: "User is in docker group".to_string(),
                    description: "Can escalate to root via Docker".to_string(),
                    exploit_technique: r#"
docker run -v /:/mnt --rm -it alpine chroot /mnt sh
# OR
docker run -v /:/mnt --rm -it ubuntu chroot /mnt bash
"#
                    .to_string(),
                    references: vec!["https://gtfobins.github.io/gtfobins/docker/".to_string()],
                });
            }
        }

        Ok(vectors)
    }

    /// Check PATH hijacking opportunities
    fn check_path_hijacking(&self) -> Result<Vec<PrivEscVector>, String> {
        #[cfg(not(target_os = "linux"))]
        {
            Ok(Vec::new())
        }

        #[cfg(target_os = "linux")]
        {
            use std::env;
            use std::path::Path;

            let mut vectors = Vec::new();
            let path_env = match env::var("PATH") {
                Ok(value) => value,
                Err(_) => return Ok(vectors),
            };

            let (uid, gid) = match self.current_user_ids() {
                Ok(ids) => ids,
                Err(_) => return Ok(vectors),
            };

            for entry in path_env.split(':') {
                let trimmed = entry.trim();
                if trimmed.is_empty() {
                    continue;
                }

                let path = Path::new(trimmed);
                if !path.exists() {
                    continue;
                }

                if let Ok(classification) = self.path_writable_classification(path, uid, gid) {
                    match classification {
                        PathWritable::NotWritable => {}
                        PathWritable::UserWritable => vectors.push(Self::build_path_hijack_vector(
                            path,
                            "Directory in PATH writable by current user",
                            Severity::High,
                        )),
                        PathWritable::WorldWritable => {
                            vectors.push(Self::build_path_hijack_vector(
                                path,
                                "Directory in PATH is world-writable",
                                Severity::Critical,
                            ))
                        }
                        PathWritable::StickyWorldWritable => {
                            vectors.push(Self::build_path_hijack_vector(
                                path,
                                "World-writable PATH directory relies on sticky bit",
                                Severity::Medium,
                            ))
                        }
                    }
                }
            }

            Ok(vectors)
        }
    }

    /// Get Windows system information
    fn get_windows_system_info(
        &self,
    ) -> Result<(String, String, String, String, Vec<String>), String> {
        #[cfg(target_os = "windows")]
        {
            return self.get_windows_system_info_windows();
        }

        #[cfg(not(target_os = "windows"))]
        {
            Ok((
                "Windows".to_string(),
                "Unknown".to_string(),
                "Unknown".to_string(),
                "Unknown".to_string(),
                Vec::new(),
            ))
        }
    }

    /// Check unquoted service paths (Windows)
    fn check_unquoted_service_paths(&self) -> Result<Vec<PrivEscVector>, String> {
        #[cfg(target_os = "windows")]
        {
            return self.check_unquoted_service_paths_windows();
        }

        #[cfg(not(target_os = "windows"))]
        {
            Ok(Vec::new())
        }
    }

    /// Check weak service permissions (Windows)
    fn check_weak_service_permissions(&self) -> Result<Vec<PrivEscVector>, String> {
        #[cfg(target_os = "windows")]
        {
            return self.check_weak_service_permissions_windows();
        }

        #[cfg(not(target_os = "windows"))]
        {
            Ok(Vec::new())
        }
    }

    /// Check AlwaysInstallElevated (Windows)
    fn check_always_install_elevated(&self) -> Result<Vec<PrivEscVector>, String> {
        #[cfg(target_os = "windows")]
        {
            return self.check_always_install_elevated_windows();
        }

        #[cfg(not(target_os = "windows"))]
        {
            Ok(Vec::new())
        }
    }

    /// Check stored credentials (Windows)
    fn check_stored_credentials(&self) -> Result<Vec<PrivEscVector>, String> {
        #[cfg(target_os = "windows")]
        {
            return self.check_stored_credentials_windows();
        }

        #[cfg(not(target_os = "windows"))]
        {
            Ok(Vec::new())
        }
    }

    /// Check token privileges (Windows)
    fn check_token_privileges(&self) -> Result<Vec<PrivEscVector>, String> {
        #[cfg(target_os = "windows")]
        {
            return self.check_token_privileges_windows();
        }

        #[cfg(not(target_os = "windows"))]
        {
            Ok(Vec::new())
        }
    }

    /// Check Windows kernel exploits
    fn check_windows_kernel_exploits(
        &self,
        _os_version: &str,
    ) -> Result<Vec<PrivEscVector>, String> {
        #[cfg(target_os = "windows")]
        {
            return self.check_windows_kernel_exploits_windows(_os_version);
        }

        #[cfg(not(target_os = "windows"))]
        {
            Ok(Vec::new())
        }
    }

    /// Check scheduled tasks (Windows)
    fn check_scheduled_tasks(&self) -> Result<Vec<PrivEscVector>, String> {
        #[cfg(target_os = "windows")]
        {
            return self.check_scheduled_tasks_windows();
        }

        #[cfg(not(target_os = "windows"))]
        {
            Ok(Vec::new())
        }
    }

    /// Check DLL hijacking (Windows)
    fn check_dll_hijacking(&self) -> Result<Vec<PrivEscVector>, String> {
        #[cfg(target_os = "windows")]
        {
            return self.check_dll_hijacking_windows();
        }

        #[cfg(not(target_os = "windows"))]
        {
            Ok(Vec::new())
        }
    }
}

impl Default for PrivEscScanner {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(target_os = "windows")]
impl PrivEscScanner {
    fn get_windows_system_info_windows(
        &self,
    ) -> Result<(String, String, String, String, Vec<String>), String> {
        let os_info_raw =
            Self::run_windows_command("wmic", &["os", "get", "Caption,Version", "/value"])
                .or_else(|_| Self::run_windows_command("cmd", &["/C", "ver"]))?;

        let mut caption = String::new();
        let mut version = String::new();

        for line in os_info_raw.lines() {
            let trimmed = line.trim();
            if let Some(value) = trimmed.strip_prefix("Caption=") {
                caption = value.trim().to_string();
            } else if let Some(value) = trimmed.strip_prefix("Version=") {
                version = value.trim().to_string();
            }
        }

        if caption.is_empty() {
            caption = "Windows".to_string();
        }
        if version.is_empty() {
            version = os_info_raw.trim().to_string();
        }

        let hostname = Self::run_windows_command("hostname", &[])?;
        let current_user = Self::run_windows_command("whoami", &[])?;
        let groups_output = Self::run_windows_command("whoami", &["/groups"]).unwrap_or_default();

        let mut groups = Vec::new();
        for line in groups_output.lines() {
            let trimmed = line.trim_end();
            if trimmed.is_empty()
                || trimmed.starts_with("GROUP INFORMATION")
                || trimmed.starts_with('-')
                || trimmed.starts_with('=')
                || trimmed.starts_with("Group Name")
            {
                continue;
            }

            if let Some((group_name, _rest)) = Self::split_first_column(trimmed) {
                if !group_name.is_empty() {
                    groups.push(group_name.to_string());
                }
            }
        }

        Ok((caption, version.clone(), version, hostname, groups))
    }

    fn check_unquoted_service_paths_windows(&self) -> Result<Vec<PrivEscVector>, String> {
        let raw = Self::run_windows_command(
            "wmic",
            &[
                "service",
                "get",
                "Name,DisplayName,PathName,StartMode",
                "/format:list",
            ],
        )?;

        let mut vectors = Vec::new();
        for service in Self::parse_wmic_service_blocks(&raw) {
            if service.path_name.trim().is_empty() {
                continue;
            }

            if Self::path_is_unquoted(&service.path_name) {
                let title = format!("Unquoted service path: {}", service.display_name);
                let description = format!(
                    "Service '{}' launches '{}' without quotes, allowing path traversal attacks.",
                    service.display_name, service.path_name
                );
                let exploit = format!(
                    "Create a directory such as '{}\\Program.exe' with a malicious binary. Restart the service or system to achieve execution.",
                    Self::extract_parent_directory(&service.path_name).unwrap_or_else(|| "C:\\".to_string())
                );
                vectors.push(PrivEscVector {
                    category: "Windows Service".to_string(),
                    severity: Severity::High,
                    title,
                    description,
                    exploit_technique: exploit,
                    references: vec![
                        "https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/unquoted-service-paths"
                            .to_string(),
                    ],
                });
            }
        }

        Ok(vectors)
    }

    fn check_weak_service_permissions_windows(&self) -> Result<Vec<PrivEscVector>, String> {
        let raw = Self::run_windows_command(
            "wmic",
            &[
                "service",
                "get",
                "Name,DisplayName,PathName",
                "/format:list",
            ],
        )?;

        let mut vectors = Vec::new();
        for service in Self::parse_wmic_service_blocks(&raw) {
            let binary_path = match Self::extract_service_binary(&service.path_name) {
                Some(path) => path,
                None => continue,
            };

            let acl = match Self::icacls_output(&binary_path) {
                Ok(output) => output,
                Err(_) => continue,
            };

            if let Some(principal) = Self::find_weak_acl(&acl) {
                vectors.push(PrivEscVector {
                    category: "Windows Service".to_string(),
                    severity: Severity::High,
                    title: format!(
                        "Weak permissions on service binary: {}",
                        service.display_name
                    ),
                    description: format!(
                        "Service '{}' binary '{}' grants '{}' excessive rights ({}).",
                        service.display_name, binary_path, principal.name, principal.rights
                    ),
                    exploit_technique: format!(
                        "Replace '{}' with a malicious binary. Restart the service to execute with elevated privileges.",
                        binary_path
                    ),
                    references: vec![
                        "https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/service-permissions"
                            .to_string(),
                    ],
                });
            }
        }

        Ok(vectors)
    }

    fn check_always_install_elevated_windows(&self) -> Result<Vec<PrivEscVector>, String> {
        let mut vectors = Vec::new();
        let hklm = Self::run_windows_command(
            "reg",
            &[
                "query",
                r"HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer",
                "/v",
                "AlwaysInstallElevated",
            ],
        )
        .unwrap_or_default();

        let hkcu = Self::run_windows_command(
            "reg",
            &[
                "query",
                r"HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer",
                "/v",
                "AlwaysInstallElevated",
            ],
        )
        .unwrap_or_default();

        let hklm_enabled = Self::registry_value_enabled(&hklm);
        let hkcu_enabled = Self::registry_value_enabled(&hkcu);

        if hklm_enabled && hkcu_enabled {
            vectors.push(PrivEscVector {
                category: "Windows Installer".to_string(),
                severity: Severity::High,
                title: "AlwaysInstallElevated enabled for current user".to_string(),
                description: "MSI packages run with SYSTEM privileges because both HKLM and HKCU keys are enabled.".to_string(),
                exploit_technique: "Generate a malicious MSI with msiexec and run it to escalate: msfvenom -p windows/x64/shell_reverse_tcp ...".to_string(),
                references: vec![
                    "https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/alwaysinstallelevated"
                        .to_string(),
                ],
            });
        }

        Ok(vectors)
    }

    fn check_stored_credentials_windows(&self) -> Result<Vec<PrivEscVector>, String> {
        let output = Self::run_windows_command("cmdkey", &["/list"]).unwrap_or_default();
        let mut vectors = Vec::new();

        for line in output.lines() {
            if let Some(target) = line.trim().strip_prefix("Target:") {
                let target = target.trim();
                if !target.is_empty() {
                    vectors.push(PrivEscVector {
                        category: "Stored Credentials".to_string(),
                        severity: Severity::Medium,
                        title: format!("Saved credential: {}", target),
                        description: format!(
                            "Credential manager holds secrets for '{}'. These can be abused via 'runas /savecred' or credential export.",
                            target
                        ),
                        exploit_technique: "Use 'runas /savecred /user:TARGET cmd.exe' or 'cmdkey /list' followed by Mimikatz sekurlsa::logonpasswords.".to_string(),
                        references: vec![
                            "https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/credentials-manager"
                                .to_string(),
                        ],
                    });
                }
            }
        }

        Ok(vectors)
    }

    fn check_token_privileges_windows(&self) -> Result<Vec<PrivEscVector>, String> {
        let output = Self::run_windows_command("whoami", &["/priv"]).unwrap_or_default();
        let mut vectors = Vec::new();
        let interesting = [
            (
                "SeImpersonatePrivilege",
                "PrintSpoofer / RoguePotato allow SYSTEM impersonation",
            ),
            (
                "SeAssignPrimaryTokenPrivilege",
                "Use RottenPotato / TokenMagic to assign tokens",
            ),
            (
                "SeBackupPrivilege",
                "Abuse with 'ntdsutil' or 'diskshadow' to dump SAM/NTDS",
            ),
            (
                "SeRestorePrivilege",
                "Overwrite protected files via 'robocopy' or 'reg restore'",
            ),
            (
                "SeTakeOwnershipPrivilege",
                "Take ownership of sensitive files and grant full control",
            ),
            (
                "SeLoadDriverPrivilege",
                "Load malicious drivers to escalate to kernel",
            ),
        ];

        for line in output.lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() || trimmed.starts_with("PRIVILEGES INFORMATION") {
                continue;
            }

            for (priv_name, technique) in &interesting {
                if trimmed.starts_with(priv_name) && trimmed.contains("Enabled") {
                    vectors.push(PrivEscVector {
                        category: "Token Privilege".to_string(),
                        severity: Severity::High,
                        title: format!("{} is enabled", priv_name),
                        description: format!(
                            "The current token has '{}' enabled allowing privilege escalation techniques.",
                            priv_name
                        ),
                        exploit_technique: technique.to_string(),
                        references: vec![
                            "https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/privilege-abuse"
                                .to_string(),
                        ],
                    });
                }
            }
        }

        Ok(vectors)
    }

    fn check_windows_kernel_exploits_windows(
        &self,
        os_version: &str,
    ) -> Result<Vec<PrivEscVector>, String> {
        let mut vectors = Vec::new();
        let mappings = [
            (
                "6.1",
                "Kernel pool overflow",
                "CVE-2014-4113",
                "Exploit via Chimichurri",
            ),
            (
                "6.1",
                "Win32k elevation",
                "CVE-2015-1701",
                "Exploit via TinderWin",
            ),
            (
                "6.1",
                "MS16-032",
                "CVE-2016-0099",
                "Secondary Logon Privilege escalation",
            ),
            ("6.1", "MS16-135", "CVE-2016-7255", "Win32k elevation leak"),
            (
                "6.3",
                "Win32k EhStorShell",
                "CVE-2015-1701",
                "Win32k privilege escalation",
            ),
            (
                "10.0.14393",
                "Windows 10 Kernel (2016)",
                "CVE-2016-7255",
                "Win32k privilege escalation",
            ),
            (
                "10.0.17134",
                "ALPC Task Scheduler",
                "CVE-2018-8440",
                "Task Scheduler ALPC exploit",
            ),
            (
                "10.0.17763",
                "SandboxEscaper",
                "CVE-2019-0841",
                "Acquire device driver privileges",
            ),
        ];

        for (pattern, name, cve, desc) in &mappings {
            if os_version.contains(pattern) {
                vectors.push(PrivEscVector {
                    category: "Kernel Exploit".to_string(),
                    severity: Severity::High,
                    title: format!("{} vulnerable ({}).", name, cve),
                    description: desc.to_string(),
                    exploit_technique: format!(
                        "Search for public exploit for {} (e.g. GitHub or exploit-db) and execute on target.",
                        cve
                    ),
                    references: vec![
                        format!("https://www.cvedetails.com/cve/{}/", cve),
                        "https://github.com/SecWiki/windows-kernel-exploits".to_string(),
                    ],
                });
            }
        }

        Ok(vectors)
    }

    fn check_scheduled_tasks_windows(&self) -> Result<Vec<PrivEscVector>, String> {
        let output = Self::run_windows_command("schtasks", &["/query", "/fo", "LIST", "/v"])?;

        let mut vectors = Vec::new();
        for task in Self::split_record_blocks(&output) {
            let mut name = String::new();
            let mut run_as = String::new();
            let mut run_command = String::new();

            for line in task.lines() {
                let trimmed = line.trim();
                if let Some(value) = trimmed.strip_prefix("TaskName:") {
                    name = value.trim().to_string();
                } else if let Some(value) = trimmed.strip_prefix("Run As User:") {
                    run_as = value.trim().to_string();
                } else if let Some(value) = trimmed.strip_prefix("Task To Run:") {
                    run_command = value.trim().to_string();
                }
            }

            if run_command.is_empty() {
                continue;
            }

            if run_as.eq_ignore_ascii_case("SYSTEM") && Self::path_is_unquoted(&run_command) {
                vectors.push(PrivEscVector {
                    category: "Scheduled Task".to_string(),
                    severity: Severity::High,
                    title: format!("Unquoted SYSTEM scheduled task: {}", name),
                    description: format!(
                        "Task '{}' runs as SYSTEM and launches '{}' without quotes.",
                        name, run_command
                    ),
                    exploit_technique: r"Plant a malicious executable in the path (e.g. C:\Windows\System32\tasks\malicious.exe) to hijack execution when the task triggers.".to_string(),
                    references: vec![
                        "https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/scheduled-tasks"
                            .to_string(),
                    ],
                });
            }
        }

        Ok(vectors)
    }

    fn check_dll_hijacking_windows(&self) -> Result<Vec<PrivEscVector>, String> {
        use std::path::Path;

        let path_env = match std::env::var("PATH") {
            Ok(value) => value,
            Err(_) => return Ok(Vec::new()),
        };

        let mut vectors = Vec::new();
        for entry in path_env.split(';') {
            let trimmed = entry.trim();
            if trimmed.is_empty() {
                continue;
            }

            let path = Path::new(trimmed);
            if !path.exists() {
                continue;
            }

            if let Ok(Some(principal)) = Self::directory_is_world_writable(path) {
                vectors.push(PrivEscVector {
                    category: "DLL Hijacking".to_string(),
                    severity: Severity::High,
                    title: format!("Writable directory in DLL search order: {}", path.display()),
                    description: format!(
                        "Directory '{}' grants '{}' write permissions ({}), enabling DLL planting attacks.",
                        path.display(), principal.name, principal.rights
                    ),
                    exploit_technique: format!(
                        "Drop a malicious DLL (e.g. version.dll) in '{}'. When privileged applications search the PATH, they will load your payload.",
                        path.display()
                    ),
                    references: vec![
                        "https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dll-hijacking"
                            .to_string(),
                    ],
                });
            }
        }

        Ok(vectors)
    }

    fn run_windows_command(program: &str, args: &[&str]) -> Result<String, String> {
        use std::process::Command;

        let output = Command::new(program)
            .args(args)
            .output()
            .map_err(|err| format!("Failed to run {}: {}", program, err))?;

        if !output.status.success() {
            return Err(format!("{} exited with status {}", program, output.status));
        }

        Ok(String::from_utf8_lossy(&output.stdout)
            .replace('\r', "")
            .trim()
            .to_string())
    }

    fn icacls_output(path: &str) -> Result<String, String> {
        use std::ffi::OsString;
        use std::process::Command;

        let mut cmd = Command::new("icacls");
        cmd.arg(OsString::from(path));
        let output = cmd
            .output()
            .map_err(|err| format!("Failed to run icacls: {}", err))?;

        if !output.status.success() {
            return Err(format!("icacls exited with status {}", output.status));
        }

        Ok(String::from_utf8_lossy(&output.stdout)
            .replace('\r', "")
            .to_lowercase())
    }

    fn find_weak_acl(acl_output: &str) -> Option<AclFinding> {
        let principals = ["everyone", "authenticated users", "users"];
        let dangerous = ["(f)", "(m)", "(w)", "(wd)", "(wa)"];

        for line in acl_output.lines() {
            let trimmed = line.trim();
            for principal in &principals {
                if trimmed.contains(principal) {
                    for right in &dangerous {
                        if trimmed.contains(right) {
                            return Some(AclFinding {
                                name: principal.to_string(),
                                rights: right.trim_matches(|c| c == '(' || c == ')').to_string(),
                            });
                        }
                    }
                }
            }
        }

        None
    }

    fn directory_is_world_writable(path: &std::path::Path) -> Result<Option<AclFinding>, String> {
        let canonical = path.canonicalize().unwrap_or_else(|_| path.to_path_buf());
        let acl = Self::icacls_output(&canonical.display().to_string())?;
        Ok(Self::find_weak_acl(&acl))
    }

    fn registry_value_enabled(output: &str) -> bool {
        for line in output.lines() {
            let trimmed = line.trim().to_ascii_lowercase();
            if trimmed.contains("alwaysinstallelevated")
                && (trimmed.contains("0x1") || trimmed.contains("0x00000001"))
            {
                return true;
            }
        }
        false
    }

    fn parse_wmic_service_blocks(raw: &str) -> Vec<ServiceInfo> {
        let mut services = Vec::new();
        for block in Self::split_record_blocks(raw) {
            let mut name = String::new();
            let mut display_name = String::new();
            let mut path_name = String::new();
            let mut start_mode = String::new();

            for line in block.lines() {
                let trimmed = line.trim();
                if let Some(value) = trimmed.strip_prefix("Name=") {
                    name = value.trim().to_string();
                } else if let Some(value) = trimmed.strip_prefix("DisplayName=") {
                    display_name = value.trim().to_string();
                } else if let Some(value) = trimmed.strip_prefix("PathName=") {
                    path_name = value.trim().to_string();
                } else if let Some(value) = trimmed.strip_prefix("StartMode=") {
                    start_mode = value.trim().to_string();
                }
            }

            if !name.is_empty() {
                services.push(ServiceInfo {
                    name,
                    display_name: if display_name.is_empty() {
                        "Unnamed Service".to_string()
                    } else {
                        display_name
                    },
                    path_name,
                    start_mode,
                });
            }
        }

        services
    }

    fn split_record_blocks(raw: &str) -> Vec<String> {
        raw.replace('\r', "")
            .split("\n\n")
            .map(|block| block.trim().to_string())
            .filter(|block| !block.is_empty())
            .collect()
    }

    fn path_is_unquoted(path: &str) -> bool {
        let trimmed = path.trim();
        if trimmed.starts_with('"') {
            return !trimmed[1..].contains('"');
        }
        trimmed.contains(' ')
    }

    fn extract_service_binary(path: &str) -> Option<String> {
        let trimmed = path.trim();
        if trimmed.is_empty() {
            return None;
        }

        if trimmed.starts_with('"') {
            if let Some(end) = trimmed[1..].find('"') {
                return Some(trimmed[1..1 + end].to_string());
            }
            return None;
        }

        trimmed.split_whitespace().next().map(|s| s.to_string())
    }

    fn extract_parent_directory(path: &str) -> Option<String> {
        use std::path::Path;

        let binary = Self::extract_service_binary(path)?;
        let parent = Path::new(&binary).parent()?;
        Some(parent.display().to_string())
    }

    fn split_first_column(line: &str) -> Option<(&str, &str)> {
        let mut parts = line.splitn(2, "  ");
        let first = parts.next()?.trim_end();
        let rest = parts.next().unwrap_or("");
        Some((first.trim(), rest))
    }
}

#[cfg(target_os = "windows")]
struct ServiceInfo {
    name: String,
    display_name: String,
    path_name: String,
    start_mode: String,
}

#[cfg(target_os = "windows")]
struct AclFinding {
    name: String,
    rights: String,
}

#[cfg(target_os = "linux")]
enum PathWritable {
    NotWritable,
    UserWritable,
    WorldWritable,
    StickyWorldWritable,
}

#[cfg(target_os = "linux")]
impl PrivEscScanner {
    fn current_user_ids(&self) -> Result<(u32, u32), String> {
        use std::fs;

        let status = fs::read_to_string("/proc/self/status")
            .map_err(|err| format!("Failed to read /proc/self/status: {}", err))?;

        let mut uid = None;
        let mut gid = None;

        for line in status.lines() {
            if line.starts_with("Uid:") {
                uid = line
                    .split_whitespace()
                    .nth(1)
                    .and_then(|v| v.parse::<u32>().ok());
            }
            if line.starts_with("Gid:") {
                gid = line
                    .split_whitespace()
                    .nth(1)
                    .and_then(|v| v.parse::<u32>().ok());
            }
            if uid.is_some() && gid.is_some() {
                break;
            }
        }

        match (uid, gid) {
            (Some(uid), Some(gid)) => Ok((uid, gid)),
            _ => Err("Unable to determine current UID/GID".to_string()),
        }
    }

    fn is_path_writable_by_user(
        &self,
        path: &std::path::Path,
        uid: u32,
        gid: u32,
    ) -> Result<bool, String> {
        use std::fs;
        use std::os::unix::fs::MetadataExt;
        use std::os::unix::fs::PermissionsExt;

        let metadata = fs::metadata(path)
            .map_err(|err| format!("Failed to read metadata for {}: {}", path.display(), err))?;
        let mode = metadata.permissions().mode();

        if metadata.uid() == uid && (mode & 0o200 != 0) {
            return Ok(true);
        }
        if metadata.gid() == gid && (mode & 0o020 != 0) {
            return Ok(true);
        }

        Ok(mode & 0o002 != 0)
    }

    fn path_writable_classification(
        &self,
        path: &std::path::Path,
        uid: u32,
        gid: u32,
    ) -> Result<PathWritable, String> {
        use std::fs;
        use std::os::unix::fs::MetadataExt;
        use std::os::unix::fs::PermissionsExt;

        let metadata = fs::metadata(path)
            .map_err(|err| format!("Failed to read metadata for {}: {}", path.display(), err))?;
        let mode = metadata.permissions().mode();

        if metadata.uid() == uid && (mode & 0o200 != 0) {
            return Ok(PathWritable::UserWritable);
        }
        if metadata.gid() == gid && (mode & 0o020 != 0) {
            return Ok(PathWritable::UserWritable);
        }

        let sticky = mode & 0o1000 != 0;

        if mode & 0o002 != 0 {
            return Ok(if sticky {
                PathWritable::StickyWorldWritable
            } else {
                PathWritable::WorldWritable
            });
        }

        Ok(PathWritable::NotWritable)
    }

    fn extract_cron_targets(contents: &str) -> Vec<std::path::PathBuf> {
        use std::path::PathBuf;

        let mut targets = Vec::new();

        for line in contents.lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() || trimmed.starts_with('#') {
                continue;
            }

            let mut parts = trimmed.split_whitespace();
            let command_parts: Vec<&str> = if trimmed.starts_with('@') {
                parts.next();
                parts.collect()
            } else {
                for _ in 0..5 {
                    parts.next();
                }
                parts.collect()
            };

            for token in command_parts {
                if !token.starts_with('/') {
                    continue;
                }
                let cleaned = token.trim_matches(|c: char| c == ';' || c == ',' || c == '"');
                if cleaned.is_empty() {
                    continue;
                }
                let path = PathBuf::from(cleaned);
                if path.exists() {
                    targets.push(path);
                }
            }
        }

        targets
    }

    fn build_path_hijack_vector(
        path: &std::path::Path,
        title: &str,
        severity: Severity,
    ) -> PrivEscVector {
        PrivEscVector {
            category: "PATH Hijacking".to_string(),
            severity,
            title: format!("{} ({})", title, path.display()),
            description: format!(
                "The PATH entry '{}' is writable. An attacker can plant a malicious binary that will be resolved before trusted binaries.",
                path.display()
            ),
            exploit_technique: format!(
                "Place a trojan binary inside '{}' with the same name as a commonly used command (e.g. 'sudo'); when privileged scripts rely on PATH lookup, your payload executes.",
                path.display()
            ),
            references: vec![
                "https://book.hacktricks.xyz/linux-hardening/privilege-escalation#path-abuse".to_string(),
            ],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_os_detection() {
        let scanner = PrivEscScanner::new();
        #[cfg(target_os = "linux")]
        assert_eq!(scanner.os_type, OsType::Linux);

        #[cfg(target_os = "windows")]
        assert_eq!(scanner.os_type, OsType::Windows);
    }

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::Critical > Severity::High);
        assert!(Severity::High > Severity::Medium);
        assert!(Severity::Medium > Severity::Low);
    }
}
