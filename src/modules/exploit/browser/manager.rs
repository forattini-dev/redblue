//! RBB (RedBlue Browser) Manager
//!
//! Thread-safe state management for hooked browser sessions.
//! Enables IPC between the server and TUI dashboard.

use std::collections::{HashMap, VecDeque};
use std::sync::{Arc, RwLock};
use std::time::{SystemTime, UNIX_EPOCH};

use crate::modules::exploit::browser::command::{BrowserCommand, CommandResult};
use crate::modules::exploit::browser::session::{Zombie, ZombieStatus};

/// Session identifier type alias
pub type SessionId = String;

/// Browser state with command queue and response history
#[derive(Debug, Clone)]
pub struct BrowserState {
    /// Basic zombie info
    pub zombie: Zombie,
    /// Pending commands to be executed
    pub command_queue: VecDeque<BrowserCommand>,
    /// History of command results
    pub response_history: Vec<CommandResult>,
    /// Capabilities reported by the browser
    pub capabilities: BrowserCapabilities,
}

/// Browser capabilities detected during registration
#[derive(Debug, Clone, Default)]
pub struct BrowserCapabilities {
    pub has_websocket: bool,
    pub has_localstorage: bool,
    pub has_geolocation: bool,
    pub has_webrtc: bool,
    pub cookies_enabled: bool,
    pub screen_width: u32,
    pub screen_height: u32,
}

impl BrowserState {
    pub fn new(zombie: Zombie) -> Self {
        Self {
            zombie,
            command_queue: VecDeque::new(),
            response_history: Vec::new(),
            capabilities: BrowserCapabilities::default(),
        }
    }

    /// Queue a command for this browser
    pub fn queue_command(&mut self, cmd: BrowserCommand) {
        self.command_queue.push_back(cmd);
    }

    /// Pop the next command from the queue
    pub fn pop_command(&mut self) -> Option<BrowserCommand> {
        self.command_queue.pop_front()
    }

    /// Pop all pending commands
    pub fn drain_commands(&mut self) -> Vec<BrowserCommand> {
        self.command_queue.drain(..).collect()
    }

    /// Record a command result
    pub fn record_result(&mut self, result: CommandResult) {
        self.response_history.push(result);
    }

    /// Update heartbeat timestamp
    pub fn heartbeat(&mut self) {
        self.zombie.heartbeat();
    }

    /// Check if session is stale (no heartbeat within timeout)
    pub fn is_stale(&self, timeout_secs: u64) -> bool {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|d| d.as_secs())
            .unwrap_or(0);
        now.saturating_sub(self.zombie.last_seen) > timeout_secs
    }
}

/// Thread-safe manager for all hooked browser sessions
#[derive(Clone)]
pub struct RbbManager {
    /// Map of session ID to browser state
    sessions: Arc<RwLock<HashMap<SessionId, BrowserState>>>,
    /// Heartbeat timeout in seconds
    heartbeat_timeout: u64,
}

impl Default for RbbManager {
    fn default() -> Self {
        Self::new()
    }
}

impl RbbManager {
    /// Create a new RBB manager with default 30s timeout
    pub fn new() -> Self {
        Self {
            sessions: Arc::new(RwLock::new(HashMap::new())),
            heartbeat_timeout: 30,
        }
    }

    /// Create with custom heartbeat timeout
    pub fn with_timeout(timeout_secs: u64) -> Self {
        Self {
            sessions: Arc::new(RwLock::new(HashMap::new())),
            heartbeat_timeout: timeout_secs,
        }
    }

    /// Register a new browser session
    pub fn register(&self, zombie: Zombie) -> SessionId {
        let session_id = zombie.id.clone();
        let state = BrowserState::new(zombie);

        let mut sessions = self.sessions.write().unwrap();
        sessions.insert(session_id.clone(), state);

        session_id
    }

    /// Update an existing session or create new one
    pub fn upsert(&self, zombie: Zombie) {
        let session_id = zombie.id.clone();
        let mut sessions = self.sessions.write().unwrap();

        if let Some(state) = sessions.get_mut(&session_id) {
            // Update existing
            state.zombie.last_seen = zombie.last_seen;
            state.zombie.page = zombie.page;
            state.zombie.hostname = zombie.hostname;
            state.zombie.status = ZombieStatus::Online;
        } else {
            // Create new
            sessions.insert(session_id, BrowserState::new(zombie));
        }
    }

    /// Get a session by ID
    pub fn get(&self, session_id: &str) -> Option<BrowserState> {
        let sessions = self.sessions.read().unwrap();
        sessions.get(session_id).cloned()
    }

    /// Update heartbeat for a session
    pub fn heartbeat(&self, session_id: &str) {
        let mut sessions = self.sessions.write().unwrap();
        if let Some(state) = sessions.get_mut(session_id) {
            state.heartbeat();
        }
    }

    /// Queue a command for a specific session
    pub fn queue_command(&self, session_id: &str, cmd: BrowserCommand) -> bool {
        let mut sessions = self.sessions.write().unwrap();
        if let Some(state) = sessions.get_mut(session_id) {
            state.queue_command(cmd);
            true
        } else {
            false
        }
    }

    /// Queue a command for all online sessions
    pub fn broadcast_command(&self, cmd: BrowserCommand) -> usize {
        let mut sessions = self.sessions.write().unwrap();
        let mut count = 0;
        for (_, state) in sessions.iter_mut() {
            if state.zombie.status == ZombieStatus::Online {
                state.queue_command(cmd.clone());
                count += 1;
            }
        }
        count
    }

    /// Pop pending commands for a session (called by poll endpoint)
    pub fn drain_commands(&self, session_id: &str) -> Vec<BrowserCommand> {
        let mut sessions = self.sessions.write().unwrap();
        if let Some(state) = sessions.get_mut(session_id) {
            state.heartbeat();
            state.drain_commands()
        } else {
            vec![]
        }
    }

    /// Record a command result
    pub fn record_result(&self, session_id: &str, result: CommandResult) {
        let mut sessions = self.sessions.write().unwrap();
        if let Some(state) = sessions.get_mut(session_id) {
            state.record_result(result);
        }
    }

    /// Get all zombies (for TUI display)
    pub fn list_zombies(&self) -> Vec<Zombie> {
        let sessions = self.sessions.read().unwrap();
        sessions.values().map(|s| s.zombie.clone()).collect()
    }

    /// Get all online zombies
    pub fn list_online(&self) -> Vec<Zombie> {
        let sessions = self.sessions.read().unwrap();
        sessions
            .values()
            .filter(|s| s.zombie.status == ZombieStatus::Online)
            .map(|s| s.zombie.clone())
            .collect()
    }

    /// Get session count
    pub fn session_count(&self) -> usize {
        self.sessions.read().unwrap().len()
    }

    /// Get online session count
    pub fn online_count(&self) -> usize {
        let sessions = self.sessions.read().unwrap();
        sessions
            .values()
            .filter(|s| s.zombie.status == ZombieStatus::Online)
            .count()
    }

    /// Clean up stale sessions (mark as offline or remove)
    pub fn cleanup_stale(&self) {
        let mut sessions = self.sessions.write().unwrap();
        for (_, state) in sessions.iter_mut() {
            if state.is_stale(self.heartbeat_timeout) {
                state.zombie.status = ZombieStatus::Offline;
            }
        }
    }

    /// Remove a session
    pub fn remove(&self, session_id: &str) -> Option<BrowserState> {
        let mut sessions = self.sessions.write().unwrap();
        sessions.remove(session_id)
    }

    /// Remove all offline sessions
    pub fn prune_offline(&self) -> usize {
        let mut sessions = self.sessions.write().unwrap();
        let before = sessions.len();
        sessions.retain(|_, state| state.zombie.status != ZombieStatus::Offline);
        before - sessions.len()
    }

    /// Get response history for a session
    pub fn get_history(&self, session_id: &str) -> Vec<CommandResult> {
        let sessions = self.sessions.read().unwrap();
        sessions
            .get(session_id)
            .map(|s| s.response_history.clone())
            .unwrap_or_default()
    }

    /// Get last N results across all sessions
    pub fn recent_results(&self, limit: usize) -> Vec<(SessionId, CommandResult)> {
        let sessions = self.sessions.read().unwrap();
        let mut results: Vec<(SessionId, CommandResult)> = sessions
            .iter()
            .flat_map(|(id, state)| {
                state
                    .response_history
                    .iter()
                    .map(|r| (id.clone(), r.clone()))
            })
            .collect();

        // Take last N
        if results.len() > limit {
            results.split_off(results.len() - limit)
        } else {
            results
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_register_and_get() {
        let manager = RbbManager::new();
        let zombie = Zombie::new("test-123".to_string(), "192.168.1.1".to_string());

        let session_id = manager.register(zombie);
        assert_eq!(session_id, "test-123");

        let state = manager.get("test-123").unwrap();
        assert_eq!(state.zombie.ip, "192.168.1.1");
    }

    #[test]
    fn test_command_queue() {
        let manager = RbbManager::new();
        let zombie = Zombie::new("z1".to_string(), "10.0.0.1".to_string());
        manager.register(zombie);

        let cmd = BrowserCommand::alert("Hello!");
        assert!(manager.queue_command("z1", cmd));

        let commands = manager.drain_commands("z1");
        assert_eq!(commands.len(), 1);
        assert_eq!(commands[0].name, "alert");

        // Queue should be empty now
        let commands = manager.drain_commands("z1");
        assert!(commands.is_empty());
    }

    #[test]
    fn test_broadcast() {
        let manager = RbbManager::new();

        manager.register(Zombie::new("z1".to_string(), "10.0.0.1".to_string()));
        manager.register(Zombie::new("z2".to_string(), "10.0.0.2".to_string()));

        let cmd = BrowserCommand::eval("console.log('test');");
        let count = manager.broadcast_command(cmd);
        assert_eq!(count, 2);

        assert_eq!(manager.drain_commands("z1").len(), 1);
        assert_eq!(manager.drain_commands("z2").len(), 1);
    }

    #[test]
    fn test_stale_detection() {
        let manager = RbbManager::with_timeout(1); // 1 second timeout
        let mut zombie = Zombie::new("stale".to_string(), "1.1.1.1".to_string());
        zombie.last_seen = 0; // Very old timestamp

        manager.register(zombie);
        manager.cleanup_stale();

        let state = manager.get("stale").unwrap();
        assert_eq!(state.zombie.status, ZombieStatus::Offline);
    }
}
