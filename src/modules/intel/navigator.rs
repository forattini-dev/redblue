//! MITRE ATT&CK Navigator Layer Export
//!
//! Generates Navigator-compatible JSON layers (v4.4 format) from technique mappings.
//!
//! The ATT&CK Navigator is a web-based tool for visualizing ATT&CK matrices.
//! See: https://mitre-attack.github.io/attack-navigator/
//!
//! ## Layer Format v4.4
//!
//! The layer format supports:
//! - Technique highlighting with scores (0-100)
//! - Custom colors and comments per technique
//! - Filtering by platforms and tactics
//! - Gradient-based coloring
//!
//! ## Example Usage
//!
//! ```rust,ignore
//! use redblue::modules::intel::navigator::{NavigatorLayer, TechniqueAnnotation};
//!
//! let mut layer = NavigatorLayer::new("example.com Findings", "Generated by redblue");
//!
//! layer.add_technique(TechniqueAnnotation {
//!     technique_id: "T1021.004".to_string(),
//!     tactic: Some("lateral-movement".to_string()),
//!     score: Some(75),
//!     color: None,
//!     comment: Some("SSH found on port 22".to_string()),
//!     enabled: true,
//! });
//!
//! let json = layer.to_json()?;
//! ```

use std::collections::HashMap;

use super::mapper::{MappedTechnique, MappingResult, Confidence};

/// Navigator layer (v4.4 format)
#[derive(Debug)]
pub struct NavigatorLayer {
    /// Layer name (displayed in Navigator)
    pub name: String,
    /// Layer description
    pub description: String,
    /// ATT&CK Navigator layer version
    pub version: &'static str,
    /// ATT&CK domain (enterprise-attack, mobile-attack, ics-attack)
    pub domain: String,
    /// Techniques in this layer
    pub techniques: Vec<TechniqueAnnotation>,
    /// Gradient configuration
    pub gradient: GradientConfig,
    /// Legend items
    pub legend_items: Vec<LegendItem>,
    /// Show technique sub-techniques
    pub show_subtechniques: bool,
    /// Filters applied to the layer
    pub filters: LayerFilters,
    /// Metadata about the layer
    pub metadata: Vec<MetadataItem>,
}

/// Technique annotation in the layer
#[derive(Debug, Clone)]
pub struct TechniqueAnnotation {
    /// Technique ID (e.g., "T1021.004")
    pub technique_id: String,
    /// Tactic name (e.g., "lateral-movement") - None for all tactics
    pub tactic: Option<String>,
    /// Score (0-100), maps to gradient color
    pub score: Option<u8>,
    /// Custom color override (hex, e.g., "#ff0000")
    pub color: Option<String>,
    /// Comment/note
    pub comment: Option<String>,
    /// Whether the technique is enabled (visible)
    pub enabled: bool,
    /// Links to external resources
    pub links: Vec<TechniqueLink>,
}

/// Link associated with a technique
#[derive(Debug, Clone)]
pub struct TechniqueLink {
    pub label: String,
    pub url: String,
}

/// Gradient configuration for score-based coloring
#[derive(Debug, Clone)]
pub struct GradientConfig {
    /// Color at score 0
    pub min_color: String,
    /// Color at max score
    pub max_color: String,
    /// Minimum score value
    pub min_value: u8,
    /// Maximum score value
    pub max_value: u8,
}

impl Default for GradientConfig {
    fn default() -> Self {
        Self {
            min_color: "#ffffff".to_string(), // White
            max_color: "#ff0000".to_string(), // Red
            min_value: 0,
            max_value: 100,
        }
    }
}

/// Legend item
#[derive(Debug, Clone)]
pub struct LegendItem {
    pub label: String,
    pub color: String,
}

/// Layer filters
#[derive(Debug, Clone, Default)]
pub struct LayerFilters {
    /// Platforms to include (empty = all)
    pub platforms: Vec<String>,
    /// Tactics to include (empty = all)
    pub tactics: Vec<String>,
}

/// Metadata item
#[derive(Debug, Clone)]
pub struct MetadataItem {
    pub name: String,
    pub value: String,
}

impl Default for NavigatorLayer {
    fn default() -> Self {
        Self::new("redblue Layer", "Generated by redblue")
    }
}

impl NavigatorLayer {
    /// Create a new Navigator layer
    pub fn new(name: &str, description: &str) -> Self {
        Self {
            name: name.to_string(),
            description: description.to_string(),
            version: "4.4",
            domain: "enterprise-attack".to_string(),
            techniques: Vec::new(),
            gradient: GradientConfig::default(),
            legend_items: vec![
                LegendItem { label: "High Confidence".to_string(), color: "#ff0000".to_string() },
                LegendItem { label: "Medium Confidence".to_string(), color: "#ff9900".to_string() },
                LegendItem { label: "Low Confidence".to_string(), color: "#ffff00".to_string() },
            ],
            show_subtechniques: true,
            filters: LayerFilters::default(),
            metadata: vec![
                MetadataItem {
                    name: "generator".to_string(),
                    value: "redblue".to_string(),
                },
            ],
        }
    }

    /// Add a technique annotation
    pub fn add_technique(&mut self, annotation: TechniqueAnnotation) {
        self.techniques.push(annotation);
    }

    /// Create a layer from mapping results
    pub fn from_mapping_result(result: &MappingResult, name: &str, target: &str) -> Self {
        let mut layer = Self::new(
            name,
            &format!("ATT&CK techniques mapped from findings on {}", target),
        );

        // Add metadata
        layer.metadata.push(MetadataItem {
            name: "target".to_string(),
            value: target.to_string(),
        });
        layer.metadata.push(MetadataItem {
            name: "technique_count".to_string(),
            value: result.techniques.len().to_string(),
        });

        // Group techniques by ID to aggregate scores
        let mut technique_scores: HashMap<String, (u8, Vec<String>)> = HashMap::new();

        for tech in &result.techniques {
            let score = tech.confidence.score();
            let comment = format!("{} ({})", tech.reason, tech.original_value);

            technique_scores
                .entry(tech.technique_id.clone())
                .and_modify(|(s, comments)| {
                    // Keep highest score
                    if score > *s {
                        *s = score;
                    }
                    comments.push(comment.clone());
                })
                .or_insert((score, vec![comment]));
        }

        // Convert to annotations
        for (technique_id, (score, comments)) in technique_scores {
            // Find the tactic for this technique
            let tactic = result.techniques
                .iter()
                .find(|t| t.technique_id == technique_id)
                .map(|t| tactic_to_slug(&t.tactic));

            layer.add_technique(TechniqueAnnotation {
                technique_id,
                tactic,
                score: Some(score),
                color: None,
                comment: Some(comments.join("; ")),
                enabled: true,
                links: Vec::new(),
            });
        }

        layer
    }

    /// Export to JSON string
    pub fn to_json(&self) -> String {
        let mut json = String::new();
        json.push_str("{\n");

        // Basic fields
        json.push_str(&format!("  \"name\": \"{}\",\n", escape_json(&self.name)));
        json.push_str(&format!("  \"versions\": {{\n"));
        json.push_str(&format!("    \"attack\": \"14\",\n"));
        json.push_str(&format!("    \"navigator\": \"4.9.1\",\n"));
        json.push_str(&format!("    \"layer\": \"{}\"\n", self.version));
        json.push_str("  },\n");
        json.push_str(&format!("  \"domain\": \"{}\",\n", self.domain));
        json.push_str(&format!("  \"description\": \"{}\",\n", escape_json(&self.description)));

        // Filters
        json.push_str("  \"filters\": {\n");
        json.push_str("    \"platforms\": [\n");
        if self.filters.platforms.is_empty() {
            // Default platforms for enterprise-attack
            json.push_str("      \"Linux\", \"macOS\", \"Windows\", \"Network\",\n");
            json.push_str("      \"PRE\", \"Containers\", \"Office 365\", \"SaaS\",\n");
            json.push_str("      \"Google Workspace\", \"IaaS\", \"Azure AD\"\n");
        } else {
            let platforms: Vec<String> = self.filters.platforms.iter()
                .map(|p| format!("      \"{}\"", p))
                .collect();
            json.push_str(&platforms.join(",\n"));
            json.push('\n');
        }
        json.push_str("    ]\n");
        json.push_str("  },\n");

        // Sorting
        json.push_str("  \"sorting\": 0,\n");

        // Layout
        json.push_str("  \"layout\": {\n");
        json.push_str("    \"layout\": \"side\",\n");
        json.push_str("    \"aggregateFunction\": \"average\",\n");
        json.push_str("    \"showID\": false,\n");
        json.push_str("    \"showName\": true,\n");
        json.push_str("    \"showAggregateScores\": false,\n");
        json.push_str("    \"countUnscored\": false,\n");
        json.push_str("    \"expandedSubtechniques\": \"none\"\n");
        json.push_str("  },\n");

        // Hide disabled
        json.push_str("  \"hideDisabled\": false,\n");

        // Techniques
        json.push_str("  \"techniques\": [\n");
        let tech_strings: Vec<String> = self.techniques.iter().map(|t| {
            let mut tech_json = String::new();
            tech_json.push_str("    {\n");
            tech_json.push_str(&format!("      \"techniqueID\": \"{}\",\n", t.technique_id));

            if let Some(ref tactic) = t.tactic {
                tech_json.push_str(&format!("      \"tactic\": \"{}\",\n", tactic));
            }

            if let Some(score) = t.score {
                tech_json.push_str(&format!("      \"score\": {},\n", score));
            }

            if let Some(ref color) = t.color {
                tech_json.push_str(&format!("      \"color\": \"{}\",\n", color));
            }

            if let Some(ref comment) = t.comment {
                tech_json.push_str(&format!("      \"comment\": \"{}\",\n", escape_json(comment)));
            }

            tech_json.push_str(&format!("      \"enabled\": {}\n", t.enabled));
            tech_json.push_str("    }");
            tech_json
        }).collect();
        json.push_str(&tech_strings.join(",\n"));
        json.push_str("\n  ],\n");

        // Gradient
        json.push_str("  \"gradient\": {\n");
        json.push_str(&format!("    \"colors\": [\"{}\", \"{}\"],\n",
            self.gradient.min_color, self.gradient.max_color));
        json.push_str(&format!("    \"minValue\": {},\n", self.gradient.min_value));
        json.push_str(&format!("    \"maxValue\": {}\n", self.gradient.max_value));
        json.push_str("  },\n");

        // Legend items
        json.push_str("  \"legendItems\": [\n");
        let legend_strings: Vec<String> = self.legend_items.iter().map(|l| {
            format!("    {{ \"label\": \"{}\", \"color\": \"{}\" }}",
                escape_json(&l.label), l.color)
        }).collect();
        json.push_str(&legend_strings.join(",\n"));
        json.push_str("\n  ],\n");

        // Metadata
        json.push_str("  \"metadata\": [\n");
        let meta_strings: Vec<String> = self.metadata.iter().map(|m| {
            format!("    {{ \"name\": \"{}\", \"value\": \"{}\" }}",
                escape_json(&m.name), escape_json(&m.value))
        }).collect();
        json.push_str(&meta_strings.join(",\n"));
        json.push_str("\n  ],\n");

        // Show/hide options
        json.push_str("  \"showTacticRowBackground\": false,\n");
        json.push_str("  \"tacticRowBackground\": \"#dddddd\",\n");
        json.push_str("  \"selectTechniquesAcrossTactics\": true,\n");
        json.push_str("  \"selectSubtechniquesWithParent\": false\n");

        json.push_str("}\n");
        json
    }

    /// Export to a file
    pub fn to_file(&self, path: &str) -> Result<(), String> {
        let json = self.to_json();
        std::fs::write(path, json)
            .map_err(|e| format!("Failed to write layer file: {}", e))
    }
}

/// Convert tactic name to URL slug format
fn tactic_to_slug(tactic: &str) -> String {
    tactic.to_lowercase().replace(' ', "-")
}

/// Escape JSON special characters
fn escape_json(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

/// Create a layer from mapped techniques
pub fn create_layer_from_techniques(
    techniques: &[MappedTechnique],
    name: &str,
    target: &str,
) -> NavigatorLayer {
    let mut layer = NavigatorLayer::new(name, &format!("Findings from {}", target));

    // Add metadata
    layer.metadata.push(MetadataItem {
        name: "target".to_string(),
        value: target.to_string(),
    });

    // Group by technique ID
    let mut grouped: HashMap<String, Vec<&MappedTechnique>> = HashMap::new();
    for tech in techniques {
        grouped.entry(tech.technique_id.clone()).or_default().push(tech);
    }

    for (technique_id, techs) in grouped {
        // Calculate aggregate score (max confidence)
        let max_confidence = techs.iter()
            .map(|t| t.confidence.score())
            .max()
            .unwrap_or(0);

        // Combine comments
        let comments: Vec<String> = techs.iter()
            .map(|t| format!("{} ({})", t.reason, t.original_value))
            .collect();

        // Get tactic from first match
        let tactic = techs.first().map(|t| tactic_to_slug(&t.tactic));

        layer.add_technique(TechniqueAnnotation {
            technique_id,
            tactic,
            score: Some(max_confidence),
            color: None,
            comment: Some(comments.join("; ")),
            enabled: true,
            links: Vec::new(),
        });
    }

    layer
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_layer() {
        let layer = NavigatorLayer::new("Test Layer", "Test description");
        assert_eq!(layer.name, "Test Layer");
        assert_eq!(layer.description, "Test description");
        assert_eq!(layer.domain, "enterprise-attack");
    }

    #[test]
    fn test_add_technique() {
        let mut layer = NavigatorLayer::new("Test", "Test");
        layer.add_technique(TechniqueAnnotation {
            technique_id: "T1021.004".to_string(),
            tactic: Some("lateral-movement".to_string()),
            score: Some(75),
            color: None,
            comment: Some("SSH access".to_string()),
            enabled: true,
            links: Vec::new(),
        });

        assert_eq!(layer.techniques.len(), 1);
        assert_eq!(layer.techniques[0].technique_id, "T1021.004");
    }

    #[test]
    fn test_to_json() {
        let mut layer = NavigatorLayer::new("Test Layer", "Test description");
        layer.add_technique(TechniqueAnnotation {
            technique_id: "T1021.004".to_string(),
            tactic: Some("lateral-movement".to_string()),
            score: Some(75),
            color: None,
            comment: Some("SSH found".to_string()),
            enabled: true,
            links: Vec::new(),
        });

        let json = layer.to_json();

        assert!(json.contains("\"name\": \"Test Layer\""));
        assert!(json.contains("\"techniqueID\": \"T1021.004\""));
        assert!(json.contains("\"score\": 75"));
        assert!(json.contains("\"tactic\": \"lateral-movement\""));
    }

    #[test]
    fn test_escape_json() {
        assert_eq!(escape_json("hello"), "hello");
        assert_eq!(escape_json("hello\"world"), "hello\\\"world");
        assert_eq!(escape_json("line1\nline2"), "line1\\nline2");
    }

    #[test]
    fn test_tactic_to_slug() {
        assert_eq!(tactic_to_slug("Lateral Movement"), "lateral-movement");
        assert_eq!(tactic_to_slug("Initial Access"), "initial-access");
        assert_eq!(tactic_to_slug("Command and Control"), "command-and-control");
    }

    #[test]
    fn test_create_layer_from_techniques() {
        let techniques = vec![
            MappedTechnique {
                technique_id: "T1021.004".to_string(),
                name: "Remote Services: SSH".to_string(),
                reason: "SSH enables lateral movement".to_string(),
                tactic: "Lateral Movement".to_string(),
                confidence: Confidence::High,
                source: super::super::mapper::MappingSource::Port,
                original_value: "port/22".to_string(),
            },
        ];

        let layer = create_layer_from_techniques(&techniques, "Test", "example.com");

        assert_eq!(layer.techniques.len(), 1);
        assert_eq!(layer.techniques[0].score, Some(100)); // High confidence = 100
    }
}
