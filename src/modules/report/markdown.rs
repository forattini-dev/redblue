//! Markdown Export for reports
//!
//! Generates GitHub-compatible markdown for documentation and issues.

use super::{Report, Severity};

pub struct MarkdownExporter;

impl MarkdownExporter {
    /// Export report to Markdown string
    pub fn export(report: &Report) -> String {
        let mut md = String::with_capacity(16384);

        // Title
        md.push_str(&format!("# {}\n\n", report.title));

        // Metadata
        md.push_str(&format!("**Target:** `{}`  \n", report.target));
        md.push_str(&format!("**Scan Date:** {}  \n\n", report.scan_date));

        // Executive Summary
        if !report.executive_summary.is_empty() {
            md.push_str("## Executive Summary\n\n");
            md.push_str(&report.executive_summary);
            md.push_str("\n\n");
        }

        // Summary Table
        let counts = report.severity_counts();
        md.push_str("## Summary\n\n");
        md.push_str("| Severity | Count |\n");
        md.push_str("|----------|-------|\n");
        md.push_str(&format!("| Critical | {} |\n", counts.get(&Severity::Critical).unwrap_or(&0)));
        md.push_str(&format!("| High | {} |\n", counts.get(&Severity::High).unwrap_or(&0)));
        md.push_str(&format!("| Medium | {} |\n", counts.get(&Severity::Medium).unwrap_or(&0)));
        md.push_str(&format!("| Low | {} |\n", counts.get(&Severity::Low).unwrap_or(&0)));
        md.push_str(&format!("| Info | {} |\n", counts.get(&Severity::Info).unwrap_or(&0)));
        md.push_str(&format!("| **Total** | **{}** |\n\n", report.findings.len()));

        // Hosts
        if !report.hosts.is_empty() {
            md.push_str("## Discovered Hosts\n\n");
            md.push_str("| Hostname | IP | Open Ports | Technologies |\n");
            md.push_str("|----------|----|-----------|--------------|\n");

            for host in &report.hosts {
                let ports_str = host.ports.iter()
                    .map(|p| format!("{}/{}", p.port, p.service))
                    .collect::<Vec<_>>()
                    .join(", ");

                md.push_str(&format!("| {} | {} | {} | {} |\n",
                    Self::escape_md(&host.hostname),
                    host.ip.as_deref().unwrap_or("-"),
                    Self::escape_md(&ports_str),
                    Self::escape_md(&host.technologies.join(", "))));
            }
            md.push('\n');
        }

        // Findings
        md.push_str("## Security Findings\n\n");

        // Sort findings by severity (critical first)
        let mut sorted_findings = report.findings.clone();
        sorted_findings.sort_by(|a, b| b.severity.cmp(&a.severity));

        for finding in &sorted_findings {
            let severity_badge = Self::severity_badge(&finding.severity);

            md.push_str(&format!("### {} {}\n\n", severity_badge, Self::escape_md(&finding.title)));

            if !finding.description.is_empty() {
                md.push_str(&finding.description);
                md.push_str("\n\n");
            }

            if let Some(ref evidence) = finding.evidence {
                md.push_str("**Evidence:**\n\n");
                md.push_str("```\n");
                md.push_str(evidence);
                md.push_str("\n```\n\n");
            }

            if let Some(ref remediation) = finding.remediation {
                md.push_str("**Remediation:**\n\n");
                md.push_str(remediation);
                md.push_str("\n\n");
            }

            if !finding.references.is_empty() {
                md.push_str("**References:**\n\n");
                for reference in &finding.references {
                    md.push_str(&format!("- {}\n", reference));
                }
                md.push('\n');
            }

            if !finding.tags.is_empty() {
                md.push_str("**Tags:** ");
                for (i, tag) in finding.tags.iter().enumerate() {
                    if i > 0 {
                        md.push_str(", ");
                    }
                    md.push_str(&format!("`{}`", tag));
                }
                md.push_str("\n\n");
            }

            md.push_str("---\n\n");
        }

        // Footer
        md.push_str("*Generated by **redblue** - Security Assessment Toolkit*\n");

        md
    }

    /// Create severity badge
    fn severity_badge(severity: &Severity) -> &'static str {
        match severity {
            Severity::Critical => "ðŸ”´ **CRITICAL**",
            Severity::High => "ðŸŸ  **HIGH**",
            Severity::Medium => "ðŸŸ¡ **MEDIUM**",
            Severity::Low => "ðŸŸ¢ **LOW**",
            Severity::Info => "ðŸ”µ **INFO**",
        }
    }

    /// Escape markdown special characters in table cells
    fn escape_md(s: &str) -> String {
        s.replace('|', "\\|")
         .replace('\n', " ")
         .replace('\r', "")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::modules::report::Finding;

    #[test]
    fn test_markdown_export() {
        let mut report = Report::new("Test Report", "example.com");
        report.add_finding(Finding::new("Test Finding", Severity::High)
            .with_description("This is a test"));

        let md = MarkdownExporter::export(&report);
        assert!(md.contains("# Test Report"));
        assert!(md.contains("ðŸŸ  **HIGH**"));
    }

    #[test]
    fn test_escape_md() {
        assert_eq!(MarkdownExporter::escape_md("test|pipe"), "test\\|pipe");
        assert_eq!(MarkdownExporter::escape_md("multi\nline"), "multi line");
    }
}
