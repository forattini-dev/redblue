//! Exploit-DB Scraper
//!
//! Search and scrape exploit information from Exploit-DB.
//!
//! Site: https://www.exploit-db.com/
//!
//! Uses HTML scraping since there's no public API.

use super::types::{ExploitRef, VulnSource, Vulnerability};
use crate::modules::web::dom::Document;
use crate::protocols::http::HttpClient;

const EXPLOITDB_SEARCH_URL: &str = "https://www.exploit-db.com/search";
const EXPLOITDB_EXPLOIT_URL: &str = "https://www.exploit-db.com/exploits";

/// Exploit-DB search result
#[derive(Debug, Clone)]
pub struct ExploitDbEntry {
    /// Exploit-DB ID (EDB-ID)
    pub id: String,
    /// Exploit title
    pub title: String,
    /// Platform (windows, linux, etc.)
    pub platform: Option<String>,
    /// Exploit type (remote, local, webapps, etc.)
    pub exploit_type: Option<String>,
    /// Date published
    pub date: Option<String>,
    /// Author
    pub author: Option<String>,
    /// Associated CVE IDs
    pub cve_ids: Vec<String>,
    /// Verified by Exploit-DB
    pub verified: bool,
    /// Download URL
    pub download_url: Option<String>,
    /// Application/software affected
    pub application: Option<String>,
    /// Version affected
    pub version: Option<String>,
}

impl ExploitDbEntry {
    /// Convert to ExploitRef for integration with Vulnerability type
    pub fn to_exploit_ref(&self) -> ExploitRef {
        ExploitRef {
            source: "Exploit-DB".to_string(),
            url: format!("{}/{}", EXPLOITDB_EXPLOIT_URL, self.id),
            title: Some(self.title.clone()),
            exploit_type: self.exploit_type.clone(),
        }
    }
}

/// Exploit-DB client
pub struct ExploitDbClient {
    http: HttpClient,
}

impl ExploitDbClient {
    /// Create new Exploit-DB client
    pub fn new() -> Self {
        Self {
            http: HttpClient::new(),
        }
    }

    /// Search Exploit-DB by CVE ID
    pub fn search_by_cve(&self, cve_id: &str) -> Result<Vec<ExploitDbEntry>, String> {
        self.search(cve_id)
    }

    /// Search Exploit-DB by product/technology name
    pub fn search_by_product(
        &self,
        product: &str,
        version: Option<&str>,
    ) -> Result<Vec<ExploitDbEntry>, String> {
        let query = if let Some(ver) = version {
            format!("{} {}", product, ver)
        } else {
            product.to_string()
        };
        self.search(&query)
    }

    /// General search
    pub fn search(&self, query: &str) -> Result<Vec<ExploitDbEntry>, String> {
        // Build search URL with query parameter
        let url = format!("{}?q={}", EXPLOITDB_SEARCH_URL, urlencoding(query));

        let response = self.http.get(&url)?;

        if response.status_code != 200 {
            return Err(format!("Exploit-DB error: HTTP {}", response.status_code));
        }

        let body = String::from_utf8_lossy(&response.body).to_string();
        self.parse_search_results(&body)
    }

    /// Get exploit details by ID
    pub fn get_exploit(&self, exploit_id: &str) -> Result<Option<ExploitDbEntry>, String> {
        let url = format!("{}/{}", EXPLOITDB_EXPLOIT_URL, exploit_id);

        let response = self.http.get(&url)?;

        if response.status_code == 404 {
            return Ok(None);
        }

        if response.status_code != 200 {
            return Err(format!("Exploit-DB error: HTTP {}", response.status_code));
        }

        let body = String::from_utf8_lossy(&response.body).to_string();
        self.parse_exploit_page(&body, exploit_id)
    }

    /// Enrich vulnerability with Exploit-DB data
    pub fn enrich_vulnerability(&self, vuln: &mut Vulnerability) -> Result<(), String> {
        // Search by CVE ID
        let results = self.search_by_cve(&vuln.id)?;

        for entry in results {
            // Verify this exploit is actually for this CVE
            if entry.cve_ids.iter().any(|c| c == &vuln.id) {
                vuln.exploits.push(entry.to_exploit_ref());

                if !vuln.sources.contains(&VulnSource::ExploitDb) {
                    vuln.sources.push(VulnSource::ExploitDb);
                }
            }
        }

        Ok(())
    }

    /// Parse search results HTML
    fn parse_search_results(&self, html: &str) -> Result<Vec<ExploitDbEntry>, String> {
        let doc = Document::parse(html);
        let mut results = Vec::new();

        // Exploit-DB uses a table with id="exploits-table"
        // Each row contains: Date, Verified, Title, Type, Platform, Author
        // The table uses DataTables so actual data might be in JSON or in table rows

        // Try to find table rows
        let rows = doc.select("table#exploits-table tbody tr");

        for row in rows.iter() {
            if let Some(entry) = self.parse_table_row(&doc, row) {
                results.push(entry);
            }
        }

        // If no results from table, try alternative selectors
        // Exploit-DB might load data via JavaScript/AJAX
        if results.is_empty() {
            // Try parsing any exploit cards or divs
            let cards = doc.select(".exploit-card, .card, [data-exploit-id]");
            for card in cards.iter() {
                if let Some(entry) = self.parse_exploit_card(&doc, card) {
                    results.push(entry);
                }
            }
        }

        // Also try to extract from inline JavaScript data
        if results.is_empty() {
            results = self.parse_json_data(html)?;
        }

        Ok(results)
    }

    /// Parse a table row from search results
    fn parse_table_row(
        &self,
        doc: &Document,
        row: &crate::modules::web::dom::Element,
    ) -> Option<ExploitDbEntry> {
        let cell_indices = select_within_indices(doc, row.self_index, "td");

        if cell_indices.len() < 4 {
            return None;
        }

        // Try to extract exploit ID from link
        let link_indices = select_within_indices(doc, row.self_index, "a[href*='/exploits/']");
        let (id, title) = if let Some(&idx) = link_indices.first() {
            if let Some(a) = doc.get_element(idx) {
                let href = a.attr("href").cloned().unwrap_or_default();
                let id = href.rsplit('/').next().unwrap_or("").to_string();
                let title = doc.element_text(idx);
                (id, title)
            } else {
                return None;
            }
        } else {
            return None;
        };

        if id.is_empty() {
            return None;
        }

        // Extract other fields from cells
        let date = cell_indices
            .get(0)
            .map(|&idx| doc.element_text(idx).trim().to_string());
        let verified = cell_indices
            .get(1)
            .map(|&idx| {
                let text = doc.element_text(idx);
                text.contains("âœ“") || text.to_lowercase().contains("verified")
            })
            .unwrap_or(false);

        let exploit_type = cell_indices
            .get(3)
            .map(|&idx| doc.element_text(idx).trim().to_string());
        let platform = cell_indices
            .get(4)
            .map(|&idx| doc.element_text(idx).trim().to_string());
        let author = cell_indices
            .get(5)
            .map(|&idx| doc.element_text(idx).trim().to_string());

        // Try to extract CVE from title or separate column
        let cve_ids = extract_cve_ids(&title);

        Some(ExploitDbEntry {
            id,
            title,
            platform,
            exploit_type,
            date,
            author,
            cve_ids,
            verified,
            download_url: None,
            application: None,
            version: None,
        })
    }

    /// Parse exploit card element
    fn parse_exploit_card(
        &self,
        doc: &Document,
        card: &crate::modules::web::dom::Element,
    ) -> Option<ExploitDbEntry> {
        // Try to get ID from data attribute or link
        let id = card.attr("data-exploit-id").cloned().or_else(|| {
            let link_indices = select_within_indices(doc, card.self_index, "a[href*='/exploits/']");
            link_indices.first().and_then(|&idx| {
                doc.get_element(idx).and_then(|a| {
                    a.attr("href")
                        .and_then(|href| href.rsplit('/').next().map(|s| s.to_string()))
                })
            })
        })?;

        let title_indices =
            select_within_indices(doc, card.self_index, ".title, .card-title, h3, h4");
        let title = title_indices
            .first()
            .map(|&idx| doc.element_text(idx))
            .unwrap_or_default();

        if title.is_empty() {
            return None;
        }

        let cve_ids = extract_cve_ids(&title);

        Some(ExploitDbEntry {
            id,
            title,
            platform: None,
            exploit_type: None,
            date: None,
            author: None,
            cve_ids,
            verified: false,
            download_url: None,
            application: None,
            version: None,
        })
    }

    /// Parse JSON data embedded in page (DataTables often uses this)
    fn parse_json_data(&self, html: &str) -> Result<Vec<ExploitDbEntry>, String> {
        let mut results = Vec::new();

        // Look for JSON data in script tags or inline
        // Pattern: "data": [...] or similar

        // Find exploit entries in format {"id": "...", "title": "..."}
        let mut pos = 0;
        while let Some(start) = html[pos..].find("\"id_exploit\"") {
            let abs_start = pos + start;

            // Find the containing object
            if let Some(obj_start) = html[..abs_start].rfind('{') {
                if let Some(obj_end) = find_matching_brace(&html[obj_start..]) {
                    let json_str = &html[obj_start..obj_start + obj_end + 1];
                    if let Some(entry) = parse_exploit_json(json_str) {
                        results.push(entry);
                    }
                }
            }

            pos = abs_start + 1;
        }

        Ok(results)
    }

    /// Parse single exploit page
    fn parse_exploit_page(
        &self,
        html: &str,
        exploit_id: &str,
    ) -> Result<Option<ExploitDbEntry>, String> {
        let doc = Document::parse(html);

        // Title from h1 or .card-title
        let title = doc
            .select("h1, .card-title, .exploit-title")
            .first()
            .map(|e| doc.element_text(e.self_index))
            .unwrap_or_default();

        if title.is_empty() {
            return Ok(None);
        }

        // Extract metadata from the info table/list
        let mut platform = None;
        let mut exploit_type = None;
        let mut date = None;
        let mut author = None;
        let mut cve_ids = Vec::new();
        let mut verified = false;
        let mut application = None;
        let mut version = None;

        // Look for info rows (Exploit-DB uses dl/dt/dd or table rows)
        let info_items = doc.select(".info-row, dl dt, table.exploit-info tr th");

        for item in info_items.iter() {
            let label = doc.element_text(item.self_index).to_lowercase();

            // Find corresponding value
            let value = if label.contains("platform") {
                let val = get_next_sibling_text(&doc, item);
                platform = Some(val.clone());
                val
            } else if label.contains("type") {
                let val = get_next_sibling_text(&doc, item);
                exploit_type = Some(val.clone());
                val
            } else if label.contains("date") {
                let val = get_next_sibling_text(&doc, item);
                date = Some(val.clone());
                val
            } else if label.contains("author") {
                let val = get_next_sibling_text(&doc, item);
                author = Some(val.clone());
                val
            } else if label.contains("cve") {
                let val = get_next_sibling_text(&doc, item);
                cve_ids = extract_cve_ids(&val);
                val
            } else if label.contains("verified") {
                verified = true;
                String::new()
            } else if label.contains("software") || label.contains("application") {
                let val = get_next_sibling_text(&doc, item);
                application = Some(val.clone());
                val
            } else if label.contains("version") {
                let val = get_next_sibling_text(&doc, item);
                version = Some(val.clone());
                val
            } else {
                String::new()
            };

            let _ = value; // suppress unused warning
        }

        // Also extract CVEs from title
        let title_cves = extract_cve_ids(&title);
        for cve in title_cves {
            if !cve_ids.contains(&cve) {
                cve_ids.push(cve);
            }
        }

        // Download URL
        let download_url = doc
            .select("a[href*='/download/']")
            .first()
            .and_then(|a| a.attr("href").cloned());

        Ok(Some(ExploitDbEntry {
            id: exploit_id.to_string(),
            title,
            platform,
            exploit_type,
            date,
            author,
            cve_ids,
            verified,
            download_url,
            application,
            version,
        }))
    }
}

impl Default for ExploitDbClient {
    fn default() -> Self {
        Self::new()
    }
}

/// Check if element is descendant of another
fn is_descendant_of(doc: &Document, element_idx: usize, ancestor_idx: usize) -> bool {
    if let Some(elem) = doc.get_element(element_idx) {
        let mut current = elem.parent_index;
        while let Some(parent_idx) = current {
            if parent_idx == ancestor_idx {
                return true;
            }
            if let Some(parent) = doc.get_element(parent_idx) {
                current = parent.parent_index;
            } else {
                break;
            }
        }
    }
    false
}

/// Select element indices within a specific parent element
fn select_within_indices(doc: &Document, parent_idx: usize, selector: &str) -> Vec<usize> {
    doc.select(selector)
        .iter()
        .filter(|e| is_descendant_of(doc, e.self_index, parent_idx))
        .map(|e| e.self_index)
        .collect()
}

/// Get text from next sibling element
fn get_next_sibling_text(doc: &Document, elem: &crate::modules::web::dom::Element) -> String {
    // For dt/dd pairs, find the dd
    // For th/td pairs in a row, find the td
    if let Some(parent_idx) = elem.parent_index {
        if let Some(parent) = doc.get_element(parent_idx) {
            let mut found_current = false;
            for child in &parent.children {
                if let crate::modules::web::dom::Node::ElementRef(idx) = child {
                    if *idx == elem.self_index {
                        found_current = true;
                    } else if found_current {
                        if let Some(next) = doc.get_element(*idx) {
                            return doc.element_text(next.self_index);
                        }
                    }
                }
            }
        }
    }
    String::new()
}

/// Extract CVE IDs from text
fn extract_cve_ids(text: &str) -> Vec<String> {
    let mut cves = Vec::new();
    let upper = text.to_uppercase();

    // Pattern: CVE-YYYY-NNNNN
    let mut i = 0;
    while i < upper.len() {
        if let Some(pos) = upper[i..].find("CVE-") {
            let start = i + pos;
            let rest = &upper[start..];

            // Parse CVE-YYYY-NNNNN format
            if rest.len() >= 13 {
                // "CVE-YYYY-NNNNN" minimum
                let potential = &rest[..rest
                    .find(|c: char| !c.is_ascii_alphanumeric() && c != '-')
                    .unwrap_or(rest.len())];

                // Validate format
                if is_valid_cve(potential) {
                    cves.push(potential.to_string());
                }
            }
            i = start + 4;
        } else {
            break;
        }
    }

    cves
}

/// Validate CVE ID format
fn is_valid_cve(s: &str) -> bool {
    // Format: CVE-YYYY-NNNNN (N can be 4-7 digits)
    if !s.starts_with("CVE-") {
        return false;
    }

    let parts: Vec<&str> = s.split('-').collect();
    if parts.len() != 3 {
        return false;
    }

    // Year should be 4 digits, 1999-2099
    if parts[1].len() != 4 {
        return false;
    }
    if let Ok(year) = parts[1].parse::<u32>() {
        if !(1999..=2099).contains(&year) {
            return false;
        }
    } else {
        return false;
    }

    // ID should be 4-7 digits
    if parts[2].len() < 4 || parts[2].len() > 7 {
        return false;
    }
    if parts[2].chars().any(|c| !c.is_ascii_digit()) {
        return false;
    }

    true
}

/// Find matching closing brace
fn find_matching_brace(s: &str) -> Option<usize> {
    let mut depth = 0;
    let mut in_string = false;
    let mut escape = false;

    for (i, c) in s.char_indices() {
        if escape {
            escape = false;
            continue;
        }

        match c {
            '\\' if in_string => escape = true,
            '"' => in_string = !in_string,
            '{' if !in_string => depth += 1,
            '}' if !in_string => {
                depth -= 1;
                if depth == 0 {
                    return Some(i);
                }
            }
            _ => {}
        }
    }

    None
}

/// Parse exploit entry from JSON object string
fn parse_exploit_json(json_str: &str) -> Option<ExploitDbEntry> {
    // Simple JSON parsing for exploit data
    // Format: {"id_exploit": "123", "title": "...", ...}

    let id = extract_json_string(json_str, "id_exploit")
        .or_else(|| extract_json_string(json_str, "id"))?;

    let title = extract_json_string(json_str, "title")
        .or_else(|| extract_json_string(json_str, "description"))
        .unwrap_or_default();

    if title.is_empty() {
        return None;
    }

    let platform = extract_json_string(json_str, "platform");
    let exploit_type = extract_json_string(json_str, "type");
    let date = extract_json_string(json_str, "date");
    let author = extract_json_string(json_str, "author");
    let verified = json_str.contains("\"verified\":true") || json_str.contains("\"verified\":1");

    let cve_str = extract_json_string(json_str, "cve").unwrap_or_default();
    let cve_ids = extract_cve_ids(&cve_str);

    Some(ExploitDbEntry {
        id,
        title,
        platform,
        exploit_type,
        date,
        author,
        cve_ids,
        verified,
        download_url: None,
        application: None,
        version: None,
    })
}

/// Extract string value from JSON
fn extract_json_string(json: &str, key: &str) -> Option<String> {
    let pattern = format!("\"{}\":", key);
    let pos = json.find(&pattern)?;
    let rest = &json[pos + pattern.len()..];
    let rest = rest.trim_start();

    if rest.starts_with('"') {
        // String value
        let start = 1;
        let mut end = start;
        let mut escape = false;

        for c in rest[start..].chars() {
            if escape {
                escape = false;
                end += c.len_utf8();
            } else if c == '\\' {
                escape = true;
                end += 1;
            } else if c == '"' {
                break;
            } else {
                end += c.len_utf8();
            }
        }

        Some(rest[start..end].to_string())
    } else if rest.starts_with("null") {
        None
    } else {
        // Number or other value - take until comma or brace
        let end = rest.find(|c| c == ',' || c == '}').unwrap_or(rest.len());
        Some(rest[..end].trim().to_string())
    }
}

/// URL encode a string
fn urlencoding(s: &str) -> String {
    let mut result = String::with_capacity(s.len() * 3);
    for c in s.chars() {
        match c {
            'A'..='Z' | 'a'..='z' | '0'..='9' | '-' | '_' | '.' | '~' => {
                result.push(c);
            }
            ' ' => result.push_str("%20"),
            _ => {
                for byte in c.to_string().as_bytes() {
                    result.push_str(&format!("%{:02X}", byte));
                }
            }
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_cve_ids() {
        let text = "Apache Struts CVE-2017-5638 Remote Code Execution";
        let cves = extract_cve_ids(text);
        assert_eq!(cves, vec!["CVE-2017-5638"]);
    }

    #[test]
    fn test_extract_multiple_cves() {
        let text = "Multiple vulns: CVE-2021-44228, CVE-2021-45046";
        let cves = extract_cve_ids(text);
        assert_eq!(cves.len(), 2);
        assert!(cves.contains(&"CVE-2021-44228".to_string()));
        assert!(cves.contains(&"CVE-2021-45046".to_string()));
    }

    #[test]
    fn test_is_valid_cve() {
        assert!(is_valid_cve("CVE-2021-44228"));
        assert!(is_valid_cve("CVE-2023-12345"));
        assert!(!is_valid_cve("CVE-21-44228")); // Invalid year
        assert!(!is_valid_cve("CVE-2021-123")); // Too short ID
        assert!(!is_valid_cve("CVE-2021-12345678")); // Too long ID
    }

    #[test]
    fn test_urlencoding() {
        assert_eq!(urlencoding("hello world"), "hello%20world");
        assert_eq!(urlencoding("nginx 1.18"), "nginx%201.18");
        assert_eq!(urlencoding("test@example"), "test%40example");
    }

    #[test]
    fn test_find_matching_brace() {
        assert_eq!(find_matching_brace("{\"a\": 1}"), Some(7));
        assert_eq!(find_matching_brace("{\"a\": {\"b\": 2}}"), Some(14));
        assert_eq!(find_matching_brace("{\"a\": \"}\"}"), Some(9)); // Quoted brace
    }

    #[test]
    fn test_extract_json_string() {
        let json = r#"{"id": "12345", "title": "Test Exploit"}"#;
        assert_eq!(extract_json_string(json, "id"), Some("12345".to_string()));
        assert_eq!(
            extract_json_string(json, "title"),
            Some("Test Exploit".to_string())
        );
        assert_eq!(extract_json_string(json, "missing"), None);
    }

    #[test]
    fn test_exploit_entry_to_ref() {
        let entry = ExploitDbEntry {
            id: "12345".to_string(),
            title: "Test Exploit".to_string(),
            platform: Some("linux".to_string()),
            exploit_type: Some("remote".to_string()),
            date: None,
            author: None,
            cve_ids: vec!["CVE-2021-1234".to_string()],
            verified: true,
            download_url: None,
            application: None,
            version: None,
        };

        let ref_ = entry.to_exploit_ref();
        assert_eq!(ref_.source, "Exploit-DB");
        assert!(ref_.url.contains("12345"));
        assert_eq!(ref_.title, Some("Test Exploit".to_string()));
    }
}
