# Design: Pentest Workflow Integration

## Implementation Progress

| Component | Status | Notes |
|-----------|--------|-------|
| Record types (VulnerabilityRecord, etc.) | âœ… Done | In `src/storage/records.rs` |
| FingerprintSegment | âœ… Done | In `src/storage/segments/fingerprints.rs` |
| VulnSegment | âœ… Done | In `src/storage/segments/vuln.rs` |
| ExploitSegment | â³ Pending | - |
| SessionSegment | â³ Pending | - |
| PlaybookSegment | â³ Pending | - |
| CLI Commands | â³ Pending | - |
| Shell Integration | â³ Pending | - |

## Context

redblue stores security scan data in RedDB (segment-based database with encryption). The current architecture has:
- **Existing segments**: PortSegment, SubdomainSegment, WhoisSegment, TlsSegment, DnsSegment, HttpSegment, HostSegment, ProxySegment
- **Existing modules**: `src/modules/recon/vuln/` with NVD, OSV, KEV, Exploit-DB clients
- **Existing CLI**: 60+ commands with kubectl-style routing

This design adds cross-cutting integration between stored data and active operations.

## Existing Resources (Ready to Leverage)

### Vulnerability Intelligence Module
Location: `src/modules/recon/vuln/`

| File | Purpose | API |
|------|---------|-----|
| `cpe.rs` | CPE dictionary (60+ technologies) | `get_cpe(tech, version)` |
| `nvd.rs` | NVD API client | `query_cve(cpe)` |
| `osv.rs` | OSV.dev API client | `query_package(name, ecosystem)` |
| `kev.rs` | CISA KEV client | `is_known_exploited(cve_id)` |
| `exploitdb.rs` | Exploit-DB scraper | `search_exploits(query)` |
| `risk.rs` | Risk score calculator | `calculate_risk(cvss, has_exploit, in_kev)` |
| `types.rs` | Core vulnerability types | `Vulnerability`, `Severity` |

### Scripting Engine
Location: `src/modules/scripting/`

| File | Purpose | Can Be Extended For |
|------|---------|---------------------|
| `engine.rs` | Script executor | Playbook step execution |
| `definitions.rs` | Script definitions | Playbook step types |
| `loader.rs` | Script loader | Playbook YAML loading |
| `runner.rs` | Script runner | Playbook phase execution |

**Already supports:**
- `ScriptStep::HttpRequest` - HTTP requests with status/body matching
- `ScriptStep::TcpConnect` - TCP connection tests
- Variable substitution for target

### TUI Shell
Location: `src/cli/tui.rs`

Existing interactive shell that can be extended with:
- Database context loading
- Status bar with target intelligence
- Quick command dispatch

### YAML Parser
Location: `src/config/yaml.rs`

Can parse YAML configuration files - extend for playbook format.

## Goals / Non-Goals

### Goals
- Enable re-verification of discovered ports with state change detection
- Automate fingerprint â†’ CVE correlation using stored data
- Generate actionable attack plans from vulnerability data
- Support predefined and custom playbooks for automated workflows
- Enhance shell with database-aware context and quick commands

### Non-Goals
- Building a full-fledged vulnerability scanner (use existing modules)
- Real-time network monitoring daemon (redblue is CLI-focused)
- GUI interface (TUI only)
- Cloud-based storage (local database only)

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              CLI / Shell                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  network ports check  â”‚  vuln correlate  â”‚  exploit plan  â”‚  playbook   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
            â”‚                    â”‚                 â”‚               â”‚
            â–¼                    â–¼                 â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Port Health Engineâ”‚  â”‚ Vuln Correlator â”‚  â”‚ Exploit Plannerâ”‚  â”‚ Playbook â”‚
â”‚   - Diff engine   â”‚  â”‚   - CPE mapper  â”‚  â”‚   - Attack DB  â”‚  â”‚  Engine  â”‚
â”‚   - State tracker â”‚  â”‚   - Multi-sourceâ”‚  â”‚   - Chain calc â”‚  â”‚  - YAML  â”‚
â”‚   - Alert system  â”‚  â”‚   - Risk scorer â”‚  â”‚   - Suggest    â”‚  â”‚  - Steps â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
          â”‚                     â”‚                   â”‚               â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            RedDB Storage                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PortSegment â”‚ VulnSegment â”‚ FingerprintSegment â”‚ PlaybookSegment â”‚ ... â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Decisions

### Decision 1: New Database Segments

**What**: Add 4 new segments to RedDB
**Why**: Store vulnerability, fingerprint, exploit attempt, and playbook data with proper indexing

```rust
// New segments
pub struct VulnSegment { ... }         // CVE data indexed by target
pub struct FingerprintSegment { ... }  // Tech fingerprints with CPE
pub struct ExploitSegment { ... }      // Exploit attempt history
pub struct PlaybookSegment { ... }     // Playbook run history
```

**Alternatives considered**:
- Single generic segment with type field â†’ Rejected: poor query performance
- External JSON files â†’ Rejected: loses encryption and indexing benefits

### Decision 2: Port State Diff Algorithm

**What**: Track port state changes using timestamp-based comparison
**Why**: Enable detection of newly opened/closed ports

```rust
pub struct PortHealthRecord {
    pub ip: IpAddr,
    pub port: u16,
    pub previous_state: PortState,    // Open/Closed/Filtered
    pub current_state: PortState,
    pub first_seen: u32,              // timestamp
    pub last_seen: u32,               // timestamp
    pub state_changed_at: Option<u32>,
    pub check_count: u32,
}

// Diff algorithm
fn calculate_port_diff(stored: &[PortScanRecord], current: &[PortScanRecord]) -> PortDiff {
    let stored_set: HashSet<_> = stored.iter().filter(|p| p.is_open()).map(|p| p.port).collect();
    let current_set: HashSet<_> = current.iter().filter(|p| p.is_open()).map(|p| p.port).collect();

    PortDiff {
        still_open: stored_set.intersection(&current_set).collect(),
        now_closed: stored_set.difference(&current_set).collect(),
        new_open: current_set.difference(&stored_set).collect(),
    }
}
```

### Decision 3: CVE Correlation Pipeline

**What**: Multi-source CVE lookup with deduplication and risk scoring
**Why**: Aggregate vulnerability data from NVD, OSV, KEV, Exploit-DB

```
Pipeline stages:
1. Load fingerprints from FingerprintSegment
2. Map technologies to CPE identifiers (cpe.rs)
3. Query sources in parallel:
   - NVD: CPE-based query
   - OSV: Package ecosystem query (if applicable)
   - KEV: Check if CVE is known exploited
   - Exploit-DB: Search for public exploits
4. Deduplicate by CVE-ID
5. Calculate risk score: (CVSS Ã— 10) + KEV(+30) + Exploit(+25) + Age bonus
6. Store in VulnSegment with target association
7. Return sorted by risk score
```

### Decision 4: Attack Plan Generation

**What**: Rule-based attack path planning
**Why**: Suggest realistic attack chains based on discovered vulnerabilities

```rust
pub struct AttackPlan {
    pub phases: Vec<AttackPhase>,
}

pub struct AttackPhase {
    pub name: String,           // "Initial Access", "Privilege Escalation", etc.
    pub options: Vec<AttackOption>,
}

pub struct AttackOption {
    pub technique: String,      // MITRE ATT&CK technique
    pub target: String,         // Host:port or service
    pub cve: Option<String>,    // Associated CVE if applicable
    pub exploit: Option<String>,// Exploit reference
    pub confidence: u8,         // 0-100
    pub command: String,        // Suggested rb command
}
```

**Phase mapping**:
1. **Initial Access**: Web exploits, SSH bruteforce, public exploits
2. **Privilege Escalation**: SUID, kernel exploits, sudo misconfig
3. **Lateral Movement**: SSH keys, credential reuse, pivoting
4. **Persistence**: Cron, systemd, authorized_keys

### Decision 5: Playbook Format

**What**: YAML-based playbook definition
**Why**: Human-readable, easy to create custom playbooks

```yaml
# ~/.redblue/playbooks/web-app-pentest.yaml
name: web-app-pentest
description: Complete web application penetration test
version: 1.0.0
author: redblue

variables:
  timeout: 30
  threads: 100

phases:
  - name: reconnaissance
    parallel: true
    steps:
      - command: rb recon domain subdomains {target}
        store: subdomains
      - command: rb recon domain whois {target}
        store: whois
      - command: rb dns record lookup {target} --type ANY
        store: dns

  - name: fingerprinting
    steps:
      - command: rb network ports scan {target} --preset web
        store: ports
      - command: rb web asset headers https://{target}
        store: headers
      - command: rb tls security audit {target}
        store: tls

  - name: vulnerability_scan
    condition: ports.open_count > 0
    steps:
      - command: rb vuln correlate {target}
        store: vulns

  - name: exploitation
    condition: vulns.critical_count > 0
    manual: true  # Requires user confirmation
    steps:
      - command: rb exploit suggest {target}
        prompt: "Select exploit to run (or skip):"

  - name: reporting
    steps:
      - command: rb report generate {target} --format html
        output: report_{target}_{timestamp}.html
```

### Decision 6: Shell Integration

**What**: Enhanced shell with database context
**Why**: Provide real-time target intelligence and quick commands

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ğŸ”´ redblue shell â”‚ target: example.com â”‚ db: ~/.redblue/example.com.rbdb â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

â”Œâ”€ Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ports: 5 open â”‚ Subdomains: 47 â”‚ CVEs: 8 (2 critical) â”‚ Last: 2m ago   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

redblue:example.com> _
```

**Quick commands in shell**:
- `ports` â†’ Show stored ports
- `vulns` â†’ Show stored vulnerabilities
- `check` â†’ Re-verify ports
- `watch` â†’ Start port monitoring
- `plan` â†’ Show attack plan
- `run <playbook>` â†’ Execute playbook

## Data Models

### VulnerabilityRecord

```rust
pub struct VulnerabilityRecord {
    pub cve_id: String,           // CVE-2021-44228
    pub technology: String,       // log4j
    pub version: Option<String>,  // 2.14.0
    pub cvss: f32,                // 10.0
    pub risk_score: u8,           // 0-100 calculated
    pub severity: Severity,       // Critical/High/Medium/Low
    pub description: String,      // Brief description
    pub references: Vec<String>,  // Reference URLs
    pub exploit_available: bool,  // Has public exploit
    pub in_kev: bool,             // CISA Known Exploited
    pub discovered_at: u32,       // Unix timestamp
    pub source: String,           // nvd/osv/kev/exploitdb
}
```

### FingerprintRecord

```rust
pub struct FingerprintRecord {
    pub host: String,             // example.com
    pub port: u16,                // 443
    pub technology: String,       // nginx
    pub version: Option<String>,  // 1.21.0
    pub cpe: Option<String>,      // cpe:2.3:a:nginx:nginx:1.21.0:*:*:*:*:*:*:*
    pub confidence: u8,           // 0-100
    pub source: String,           // banner/header/probe
    pub raw_banner: Option<String>,
    pub detected_at: u32,         // Unix timestamp
}
```

### ExploitAttemptRecord

```rust
pub struct ExploitAttemptRecord {
    pub id: String,               // UUID
    pub target: String,           // host:port
    pub cve_id: Option<String>,   // CVE-2021-44228
    pub exploit_name: String,     // log4shell.py
    pub technique: String,        // MITRE ATT&CK ID
    pub status: ExploitStatus,    // Success/Failed/Pending/Skipped
    pub output: Option<String>,   // Exploit output
    pub attempted_at: u32,        // Unix timestamp
    pub duration_ms: u32,         // Execution time
}
```

### PlaybookRunRecord

```rust
pub struct PlaybookRunRecord {
    pub id: String,               // UUID
    pub playbook_name: String,    // web-app-pentest
    pub target: String,           // example.com
    pub status: PlaybookStatus,   // Running/Completed/Failed/Cancelled
    pub current_phase: u8,        // Phase index
    pub current_step: u8,         // Step index within phase
    pub started_at: u32,          // Unix timestamp
    pub completed_at: Option<u32>,
    pub step_results: Vec<StepResult>,
    pub variables: HashMap<String, String>,
}
```

## Risks / Trade-offs

### Risk 1: CVE Data Staleness
**Risk**: Stored CVE data becomes outdated
**Mitigation**: Add `--refresh` flag to force re-query; show data age in output

### Risk 2: False Positive Fingerprints
**Risk**: Incorrect technology detection leads to wrong CVE mapping
**Mitigation**: Include confidence score; require minimum confidence for CVE lookup

### Risk 3: Playbook Complexity
**Risk**: Complex playbooks become hard to debug
**Mitigation**: Add `--dry-run` flag; verbose logging; step-by-step mode

### Risk 4: Shell State Management
**Risk**: Shell state conflicts with CLI command state
**Mitigation**: Shell uses same PersistenceManager; auto-reload on external changes

## Migration Plan

1. **Phase 1**: Add new record types and segments (no breaking changes)
2. **Phase 2**: Implement port health check commands
3. **Phase 3**: Implement vuln correlation commands
4. **Phase 4**: Implement exploit planning commands
5. **Phase 5**: Implement playbook engine
6. **Phase 6**: Enhance shell with database integration

No data migration needed - new segments are additive.

## Open Questions

1. Should playbooks support loops/conditionals beyond simple conditions?
   - **Current decision**: Simple conditions only (MVP)

2. Should we cache CVE data globally or per-target?
   - **Current decision**: Per-target for isolation

3. Should shell auto-refresh data on interval?
   - **Current decision**: Manual refresh with `check` command (reduces API calls)
